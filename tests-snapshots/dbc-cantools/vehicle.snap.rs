// Generated code!
//
// Message definitions from file `vehicle`
// Version: 

#[allow(unused_imports)]
use core::ops::BitOr;
#[allow(unused_imports)]
use bitvec::prelude::*;
#[allow(unused_imports)]
use embedded_can::{Id, StandardId, ExtendedId};

/// All messages
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone)]
pub enum Messages {
    /// RT_SB_INS_Vel_Body_Axes
    RtSbInsVelBodyAxes(RtSbInsVelBodyAxes),
    /// RT_DL1MK3_Speed
    RtDl1mk3Speed(RtDl1mk3Speed),
    /// RT_DL1MK3_GPS_Time
    RtDl1mk3GpsTime(RtDl1mk3GpsTime),
    /// RT_DL1MK3_GPS_Pos_LLH_2
    RtDl1mk3GpsPosLlh2(RtDl1mk3GpsPosLlh2),
    /// RT_DL1MK3_GPS_Pos_LLH_1
    RtDl1mk3GpsPosLlh1(RtDl1mk3GpsPosLlh1),
    /// RT_DL1MK3_GPS_Speed
    RtDl1mk3GpsSpeed(RtDl1mk3GpsSpeed),
    /// RT_IRTemp_Temp_7
    RtIrTempTemp7(RtIrTempTemp7),
    /// RT_IRTemp_Temp_RR_2
    RtIrTempTempRr2(RtIrTempTempRr2),
    /// RT_IRTemp_Temp_RL_2
    RtIrTempTempRl2(RtIrTempTempRl2),
    /// RT_IRTemp_Temp_FR_2
    RtIrTempTempFr2(RtIrTempTempFr2),
    /// RT_IRTemp_Temp_FL_2
    RtIrTempTempFl2(RtIrTempTempFl2),
    /// RT_IRTemp_Temp_RR_1
    RtIrTempTempRr1(RtIrTempTempRr1),
    /// RT_IRTemp_Temp_RL_1
    RtIrTempTempRl1(RtIrTempTempRl1),
    /// RT_IRTemp_Temp_FR_1
    RtIrTempTempFr1(RtIrTempTempFr1),
    /// RT_IRTemp_Temp_FL_1
    RtIrTempTempFl1(RtIrTempTempFl1),
    /// RT_IRTemp_Temp_32
    RtIrTempTemp32(RtIrTempTemp32),
    /// RT_IRTemp_Temp_31
    RtIrTempTemp31(RtIrTempTemp31),
    /// RT_IRTemp_Temp_30
    RtIrTempTemp30(RtIrTempTemp30),
    /// RT_IRTemp_Temp_29
    RtIrTempTemp29(RtIrTempTemp29),
    /// RT_IRTemp_Temp_28
    RtIrTempTemp28(RtIrTempTemp28),
    /// RT_IRTemp_Temp_27
    RtIrTempTemp27(RtIrTempTemp27),
    /// RT_IRTemp_Temp_26
    RtIrTempTemp26(RtIrTempTemp26),
    /// RT_IRTemp_Temp_25
    RtIrTempTemp25(RtIrTempTemp25),
    /// RT_IRTemp_Temp_24
    RtIrTempTemp24(RtIrTempTemp24),
    /// RT_IRTemp_Temp_22
    RtIrTempTemp22(RtIrTempTemp22),
    /// RT_IRTemp_Temp_23
    RtIrTempTemp23(RtIrTempTemp23),
    /// RT_IRTemp_Temp_21
    RtIrTempTemp21(RtIrTempTemp21),
    /// RT_IRTemp_Temp_20
    RtIrTempTemp20(RtIrTempTemp20),
    /// RT_IRTemp_Temp_19
    RtIrTempTemp19(RtIrTempTemp19),
    /// RT_IRTemp_Temp_18
    RtIrTempTemp18(RtIrTempTemp18),
    /// RT_IRTemp_Temp_16
    RtIrTempTemp16(RtIrTempTemp16),
    /// RT_IRTemp_Temp_15
    RtIrTempTemp15(RtIrTempTemp15),
    /// RT_IRTemp_Temp_14
    RtIrTempTemp14(RtIrTempTemp14),
    /// RT_IRTemp_Temp_13
    RtIrTempTemp13(RtIrTempTemp13),
    /// RT_IRTemp_Temp_12
    RtIrTempTemp12(RtIrTempTemp12),
    /// RT_IRTemp_Temp_11
    RtIrTempTemp11(RtIrTempTemp11),
    /// RT_IRTemp_Temp_10
    RtIrTempTemp10(RtIrTempTemp10),
    /// RT_IRTemp_Temp_8
    RtIrTempTemp8(RtIrTempTemp8),
    /// RT_IRTemp_Temp_9
    RtIrTempTemp9(RtIrTempTemp9),
    /// RT_IRTemp_Temp_17
    RtIrTempTemp17(RtIrTempTemp17),
    /// RT_IRTemp_Temp_6
    RtIrTempTemp6(RtIrTempTemp6),
    /// RT_IRTemp_Temp_5
    RtIrTempTemp5(RtIrTempTemp5),
    /// RT_IRTemp_Temp_4
    RtIrTempTemp4(RtIrTempTemp4),
    /// RT_IRTemp_Temp_3
    RtIrTempTemp3(RtIrTempTemp3),
    /// RT_IRTemp_Temp_2
    RtIrTempTemp2(RtIrTempTemp2),
    /// RT_IRTemp_Temp_1
    RtIrTempTemp1(RtIrTempTemp1),
    /// RT_SB_Trig_Final_Condition
    RtSbTrigFinalCondition(RtSbTrigFinalCondition),
    /// RT_SB_Trig_Initial_Condition
    RtSbTrigInitialCondition(RtSbTrigInitialCondition),
    /// RT_SB_Trig_Direct_Dist
    RtSbTrigDirectDist(RtSbTrigDirectDist),
    /// RT_SB_Trig_Forward_Dist
    RtSbTrigForwardDist(RtSbTrigForwardDist),
    /// RT_SB_Trig_Path_Dist
    RtSbTrigPathDist(RtSbTrigPathDist),
    /// RT_SB_Trig_Accel
    RtSbTrigAccel(RtSbTrigAccel),
    /// RT_DL1MK3_Measure_Time_12
    RtDl1mk3MeasureTime12(RtDl1mk3MeasureTime12),
    /// RT_DL1MK3_Measure_Time_11
    RtDl1mk3MeasureTime11(RtDl1mk3MeasureTime11),
    /// RT_DL1MK3_Measure_Time_10
    RtDl1mk3MeasureTime10(RtDl1mk3MeasureTime10),
    /// RT_DL1MK3_Measure_Time_9
    RtDl1mk3MeasureTime9(RtDl1mk3MeasureTime9),
    /// RT_DL1MK3_Measure_Time_8
    RtDl1mk3MeasureTime8(RtDl1mk3MeasureTime8),
    /// RT_DL1MK3_Measure_Time_7
    RtDl1mk3MeasureTime7(RtDl1mk3MeasureTime7),
    /// RT_DL1MK3_Measure_Time_6
    RtDl1mk3MeasureTime6(RtDl1mk3MeasureTime6),
    /// RT_DL1MK3_Measure_Time_5
    RtDl1mk3MeasureTime5(RtDl1mk3MeasureTime5),
    /// RT_DL1MK3_Measure_Time_4
    RtDl1mk3MeasureTime4(RtDl1mk3MeasureTime4),
    /// RT_DL1MK3_Measure_Time_3
    RtDl1mk3MeasureTime3(RtDl1mk3MeasureTime3),
    /// RT_DL1MK3_Measure_Time_2
    RtDl1mk3MeasureTime2(RtDl1mk3MeasureTime2),
    /// RT_DL1MK3_Measure_Time_1
    RtDl1mk3MeasureTime1(RtDl1mk3MeasureTime1),
    /// RT_DL1MK3_RPM
    RtDl1mk3Rpm(RtDl1mk3Rpm),
    /// RT_DL1MK3_Freq_4
    RtDl1mk3Freq4(RtDl1mk3Freq4),
    /// RT_DL1MK3_Freq_3
    RtDl1mk3Freq3(RtDl1mk3Freq3),
    /// RT_DL1MK3_Freq_2
    RtDl1mk3Freq2(RtDl1mk3Freq2),
    /// RT_DL1MK3_Misc_3
    RtDl1mk3Misc3(RtDl1mk3Misc3),
    /// RT_DL1MK3_Misc_2
    RtDl1mk3Misc2(RtDl1mk3Misc2),
    /// RT_DL1MK3_Misc_1
    RtDl1mk3Misc1(RtDl1mk3Misc1),
    /// RT_DL1MK3_Aux_31
    RtDl1mk3Aux31(RtDl1mk3Aux31),
    /// RT_DL1MK3_Aux_30
    RtDl1mk3Aux30(RtDl1mk3Aux30),
    /// RT_DL1MK3_Aux_29
    RtDl1mk3Aux29(RtDl1mk3Aux29),
    /// RT_DL1MK3_Aux_28
    RtDl1mk3Aux28(RtDl1mk3Aux28),
    /// RT_DL1MK3_Aux_27
    RtDl1mk3Aux27(RtDl1mk3Aux27),
    /// RT_DL1MK3_Aux_26
    RtDl1mk3Aux26(RtDl1mk3Aux26),
    /// RT_DL1MK3_Aux_25
    RtDl1mk3Aux25(RtDl1mk3Aux25),
    /// RT_DL1MK3_Aux_24
    RtDl1mk3Aux24(RtDl1mk3Aux24),
    /// RT_DL1MK3_Aux_23
    RtDl1mk3Aux23(RtDl1mk3Aux23),
    /// RT_DL1MK3_Aux_22
    RtDl1mk3Aux22(RtDl1mk3Aux22),
    /// RT_DL1MK3_Aux_21
    RtDl1mk3Aux21(RtDl1mk3Aux21),
    /// RT_DL1MK3_Aux_20
    RtDl1mk3Aux20(RtDl1mk3Aux20),
    /// RT_DL1MK3_Aux_19
    RtDl1mk3Aux19(RtDl1mk3Aux19),
    /// RT_DL1MK3_Aux_18
    RtDl1mk3Aux18(RtDl1mk3Aux18),
    /// RT_DL1MK3_Aux_17
    RtDl1mk3Aux17(RtDl1mk3Aux17),
    /// RT_DL1MK3_Aux_16
    RtDl1mk3Aux16(RtDl1mk3Aux16),
    /// RT_DL1MK3_Aux_15
    RtDl1mk3Aux15(RtDl1mk3Aux15),
    /// RT_DL1MK3_Aux_14
    RtDl1mk3Aux14(RtDl1mk3Aux14),
    /// RT_DL1MK3_Aux_13
    RtDl1mk3Aux13(RtDl1mk3Aux13),
    /// RT_DL1MK3_Aux_12
    RtDl1mk3Aux12(RtDl1mk3Aux12),
    /// RT_DL1MK3_Aux_11
    RtDl1mk3Aux11(RtDl1mk3Aux11),
    /// RT_DL1MK3_Aux_9
    RtDl1mk3Aux9(RtDl1mk3Aux9),
    /// RT_DL1MK3_Aux_10
    RtDl1mk3Aux10(RtDl1mk3Aux10),
    /// RT_DL1MK3_Aux_8
    RtDl1mk3Aux8(RtDl1mk3Aux8),
    /// RT_DL1MK3_Aux_7
    RtDl1mk3Aux7(RtDl1mk3Aux7),
    /// RT_DL1MK3_Aux_6
    RtDl1mk3Aux6(RtDl1mk3Aux6),
    /// RT_DL1MK3_Aux_5
    RtDl1mk3Aux5(RtDl1mk3Aux5),
    /// RT_DL1MK3_Aux_4
    RtDl1mk3Aux4(RtDl1mk3Aux4),
    /// RT_DL1MK3_Aux_3
    RtDl1mk3Aux3(RtDl1mk3Aux3),
    /// RT_DL1MK3_Aux_2
    RtDl1mk3Aux2(RtDl1mk3Aux2),
    /// RT_DL1MK3_Aux_1
    RtDl1mk3Aux1(RtDl1mk3Aux1),
    /// RT_DL1MK3_Pressure_5
    RtDl1mk3Pressure5(RtDl1mk3Pressure5),
    /// RT_DL1MK3_Pressure_4
    RtDl1mk3Pressure4(RtDl1mk3Pressure4),
    /// RT_DL1MK3_Pressure_3
    RtDl1mk3Pressure3(RtDl1mk3Pressure3),
    /// RT_DL1MK3_Pressure_2
    RtDl1mk3Pressure2(RtDl1mk3Pressure2),
    /// RT_DL1MK3_Pressure_1
    RtDl1mk3Pressure1(RtDl1mk3Pressure1),
    /// RT_DL1MK3_Angle_3
    RtDl1mk3Angle3(RtDl1mk3Angle3),
    /// RT_DL1MK3_Angle_2
    RtDl1mk3Angle2(RtDl1mk3Angle2),
    /// RT_DL1MK3_Angle_1
    RtDl1mk3Angle1(RtDl1mk3Angle1),
    /// RT_DL1MK3_Temp_25
    RtDl1mk3Temp25(RtDl1mk3Temp25),
    /// RT_DL1MK3_Temp_24
    RtDl1mk3Temp24(RtDl1mk3Temp24),
    /// RT_DL1MK3_Temp_23
    RtDl1mk3Temp23(RtDl1mk3Temp23),
    /// RT_DL1MK3_Temp_22
    RtDl1mk3Temp22(RtDl1mk3Temp22),
    /// RT_DL1MK3_Temp_21
    RtDl1mk3Temp21(RtDl1mk3Temp21),
    /// RT_DL1MK3_Temp_20
    RtDl1mk3Temp20(RtDl1mk3Temp20),
    /// RT_DL1MK3_Temp_19
    RtDl1mk3Temp19(RtDl1mk3Temp19),
    /// RT_DL1MK3_Temp_18
    RtDl1mk3Temp18(RtDl1mk3Temp18),
    /// RT_DL1MK3_Temp_17
    RtDl1mk3Temp17(RtDl1mk3Temp17),
    /// RT_DL1MK3_Temp_16
    RtDl1mk3Temp16(RtDl1mk3Temp16),
    /// RT_DL1MK3_Temp_15
    RtDl1mk3Temp15(RtDl1mk3Temp15),
    /// RT_DL1MK3_Temp_14
    RtDl1mk3Temp14(RtDl1mk3Temp14),
    /// RT_DL1MK3_Temp_13
    RtDl1mk3Temp13(RtDl1mk3Temp13),
    /// RT_DL1MK3_Temp_12
    RtDl1mk3Temp12(RtDl1mk3Temp12),
    /// RT_DL1MK3_Temp_11
    RtDl1mk3Temp11(RtDl1mk3Temp11),
    /// RT_DL1MK3_Temp_10
    RtDl1mk3Temp10(RtDl1mk3Temp10),
    /// RT_DL1MK3_Temp_9
    RtDl1mk3Temp9(RtDl1mk3Temp9),
    /// RT_DL1MK3_Temp_8
    RtDl1mk3Temp8(RtDl1mk3Temp8),
    /// RT_DL1MK3_Temp_7
    RtDl1mk3Temp7(RtDl1mk3Temp7),
    /// RT_DL1MK3_Temp_6
    RtDl1mk3Temp6(RtDl1mk3Temp6),
    /// RT_DL1MK3_Temp_5
    RtDl1mk3Temp5(RtDl1mk3Temp5),
    /// RT_DL1MK3_Temp_4
    RtDl1mk3Temp4(RtDl1mk3Temp4),
    /// RT_DL1MK3_Temp_3
    RtDl1mk3Temp3(RtDl1mk3Temp3),
    /// RT_DL1MK3_Temp_2
    RtDl1mk3Temp2(RtDl1mk3Temp2),
    /// RT_DL1MK3_Temp_1
    RtDl1mk3Temp1(RtDl1mk3Temp1),
    /// RT_DL1MK3_Analog_32
    RtDl1mk3Analog32(RtDl1mk3Analog32),
    /// RT_DL1MK3_Analog_31
    RtDl1mk3Analog31(RtDl1mk3Analog31),
    /// RT_DL1MK3_Analog_30
    RtDl1mk3Analog30(RtDl1mk3Analog30),
    /// RT_DL1MK3_Analog_29
    RtDl1mk3Analog29(RtDl1mk3Analog29),
    /// RT_DL1MK3_Analog_28
    RtDl1mk3Analog28(RtDl1mk3Analog28),
    /// RT_DL1MK3_Analog_27
    RtDl1mk3Analog27(RtDl1mk3Analog27),
    /// RT_DL1MK3_Analog_26
    RtDl1mk3Analog26(RtDl1mk3Analog26),
    /// RT_DL1MK3_Analog_25
    RtDl1mk3Analog25(RtDl1mk3Analog25),
    /// RT_DL1MK3_Analog_15
    RtDl1mk3Analog15(RtDl1mk3Analog15),
    /// RT_DL1MK3_Analog_14
    RtDl1mk3Analog14(RtDl1mk3Analog14),
    /// RT_DL1MK3_Analog_17
    RtDl1mk3Analog17(RtDl1mk3Analog17),
    /// RT_DL1MK3_Analog_24
    RtDl1mk3Analog24(RtDl1mk3Analog24),
    /// RT_DL1MK3_Analog_23
    RtDl1mk3Analog23(RtDl1mk3Analog23),
    /// RT_DL1MK3_Analog_22
    RtDl1mk3Analog22(RtDl1mk3Analog22),
    /// RT_DL1MK3_Analog_21
    RtDl1mk3Analog21(RtDl1mk3Analog21),
    /// RT_DL1MK3_Analog_20
    RtDl1mk3Analog20(RtDl1mk3Analog20),
    /// RT_DL1MK3_Analog_19
    RtDl1mk3Analog19(RtDl1mk3Analog19),
    /// RT_DL1MK3_Analog_16
    RtDl1mk3Analog16(RtDl1mk3Analog16),
    /// RT_DL1MK3_Analog_18
    RtDl1mk3Analog18(RtDl1mk3Analog18),
    /// RT_DL1MK3_Analog_12
    RtDl1mk3Analog12(RtDl1mk3Analog12),
    /// RT_DL1MK3_Analog_11
    RtDl1mk3Analog11(RtDl1mk3Analog11),
    /// RT_DL1MK3_Analog_10
    RtDl1mk3Analog10(RtDl1mk3Analog10),
    /// RT_DL1MK3_Analog_9
    RtDl1mk3Analog9(RtDl1mk3Analog9),
    /// RT_DL1MK3_Analog_8
    RtDl1mk3Analog8(RtDl1mk3Analog8),
    /// RT_DL1MK3_Analog_7
    RtDl1mk3Analog7(RtDl1mk3Analog7),
    /// RT_DL1MK3_Analog_6
    RtDl1mk3Analog6(RtDl1mk3Analog6),
    /// RT_DL1MK3_Analog_5
    RtDl1mk3Analog5(RtDl1mk3Analog5),
    /// RT_DL1MK3_Analog_4
    RtDl1mk3Analog4(RtDl1mk3Analog4),
    /// RT_DL1MK3_Analog_3
    RtDl1mk3Analog3(RtDl1mk3Analog3),
    /// RT_DL1MK3_Analog_2
    RtDl1mk3Analog2(RtDl1mk3Analog2),
    /// RT_DL1MK3_Analog_1
    RtDl1mk3Analog1(RtDl1mk3Analog1),
    /// RT_DL1MK3_Accel
    RtDl1mk3Accel(RtDl1mk3Accel),
    /// RT_SB_INS_Vpt_4_Vel_NED_2
    RtSbInsVpt4VelNed2(RtSbInsVpt4VelNed2),
    /// RT_SB_INS_Vpt_4_Vel_NED_1
    RtSbInsVpt4VelNed1(RtSbInsVpt4VelNed1),
    /// RT_SB_INS_Vpt_4_Offset
    RtSbInsVpt4Offset(RtSbInsVpt4Offset),
    /// RT_SB_INS_Vpt_3_Vel_NED_2
    RtSbInsVpt3VelNed2(RtSbInsVpt3VelNed2),
    /// RT_SB_INS_Vpt_3_Vel_NED_1
    RtSbInsVpt3VelNed1(RtSbInsVpt3VelNed1),
    /// RT_SB_INS_Vpt_3_Offset
    RtSbInsVpt3Offset(RtSbInsVpt3Offset),
    /// RT_SB_INS_Vpt_2_Vel_NED_2
    RtSbInsVpt2VelNed2(RtSbInsVpt2VelNed2),
    /// RT_SB_INS_Vpt_2_Vel_NED_1
    RtSbInsVpt2VelNed1(RtSbInsVpt2VelNed1),
    /// RT_SB_INS_Vpt_2_Offset
    RtSbInsVpt2Offset(RtSbInsVpt2Offset),
    /// RT_SB_INS_Vpt_1_Vel_NED_2
    RtSbInsVpt1VelNed2(RtSbInsVpt1VelNed2),
    /// RT_SB_INS_Vpt_1_Vel_NED_1
    RtSbInsVpt1VelNed1(RtSbInsVpt1VelNed1),
    /// RT_SB_INS_Vpt_1_Offset
    RtSbInsVpt1Offset(RtSbInsVpt1Offset),
    /// RT_SB_INS_Slip
    RtSbInsSlip(RtSbInsSlip),
    /// RT_SB_INS_Vel_ECEF_2
    RtSbInsVelEcef2(RtSbInsVelEcef2),
    /// RT_SB_INS_Vel_ECEF_1
    RtSbInsVelEcef1(RtSbInsVelEcef1),
    /// RT_SB_INS_Vel_NED_2
    RtSbInsVelNed2(RtSbInsVelNed2),
    /// RT_SB_INS_Vel_NED_1
    RtSbInsVelNed1(RtSbInsVelNed1),
    /// RT_SB_INS_Pos_ECEF_2
    RtSbInsPosEcef2(RtSbInsPosEcef2),
    /// RT_SB_INS_Pos_ECEF_1
    RtSbInsPosEcef1(RtSbInsPosEcef1),
    /// RT_SB_INS_Pos_LLH_2
    RtSbInsPosLlh2(RtSbInsPosLlh2),
    /// RT_SB_INS_Pos_LLH_1
    RtSbInsPosLlh1(RtSbInsPosLlh1),
    /// RT_SB_INS_Heading_Gradient_2
    RtSbInsHeadingGradient2(RtSbInsHeadingGradient2),
    /// RT_SB_INS_Heading_Gradient
    RtSbInsHeadingGradient(RtSbInsHeadingGradient),
    /// RT_SB_INS_Status
    RtSbInsStatus(RtSbInsStatus),
    /// RT_SB_INS_Attitude
    RtSbInsAttitude(RtSbInsAttitude),
    /// RT_SB_Output_Status
    RtSbOutputStatus(RtSbOutputStatus),
    /// RT_SB_GPS_Heading_Gradient_2
    RtSbGpsHeadingGradient2(RtSbGpsHeadingGradient2),
    /// RT_SB_Cumulative_Distance_2
    RtSbCumulativeDistance2(RtSbCumulativeDistance2),
    /// RT_SB_Cumulative_Distance_1
    RtSbCumulativeDistance1(RtSbCumulativeDistance1),
    /// RT_SB_Trigger_Timestamp
    RtSbTriggerTimestamp(RtSbTriggerTimestamp),
    /// RT_IMU06_Gyro_Rates
    RtImu06GyroRates(RtImu06GyroRates),
    /// RT_IMU06_Accel
    RtImu06Accel(RtImu06Accel),
    /// RT_SB_Speed
    RtSbSpeed(RtSbSpeed),
    /// RT_SB_RTK_Slip
    RtSbRtkSlip(RtSbRtkSlip),
    /// RT_SB_RTK_Attitude
    RtSbRtkAttitude(RtSbRtkAttitude),
    /// RT_SB_GPS_Mcycle_Lean
    RtSbGpsMcycleLean(RtSbGpsMcycleLean),
    /// RT_SB_GPS_Status
    RtSbGpsStatus(RtSbGpsStatus),
    /// RT_SB_GPS_Pos_ECEF_2
    RtSbGpsPosEcef2(RtSbGpsPosEcef2),
    /// RT_SB_GPS_Pos_ECEF_1
    RtSbGpsPosEcef1(RtSbGpsPosEcef1),
    /// RT_SB_GPS_Pos_LLH_2
    RtSbGpsPosLlh2(RtSbGpsPosLlh2),
    /// RT_SB_GPS_Pos_LLH_1
    RtSbGpsPosLlh1(RtSbGpsPosLlh1),
    /// RT_SB_GPS_Heading_Gradient
    RtSbGpsHeadingGradient(RtSbGpsHeadingGradient),
    /// RT_SB_GPS_Vel_ECEF_2
    RtSbGpsVelEcef2(RtSbGpsVelEcef2),
    /// RT_SB_GPS_Vel_ECEF_1
    RtSbGpsVelEcef1(RtSbGpsVelEcef1),
    /// RT_SB_GPS_Vel_NED_2
    RtSbGpsVelNed2(RtSbGpsVelNed2),
    /// RT_SB_GPS_Vel_NED_1
    RtSbGpsVelNed1(RtSbGpsVelNed1),
    /// RT_SB_GPS_Speed
    RtSbGpsSpeed(RtSbGpsSpeed),
    /// RT_SB_GPS_Time
    RtSbGpsTime(RtSbGpsTime),
    /// RT_SB_Accel
    RtSbAccel(RtSbAccel),
    /// RT_SB_Gyro_Rates
    RtSbGyroRates(RtSbGyroRates),
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl Messages {
    /// Read message from CAN frame
    #[inline(never)]
    pub fn from_can_message(id: Id, payload: &[u8]) -> Result<Self, CanError> {
        
        let res = match id {
            RtSbInsVelBodyAxes::MESSAGE_ID => Messages::RtSbInsVelBodyAxes(RtSbInsVelBodyAxes::try_from(payload)?),
            RtDl1mk3Speed::MESSAGE_ID => Messages::RtDl1mk3Speed(RtDl1mk3Speed::try_from(payload)?),
            RtDl1mk3GpsTime::MESSAGE_ID => Messages::RtDl1mk3GpsTime(RtDl1mk3GpsTime::try_from(payload)?),
            RtDl1mk3GpsPosLlh2::MESSAGE_ID => Messages::RtDl1mk3GpsPosLlh2(RtDl1mk3GpsPosLlh2::try_from(payload)?),
            RtDl1mk3GpsPosLlh1::MESSAGE_ID => Messages::RtDl1mk3GpsPosLlh1(RtDl1mk3GpsPosLlh1::try_from(payload)?),
            RtDl1mk3GpsSpeed::MESSAGE_ID => Messages::RtDl1mk3GpsSpeed(RtDl1mk3GpsSpeed::try_from(payload)?),
            RtIrTempTemp7::MESSAGE_ID => Messages::RtIrTempTemp7(RtIrTempTemp7::try_from(payload)?),
            RtIrTempTempRr2::MESSAGE_ID => Messages::RtIrTempTempRr2(RtIrTempTempRr2::try_from(payload)?),
            RtIrTempTempRl2::MESSAGE_ID => Messages::RtIrTempTempRl2(RtIrTempTempRl2::try_from(payload)?),
            RtIrTempTempFr2::MESSAGE_ID => Messages::RtIrTempTempFr2(RtIrTempTempFr2::try_from(payload)?),
            RtIrTempTempFl2::MESSAGE_ID => Messages::RtIrTempTempFl2(RtIrTempTempFl2::try_from(payload)?),
            RtIrTempTempRr1::MESSAGE_ID => Messages::RtIrTempTempRr1(RtIrTempTempRr1::try_from(payload)?),
            RtIrTempTempRl1::MESSAGE_ID => Messages::RtIrTempTempRl1(RtIrTempTempRl1::try_from(payload)?),
            RtIrTempTempFr1::MESSAGE_ID => Messages::RtIrTempTempFr1(RtIrTempTempFr1::try_from(payload)?),
            RtIrTempTempFl1::MESSAGE_ID => Messages::RtIrTempTempFl1(RtIrTempTempFl1::try_from(payload)?),
            RtIrTempTemp32::MESSAGE_ID => Messages::RtIrTempTemp32(RtIrTempTemp32::try_from(payload)?),
            RtIrTempTemp31::MESSAGE_ID => Messages::RtIrTempTemp31(RtIrTempTemp31::try_from(payload)?),
            RtIrTempTemp30::MESSAGE_ID => Messages::RtIrTempTemp30(RtIrTempTemp30::try_from(payload)?),
            RtIrTempTemp29::MESSAGE_ID => Messages::RtIrTempTemp29(RtIrTempTemp29::try_from(payload)?),
            RtIrTempTemp28::MESSAGE_ID => Messages::RtIrTempTemp28(RtIrTempTemp28::try_from(payload)?),
            RtIrTempTemp27::MESSAGE_ID => Messages::RtIrTempTemp27(RtIrTempTemp27::try_from(payload)?),
            RtIrTempTemp26::MESSAGE_ID => Messages::RtIrTempTemp26(RtIrTempTemp26::try_from(payload)?),
            RtIrTempTemp25::MESSAGE_ID => Messages::RtIrTempTemp25(RtIrTempTemp25::try_from(payload)?),
            RtIrTempTemp24::MESSAGE_ID => Messages::RtIrTempTemp24(RtIrTempTemp24::try_from(payload)?),
            RtIrTempTemp22::MESSAGE_ID => Messages::RtIrTempTemp22(RtIrTempTemp22::try_from(payload)?),
            RtIrTempTemp23::MESSAGE_ID => Messages::RtIrTempTemp23(RtIrTempTemp23::try_from(payload)?),
            RtIrTempTemp21::MESSAGE_ID => Messages::RtIrTempTemp21(RtIrTempTemp21::try_from(payload)?),
            RtIrTempTemp20::MESSAGE_ID => Messages::RtIrTempTemp20(RtIrTempTemp20::try_from(payload)?),
            RtIrTempTemp19::MESSAGE_ID => Messages::RtIrTempTemp19(RtIrTempTemp19::try_from(payload)?),
            RtIrTempTemp18::MESSAGE_ID => Messages::RtIrTempTemp18(RtIrTempTemp18::try_from(payload)?),
            RtIrTempTemp16::MESSAGE_ID => Messages::RtIrTempTemp16(RtIrTempTemp16::try_from(payload)?),
            RtIrTempTemp15::MESSAGE_ID => Messages::RtIrTempTemp15(RtIrTempTemp15::try_from(payload)?),
            RtIrTempTemp14::MESSAGE_ID => Messages::RtIrTempTemp14(RtIrTempTemp14::try_from(payload)?),
            RtIrTempTemp13::MESSAGE_ID => Messages::RtIrTempTemp13(RtIrTempTemp13::try_from(payload)?),
            RtIrTempTemp12::MESSAGE_ID => Messages::RtIrTempTemp12(RtIrTempTemp12::try_from(payload)?),
            RtIrTempTemp11::MESSAGE_ID => Messages::RtIrTempTemp11(RtIrTempTemp11::try_from(payload)?),
            RtIrTempTemp10::MESSAGE_ID => Messages::RtIrTempTemp10(RtIrTempTemp10::try_from(payload)?),
            RtIrTempTemp8::MESSAGE_ID => Messages::RtIrTempTemp8(RtIrTempTemp8::try_from(payload)?),
            RtIrTempTemp9::MESSAGE_ID => Messages::RtIrTempTemp9(RtIrTempTemp9::try_from(payload)?),
            RtIrTempTemp17::MESSAGE_ID => Messages::RtIrTempTemp17(RtIrTempTemp17::try_from(payload)?),
            RtIrTempTemp6::MESSAGE_ID => Messages::RtIrTempTemp6(RtIrTempTemp6::try_from(payload)?),
            RtIrTempTemp5::MESSAGE_ID => Messages::RtIrTempTemp5(RtIrTempTemp5::try_from(payload)?),
            RtIrTempTemp4::MESSAGE_ID => Messages::RtIrTempTemp4(RtIrTempTemp4::try_from(payload)?),
            RtIrTempTemp3::MESSAGE_ID => Messages::RtIrTempTemp3(RtIrTempTemp3::try_from(payload)?),
            RtIrTempTemp2::MESSAGE_ID => Messages::RtIrTempTemp2(RtIrTempTemp2::try_from(payload)?),
            RtIrTempTemp1::MESSAGE_ID => Messages::RtIrTempTemp1(RtIrTempTemp1::try_from(payload)?),
            RtSbTrigFinalCondition::MESSAGE_ID => Messages::RtSbTrigFinalCondition(RtSbTrigFinalCondition::try_from(payload)?),
            RtSbTrigInitialCondition::MESSAGE_ID => Messages::RtSbTrigInitialCondition(RtSbTrigInitialCondition::try_from(payload)?),
            RtSbTrigDirectDist::MESSAGE_ID => Messages::RtSbTrigDirectDist(RtSbTrigDirectDist::try_from(payload)?),
            RtSbTrigForwardDist::MESSAGE_ID => Messages::RtSbTrigForwardDist(RtSbTrigForwardDist::try_from(payload)?),
            RtSbTrigPathDist::MESSAGE_ID => Messages::RtSbTrigPathDist(RtSbTrigPathDist::try_from(payload)?),
            RtSbTrigAccel::MESSAGE_ID => Messages::RtSbTrigAccel(RtSbTrigAccel::try_from(payload)?),
            RtDl1mk3MeasureTime12::MESSAGE_ID => Messages::RtDl1mk3MeasureTime12(RtDl1mk3MeasureTime12::try_from(payload)?),
            RtDl1mk3MeasureTime11::MESSAGE_ID => Messages::RtDl1mk3MeasureTime11(RtDl1mk3MeasureTime11::try_from(payload)?),
            RtDl1mk3MeasureTime10::MESSAGE_ID => Messages::RtDl1mk3MeasureTime10(RtDl1mk3MeasureTime10::try_from(payload)?),
            RtDl1mk3MeasureTime9::MESSAGE_ID => Messages::RtDl1mk3MeasureTime9(RtDl1mk3MeasureTime9::try_from(payload)?),
            RtDl1mk3MeasureTime8::MESSAGE_ID => Messages::RtDl1mk3MeasureTime8(RtDl1mk3MeasureTime8::try_from(payload)?),
            RtDl1mk3MeasureTime7::MESSAGE_ID => Messages::RtDl1mk3MeasureTime7(RtDl1mk3MeasureTime7::try_from(payload)?),
            RtDl1mk3MeasureTime6::MESSAGE_ID => Messages::RtDl1mk3MeasureTime6(RtDl1mk3MeasureTime6::try_from(payload)?),
            RtDl1mk3MeasureTime5::MESSAGE_ID => Messages::RtDl1mk3MeasureTime5(RtDl1mk3MeasureTime5::try_from(payload)?),
            RtDl1mk3MeasureTime4::MESSAGE_ID => Messages::RtDl1mk3MeasureTime4(RtDl1mk3MeasureTime4::try_from(payload)?),
            RtDl1mk3MeasureTime3::MESSAGE_ID => Messages::RtDl1mk3MeasureTime3(RtDl1mk3MeasureTime3::try_from(payload)?),
            RtDl1mk3MeasureTime2::MESSAGE_ID => Messages::RtDl1mk3MeasureTime2(RtDl1mk3MeasureTime2::try_from(payload)?),
            RtDl1mk3MeasureTime1::MESSAGE_ID => Messages::RtDl1mk3MeasureTime1(RtDl1mk3MeasureTime1::try_from(payload)?),
            RtDl1mk3Rpm::MESSAGE_ID => Messages::RtDl1mk3Rpm(RtDl1mk3Rpm::try_from(payload)?),
            RtDl1mk3Freq4::MESSAGE_ID => Messages::RtDl1mk3Freq4(RtDl1mk3Freq4::try_from(payload)?),
            RtDl1mk3Freq3::MESSAGE_ID => Messages::RtDl1mk3Freq3(RtDl1mk3Freq3::try_from(payload)?),
            RtDl1mk3Freq2::MESSAGE_ID => Messages::RtDl1mk3Freq2(RtDl1mk3Freq2::try_from(payload)?),
            RtDl1mk3Misc3::MESSAGE_ID => Messages::RtDl1mk3Misc3(RtDl1mk3Misc3::try_from(payload)?),
            RtDl1mk3Misc2::MESSAGE_ID => Messages::RtDl1mk3Misc2(RtDl1mk3Misc2::try_from(payload)?),
            RtDl1mk3Misc1::MESSAGE_ID => Messages::RtDl1mk3Misc1(RtDl1mk3Misc1::try_from(payload)?),
            RtDl1mk3Aux31::MESSAGE_ID => Messages::RtDl1mk3Aux31(RtDl1mk3Aux31::try_from(payload)?),
            RtDl1mk3Aux30::MESSAGE_ID => Messages::RtDl1mk3Aux30(RtDl1mk3Aux30::try_from(payload)?),
            RtDl1mk3Aux29::MESSAGE_ID => Messages::RtDl1mk3Aux29(RtDl1mk3Aux29::try_from(payload)?),
            RtDl1mk3Aux28::MESSAGE_ID => Messages::RtDl1mk3Aux28(RtDl1mk3Aux28::try_from(payload)?),
            RtDl1mk3Aux27::MESSAGE_ID => Messages::RtDl1mk3Aux27(RtDl1mk3Aux27::try_from(payload)?),
            RtDl1mk3Aux26::MESSAGE_ID => Messages::RtDl1mk3Aux26(RtDl1mk3Aux26::try_from(payload)?),
            RtDl1mk3Aux25::MESSAGE_ID => Messages::RtDl1mk3Aux25(RtDl1mk3Aux25::try_from(payload)?),
            RtDl1mk3Aux24::MESSAGE_ID => Messages::RtDl1mk3Aux24(RtDl1mk3Aux24::try_from(payload)?),
            RtDl1mk3Aux23::MESSAGE_ID => Messages::RtDl1mk3Aux23(RtDl1mk3Aux23::try_from(payload)?),
            RtDl1mk3Aux22::MESSAGE_ID => Messages::RtDl1mk3Aux22(RtDl1mk3Aux22::try_from(payload)?),
            RtDl1mk3Aux21::MESSAGE_ID => Messages::RtDl1mk3Aux21(RtDl1mk3Aux21::try_from(payload)?),
            RtDl1mk3Aux20::MESSAGE_ID => Messages::RtDl1mk3Aux20(RtDl1mk3Aux20::try_from(payload)?),
            RtDl1mk3Aux19::MESSAGE_ID => Messages::RtDl1mk3Aux19(RtDl1mk3Aux19::try_from(payload)?),
            RtDl1mk3Aux18::MESSAGE_ID => Messages::RtDl1mk3Aux18(RtDl1mk3Aux18::try_from(payload)?),
            RtDl1mk3Aux17::MESSAGE_ID => Messages::RtDl1mk3Aux17(RtDl1mk3Aux17::try_from(payload)?),
            RtDl1mk3Aux16::MESSAGE_ID => Messages::RtDl1mk3Aux16(RtDl1mk3Aux16::try_from(payload)?),
            RtDl1mk3Aux15::MESSAGE_ID => Messages::RtDl1mk3Aux15(RtDl1mk3Aux15::try_from(payload)?),
            RtDl1mk3Aux14::MESSAGE_ID => Messages::RtDl1mk3Aux14(RtDl1mk3Aux14::try_from(payload)?),
            RtDl1mk3Aux13::MESSAGE_ID => Messages::RtDl1mk3Aux13(RtDl1mk3Aux13::try_from(payload)?),
            RtDl1mk3Aux12::MESSAGE_ID => Messages::RtDl1mk3Aux12(RtDl1mk3Aux12::try_from(payload)?),
            RtDl1mk3Aux11::MESSAGE_ID => Messages::RtDl1mk3Aux11(RtDl1mk3Aux11::try_from(payload)?),
            RtDl1mk3Aux9::MESSAGE_ID => Messages::RtDl1mk3Aux9(RtDl1mk3Aux9::try_from(payload)?),
            RtDl1mk3Aux10::MESSAGE_ID => Messages::RtDl1mk3Aux10(RtDl1mk3Aux10::try_from(payload)?),
            RtDl1mk3Aux8::MESSAGE_ID => Messages::RtDl1mk3Aux8(RtDl1mk3Aux8::try_from(payload)?),
            RtDl1mk3Aux7::MESSAGE_ID => Messages::RtDl1mk3Aux7(RtDl1mk3Aux7::try_from(payload)?),
            RtDl1mk3Aux6::MESSAGE_ID => Messages::RtDl1mk3Aux6(RtDl1mk3Aux6::try_from(payload)?),
            RtDl1mk3Aux5::MESSAGE_ID => Messages::RtDl1mk3Aux5(RtDl1mk3Aux5::try_from(payload)?),
            RtDl1mk3Aux4::MESSAGE_ID => Messages::RtDl1mk3Aux4(RtDl1mk3Aux4::try_from(payload)?),
            RtDl1mk3Aux3::MESSAGE_ID => Messages::RtDl1mk3Aux3(RtDl1mk3Aux3::try_from(payload)?),
            RtDl1mk3Aux2::MESSAGE_ID => Messages::RtDl1mk3Aux2(RtDl1mk3Aux2::try_from(payload)?),
            RtDl1mk3Aux1::MESSAGE_ID => Messages::RtDl1mk3Aux1(RtDl1mk3Aux1::try_from(payload)?),
            RtDl1mk3Pressure5::MESSAGE_ID => Messages::RtDl1mk3Pressure5(RtDl1mk3Pressure5::try_from(payload)?),
            RtDl1mk3Pressure4::MESSAGE_ID => Messages::RtDl1mk3Pressure4(RtDl1mk3Pressure4::try_from(payload)?),
            RtDl1mk3Pressure3::MESSAGE_ID => Messages::RtDl1mk3Pressure3(RtDl1mk3Pressure3::try_from(payload)?),
            RtDl1mk3Pressure2::MESSAGE_ID => Messages::RtDl1mk3Pressure2(RtDl1mk3Pressure2::try_from(payload)?),
            RtDl1mk3Pressure1::MESSAGE_ID => Messages::RtDl1mk3Pressure1(RtDl1mk3Pressure1::try_from(payload)?),
            RtDl1mk3Angle3::MESSAGE_ID => Messages::RtDl1mk3Angle3(RtDl1mk3Angle3::try_from(payload)?),
            RtDl1mk3Angle2::MESSAGE_ID => Messages::RtDl1mk3Angle2(RtDl1mk3Angle2::try_from(payload)?),
            RtDl1mk3Angle1::MESSAGE_ID => Messages::RtDl1mk3Angle1(RtDl1mk3Angle1::try_from(payload)?),
            RtDl1mk3Temp25::MESSAGE_ID => Messages::RtDl1mk3Temp25(RtDl1mk3Temp25::try_from(payload)?),
            RtDl1mk3Temp24::MESSAGE_ID => Messages::RtDl1mk3Temp24(RtDl1mk3Temp24::try_from(payload)?),
            RtDl1mk3Temp23::MESSAGE_ID => Messages::RtDl1mk3Temp23(RtDl1mk3Temp23::try_from(payload)?),
            RtDl1mk3Temp22::MESSAGE_ID => Messages::RtDl1mk3Temp22(RtDl1mk3Temp22::try_from(payload)?),
            RtDl1mk3Temp21::MESSAGE_ID => Messages::RtDl1mk3Temp21(RtDl1mk3Temp21::try_from(payload)?),
            RtDl1mk3Temp20::MESSAGE_ID => Messages::RtDl1mk3Temp20(RtDl1mk3Temp20::try_from(payload)?),
            RtDl1mk3Temp19::MESSAGE_ID => Messages::RtDl1mk3Temp19(RtDl1mk3Temp19::try_from(payload)?),
            RtDl1mk3Temp18::MESSAGE_ID => Messages::RtDl1mk3Temp18(RtDl1mk3Temp18::try_from(payload)?),
            RtDl1mk3Temp17::MESSAGE_ID => Messages::RtDl1mk3Temp17(RtDl1mk3Temp17::try_from(payload)?),
            RtDl1mk3Temp16::MESSAGE_ID => Messages::RtDl1mk3Temp16(RtDl1mk3Temp16::try_from(payload)?),
            RtDl1mk3Temp15::MESSAGE_ID => Messages::RtDl1mk3Temp15(RtDl1mk3Temp15::try_from(payload)?),
            RtDl1mk3Temp14::MESSAGE_ID => Messages::RtDl1mk3Temp14(RtDl1mk3Temp14::try_from(payload)?),
            RtDl1mk3Temp13::MESSAGE_ID => Messages::RtDl1mk3Temp13(RtDl1mk3Temp13::try_from(payload)?),
            RtDl1mk3Temp12::MESSAGE_ID => Messages::RtDl1mk3Temp12(RtDl1mk3Temp12::try_from(payload)?),
            RtDl1mk3Temp11::MESSAGE_ID => Messages::RtDl1mk3Temp11(RtDl1mk3Temp11::try_from(payload)?),
            RtDl1mk3Temp10::MESSAGE_ID => Messages::RtDl1mk3Temp10(RtDl1mk3Temp10::try_from(payload)?),
            RtDl1mk3Temp9::MESSAGE_ID => Messages::RtDl1mk3Temp9(RtDl1mk3Temp9::try_from(payload)?),
            RtDl1mk3Temp8::MESSAGE_ID => Messages::RtDl1mk3Temp8(RtDl1mk3Temp8::try_from(payload)?),
            RtDl1mk3Temp7::MESSAGE_ID => Messages::RtDl1mk3Temp7(RtDl1mk3Temp7::try_from(payload)?),
            RtDl1mk3Temp6::MESSAGE_ID => Messages::RtDl1mk3Temp6(RtDl1mk3Temp6::try_from(payload)?),
            RtDl1mk3Temp5::MESSAGE_ID => Messages::RtDl1mk3Temp5(RtDl1mk3Temp5::try_from(payload)?),
            RtDl1mk3Temp4::MESSAGE_ID => Messages::RtDl1mk3Temp4(RtDl1mk3Temp4::try_from(payload)?),
            RtDl1mk3Temp3::MESSAGE_ID => Messages::RtDl1mk3Temp3(RtDl1mk3Temp3::try_from(payload)?),
            RtDl1mk3Temp2::MESSAGE_ID => Messages::RtDl1mk3Temp2(RtDl1mk3Temp2::try_from(payload)?),
            RtDl1mk3Temp1::MESSAGE_ID => Messages::RtDl1mk3Temp1(RtDl1mk3Temp1::try_from(payload)?),
            RtDl1mk3Analog32::MESSAGE_ID => Messages::RtDl1mk3Analog32(RtDl1mk3Analog32::try_from(payload)?),
            RtDl1mk3Analog31::MESSAGE_ID => Messages::RtDl1mk3Analog31(RtDl1mk3Analog31::try_from(payload)?),
            RtDl1mk3Analog30::MESSAGE_ID => Messages::RtDl1mk3Analog30(RtDl1mk3Analog30::try_from(payload)?),
            RtDl1mk3Analog29::MESSAGE_ID => Messages::RtDl1mk3Analog29(RtDl1mk3Analog29::try_from(payload)?),
            RtDl1mk3Analog28::MESSAGE_ID => Messages::RtDl1mk3Analog28(RtDl1mk3Analog28::try_from(payload)?),
            RtDl1mk3Analog27::MESSAGE_ID => Messages::RtDl1mk3Analog27(RtDl1mk3Analog27::try_from(payload)?),
            RtDl1mk3Analog26::MESSAGE_ID => Messages::RtDl1mk3Analog26(RtDl1mk3Analog26::try_from(payload)?),
            RtDl1mk3Analog25::MESSAGE_ID => Messages::RtDl1mk3Analog25(RtDl1mk3Analog25::try_from(payload)?),
            RtDl1mk3Analog15::MESSAGE_ID => Messages::RtDl1mk3Analog15(RtDl1mk3Analog15::try_from(payload)?),
            RtDl1mk3Analog14::MESSAGE_ID => Messages::RtDl1mk3Analog14(RtDl1mk3Analog14::try_from(payload)?),
            RtDl1mk3Analog17::MESSAGE_ID => Messages::RtDl1mk3Analog17(RtDl1mk3Analog17::try_from(payload)?),
            RtDl1mk3Analog24::MESSAGE_ID => Messages::RtDl1mk3Analog24(RtDl1mk3Analog24::try_from(payload)?),
            RtDl1mk3Analog23::MESSAGE_ID => Messages::RtDl1mk3Analog23(RtDl1mk3Analog23::try_from(payload)?),
            RtDl1mk3Analog22::MESSAGE_ID => Messages::RtDl1mk3Analog22(RtDl1mk3Analog22::try_from(payload)?),
            RtDl1mk3Analog21::MESSAGE_ID => Messages::RtDl1mk3Analog21(RtDl1mk3Analog21::try_from(payload)?),
            RtDl1mk3Analog20::MESSAGE_ID => Messages::RtDl1mk3Analog20(RtDl1mk3Analog20::try_from(payload)?),
            RtDl1mk3Analog19::MESSAGE_ID => Messages::RtDl1mk3Analog19(RtDl1mk3Analog19::try_from(payload)?),
            RtDl1mk3Analog16::MESSAGE_ID => Messages::RtDl1mk3Analog16(RtDl1mk3Analog16::try_from(payload)?),
            RtDl1mk3Analog18::MESSAGE_ID => Messages::RtDl1mk3Analog18(RtDl1mk3Analog18::try_from(payload)?),
            RtDl1mk3Analog12::MESSAGE_ID => Messages::RtDl1mk3Analog12(RtDl1mk3Analog12::try_from(payload)?),
            RtDl1mk3Analog11::MESSAGE_ID => Messages::RtDl1mk3Analog11(RtDl1mk3Analog11::try_from(payload)?),
            RtDl1mk3Analog10::MESSAGE_ID => Messages::RtDl1mk3Analog10(RtDl1mk3Analog10::try_from(payload)?),
            RtDl1mk3Analog9::MESSAGE_ID => Messages::RtDl1mk3Analog9(RtDl1mk3Analog9::try_from(payload)?),
            RtDl1mk3Analog8::MESSAGE_ID => Messages::RtDl1mk3Analog8(RtDl1mk3Analog8::try_from(payload)?),
            RtDl1mk3Analog7::MESSAGE_ID => Messages::RtDl1mk3Analog7(RtDl1mk3Analog7::try_from(payload)?),
            RtDl1mk3Analog6::MESSAGE_ID => Messages::RtDl1mk3Analog6(RtDl1mk3Analog6::try_from(payload)?),
            RtDl1mk3Analog5::MESSAGE_ID => Messages::RtDl1mk3Analog5(RtDl1mk3Analog5::try_from(payload)?),
            RtDl1mk3Analog4::MESSAGE_ID => Messages::RtDl1mk3Analog4(RtDl1mk3Analog4::try_from(payload)?),
            RtDl1mk3Analog3::MESSAGE_ID => Messages::RtDl1mk3Analog3(RtDl1mk3Analog3::try_from(payload)?),
            RtDl1mk3Analog2::MESSAGE_ID => Messages::RtDl1mk3Analog2(RtDl1mk3Analog2::try_from(payload)?),
            RtDl1mk3Analog1::MESSAGE_ID => Messages::RtDl1mk3Analog1(RtDl1mk3Analog1::try_from(payload)?),
            RtDl1mk3Accel::MESSAGE_ID => Messages::RtDl1mk3Accel(RtDl1mk3Accel::try_from(payload)?),
            RtSbInsVpt4VelNed2::MESSAGE_ID => Messages::RtSbInsVpt4VelNed2(RtSbInsVpt4VelNed2::try_from(payload)?),
            RtSbInsVpt4VelNed1::MESSAGE_ID => Messages::RtSbInsVpt4VelNed1(RtSbInsVpt4VelNed1::try_from(payload)?),
            RtSbInsVpt4Offset::MESSAGE_ID => Messages::RtSbInsVpt4Offset(RtSbInsVpt4Offset::try_from(payload)?),
            RtSbInsVpt3VelNed2::MESSAGE_ID => Messages::RtSbInsVpt3VelNed2(RtSbInsVpt3VelNed2::try_from(payload)?),
            RtSbInsVpt3VelNed1::MESSAGE_ID => Messages::RtSbInsVpt3VelNed1(RtSbInsVpt3VelNed1::try_from(payload)?),
            RtSbInsVpt3Offset::MESSAGE_ID => Messages::RtSbInsVpt3Offset(RtSbInsVpt3Offset::try_from(payload)?),
            RtSbInsVpt2VelNed2::MESSAGE_ID => Messages::RtSbInsVpt2VelNed2(RtSbInsVpt2VelNed2::try_from(payload)?),
            RtSbInsVpt2VelNed1::MESSAGE_ID => Messages::RtSbInsVpt2VelNed1(RtSbInsVpt2VelNed1::try_from(payload)?),
            RtSbInsVpt2Offset::MESSAGE_ID => Messages::RtSbInsVpt2Offset(RtSbInsVpt2Offset::try_from(payload)?),
            RtSbInsVpt1VelNed2::MESSAGE_ID => Messages::RtSbInsVpt1VelNed2(RtSbInsVpt1VelNed2::try_from(payload)?),
            RtSbInsVpt1VelNed1::MESSAGE_ID => Messages::RtSbInsVpt1VelNed1(RtSbInsVpt1VelNed1::try_from(payload)?),
            RtSbInsVpt1Offset::MESSAGE_ID => Messages::RtSbInsVpt1Offset(RtSbInsVpt1Offset::try_from(payload)?),
            RtSbInsSlip::MESSAGE_ID => Messages::RtSbInsSlip(RtSbInsSlip::try_from(payload)?),
            RtSbInsVelEcef2::MESSAGE_ID => Messages::RtSbInsVelEcef2(RtSbInsVelEcef2::try_from(payload)?),
            RtSbInsVelEcef1::MESSAGE_ID => Messages::RtSbInsVelEcef1(RtSbInsVelEcef1::try_from(payload)?),
            RtSbInsVelNed2::MESSAGE_ID => Messages::RtSbInsVelNed2(RtSbInsVelNed2::try_from(payload)?),
            RtSbInsVelNed1::MESSAGE_ID => Messages::RtSbInsVelNed1(RtSbInsVelNed1::try_from(payload)?),
            RtSbInsPosEcef2::MESSAGE_ID => Messages::RtSbInsPosEcef2(RtSbInsPosEcef2::try_from(payload)?),
            RtSbInsPosEcef1::MESSAGE_ID => Messages::RtSbInsPosEcef1(RtSbInsPosEcef1::try_from(payload)?),
            RtSbInsPosLlh2::MESSAGE_ID => Messages::RtSbInsPosLlh2(RtSbInsPosLlh2::try_from(payload)?),
            RtSbInsPosLlh1::MESSAGE_ID => Messages::RtSbInsPosLlh1(RtSbInsPosLlh1::try_from(payload)?),
            RtSbInsHeadingGradient2::MESSAGE_ID => Messages::RtSbInsHeadingGradient2(RtSbInsHeadingGradient2::try_from(payload)?),
            RtSbInsHeadingGradient::MESSAGE_ID => Messages::RtSbInsHeadingGradient(RtSbInsHeadingGradient::try_from(payload)?),
            RtSbInsStatus::MESSAGE_ID => Messages::RtSbInsStatus(RtSbInsStatus::try_from(payload)?),
            RtSbInsAttitude::MESSAGE_ID => Messages::RtSbInsAttitude(RtSbInsAttitude::try_from(payload)?),
            RtSbOutputStatus::MESSAGE_ID => Messages::RtSbOutputStatus(RtSbOutputStatus::try_from(payload)?),
            RtSbGpsHeadingGradient2::MESSAGE_ID => Messages::RtSbGpsHeadingGradient2(RtSbGpsHeadingGradient2::try_from(payload)?),
            RtSbCumulativeDistance2::MESSAGE_ID => Messages::RtSbCumulativeDistance2(RtSbCumulativeDistance2::try_from(payload)?),
            RtSbCumulativeDistance1::MESSAGE_ID => Messages::RtSbCumulativeDistance1(RtSbCumulativeDistance1::try_from(payload)?),
            RtSbTriggerTimestamp::MESSAGE_ID => Messages::RtSbTriggerTimestamp(RtSbTriggerTimestamp::try_from(payload)?),
            RtImu06GyroRates::MESSAGE_ID => Messages::RtImu06GyroRates(RtImu06GyroRates::try_from(payload)?),
            RtImu06Accel::MESSAGE_ID => Messages::RtImu06Accel(RtImu06Accel::try_from(payload)?),
            RtSbSpeed::MESSAGE_ID => Messages::RtSbSpeed(RtSbSpeed::try_from(payload)?),
            RtSbRtkSlip::MESSAGE_ID => Messages::RtSbRtkSlip(RtSbRtkSlip::try_from(payload)?),
            RtSbRtkAttitude::MESSAGE_ID => Messages::RtSbRtkAttitude(RtSbRtkAttitude::try_from(payload)?),
            RtSbGpsMcycleLean::MESSAGE_ID => Messages::RtSbGpsMcycleLean(RtSbGpsMcycleLean::try_from(payload)?),
            RtSbGpsStatus::MESSAGE_ID => Messages::RtSbGpsStatus(RtSbGpsStatus::try_from(payload)?),
            RtSbGpsPosEcef2::MESSAGE_ID => Messages::RtSbGpsPosEcef2(RtSbGpsPosEcef2::try_from(payload)?),
            RtSbGpsPosEcef1::MESSAGE_ID => Messages::RtSbGpsPosEcef1(RtSbGpsPosEcef1::try_from(payload)?),
            RtSbGpsPosLlh2::MESSAGE_ID => Messages::RtSbGpsPosLlh2(RtSbGpsPosLlh2::try_from(payload)?),
            RtSbGpsPosLlh1::MESSAGE_ID => Messages::RtSbGpsPosLlh1(RtSbGpsPosLlh1::try_from(payload)?),
            RtSbGpsHeadingGradient::MESSAGE_ID => Messages::RtSbGpsHeadingGradient(RtSbGpsHeadingGradient::try_from(payload)?),
            RtSbGpsVelEcef2::MESSAGE_ID => Messages::RtSbGpsVelEcef2(RtSbGpsVelEcef2::try_from(payload)?),
            RtSbGpsVelEcef1::MESSAGE_ID => Messages::RtSbGpsVelEcef1(RtSbGpsVelEcef1::try_from(payload)?),
            RtSbGpsVelNed2::MESSAGE_ID => Messages::RtSbGpsVelNed2(RtSbGpsVelNed2::try_from(payload)?),
            RtSbGpsVelNed1::MESSAGE_ID => Messages::RtSbGpsVelNed1(RtSbGpsVelNed1::try_from(payload)?),
            RtSbGpsSpeed::MESSAGE_ID => Messages::RtSbGpsSpeed(RtSbGpsSpeed::try_from(payload)?),
            RtSbGpsTime::MESSAGE_ID => Messages::RtSbGpsTime(RtSbGpsTime::try_from(payload)?),
            RtSbAccel::MESSAGE_ID => Messages::RtSbAccel(RtSbAccel::try_from(payload)?),
            RtSbGyroRates::MESSAGE_ID => Messages::RtSbGyroRates(RtSbGyroRates::try_from(payload)?),
            id => return Err(CanError::UnknownMessageId(id)),
        };
        Ok(res)
    }
}

/// RT_SB_INS_Vel_Body_Axes
///
/// - Extended ID: 156795682 (0x9588322)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVelBodyAxes {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVelBodyAxes {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9588322)});
    
    pub const INS_VEL_SIDEWAYS_2D_MIN: f32 = -838_f32;
    pub const INS_VEL_SIDEWAYS_2D_MAX: f32 = 838_f32;
    pub const INS_VEL_FORWARDS_2D_MIN: f32 = -838_f32;
    pub const INS_VEL_FORWARDS_2D_MAX: f32 = 838_f32;
    pub const ACCURACY_INS_VEL_BODY_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_BODY_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Vel_Body_Axes from values
    pub fn new(ins_vel_sideways_2d: f32, ins_vel_forwards_2d: f32, accuracy_ins_vel_body: u8, validity_ins_vel_sideways: bool, validity_ins_vel_forwards: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_vel_sideways_2d(ins_vel_sideways_2d)?;
        res.set_ins_vel_forwards_2d(ins_vel_forwards_2d)?;
        res.set_accuracy_ins_vel_body(accuracy_ins_vel_body)?;
        res.set_validity_ins_vel_sideways(validity_ins_vel_sideways)?;
        res.set_validity_ins_vel_forwards(validity_ins_vel_forwards)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Vel_Sideways_2D
    ///
    /// Sideways Velocity in the vehicle body axes, 2D (no vertical component) .  +ve for motion to the vehicle RHS.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_sideways_2d(&self) -> f32 {
        self.ins_vel_sideways_2d_raw()
    }
    
    /// Get raw value of INS_Vel_Sideways_2D
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_sideways_2d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_Sideways_2D
    #[inline(always)]
    pub fn set_ins_vel_sideways_2d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelBodyAxes::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// INS_Vel_Forwards_2D
    ///
    /// Forwards Velocity in the vehicle body axes, 2D (no vertical component) .
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_forwards_2d(&self) -> f32 {
        self.ins_vel_forwards_2d_raw()
    }
    
    /// Get raw value of INS_Vel_Forwards_2D
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_forwards_2d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_Forwards_2D
    #[inline(always)]
    pub fn set_ins_vel_forwards_2d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelBodyAxes::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_Body
    ///
    /// Accuracy of INS body axis velocities (forward velocity and sideways velocity)
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_body(&self) -> u8 {
        self.accuracy_ins_vel_body_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_Body
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_body_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_Body
    #[inline(always)]
    pub fn set_accuracy_ins_vel_body(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelBodyAxes::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelBodyAxes::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_Sideways
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_sideways(&self) -> bool {
        self.validity_ins_vel_sideways_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_Sideways
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_sideways_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_Sideways
    #[inline(always)]
    pub fn set_validity_ins_vel_sideways(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_Forwards
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_forwards(&self) -> bool {
        self.validity_ins_vel_forwards_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_Forwards
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_forwards_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_Forwards
    #[inline(always)]
    pub fn set_validity_ins_vel_forwards(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVelBodyAxes {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVelBodyAxes {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Speed
///
/// - Extended ID: 155876388 (0x94a7c24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Speed {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Speed {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a7c24)});
    
    pub const SPEED_MIN: f32 = -20000_f32;
    pub const SPEED_MAX: f32 = 20000_f32;
    pub const ACCURACY_SPEED_MIN: u8 = 0_u8;
    pub const ACCURACY_SPEED_MAX: u8 = 255_u8;
    
    /// Construct new RT_DL1MK3_Speed from values
    pub fn new(speed: f32, accuracy_speed: u8, validity_speed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_speed(speed)?;
        res.set_accuracy_speed(accuracy_speed)?;
        res.set_validity_speed(validity_speed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Speed
    ///
    /// - Min: -20000
    /// - Max: 20000
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn speed(&self) -> f32 {
        self.speed_raw()
    }
    
    /// Get raw value of Speed
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 0.00001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..48].load_le::<i32>();
        
        let factor = 0.00001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Speed
    #[inline(always)]
    pub fn set_speed(&mut self, value: f32) -> Result<(), CanError> {
        if value < -20000_f32 || 20000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Speed::MESSAGE_ID });
        }
        let factor = 0.00001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..48].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Speed
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_speed(&self) -> u8 {
        self.accuracy_speed_raw()
    }
    
    /// Get raw value of Accuracy_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Speed
    #[inline(always)]
    pub fn set_accuracy_speed(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Speed::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3Speed::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Speed
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_speed(&self) -> bool {
        self.validity_speed_raw()
    }
    
    /// Get raw value of Validity_Speed
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Speed
    #[inline(always)]
    pub fn set_validity_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Speed {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Speed {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_GPS_Time
///
/// - Extended ID: 156658980 (0x9566d24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3GpsTime {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3GpsTime {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566d24)});
    
    pub const GPS_WEEK_MIN: u16 = 0_u16;
    pub const GPS_WEEK_MAX: u16 = 65535_u16;
    pub const GPS_TIME_MIN: f32 = 0_f32;
    pub const GPS_TIME_MAX: f32 = 604800_f32;
    pub const ACCURACY_GPS_TIME_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_TIME_MAX: u8 = 255_u8;
    
    /// Construct new RT_DL1MK3_GPS_Time from values
    pub fn new(gps_week: u16, gps_time: f32, accuracy_gps_time: u8, validity_gps_week: bool, validity_gps_time: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_week(gps_week)?;
        res.set_gps_time(gps_time)?;
        res.set_accuracy_gps_time(accuracy_gps_time)?;
        res.set_validity_gps_week(validity_gps_week)?;
        res.set_validity_gps_time(validity_gps_time)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Week
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_week(&self) -> u16 {
        self.gps_week_raw()
    }
    
    /// Get raw value of GPS_Week
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_week_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        let factor = 1;
        u16::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_Week
    #[inline(always)]
    pub fn set_gps_week(&mut self, value: u16) -> Result<(), CanError> {
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsTime::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsTime::MESSAGE_ID })?;
        let value = (value / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Time
    ///
    /// GPS time is the time in seconds since midnight GMT on Saturday night.
    ///
    /// - Min: 0
    /// - Max: 604800
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_time(&self) -> f32 {
        self.gps_time_raw()
    }
    
    /// Get raw value of GPS_Time
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..48].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Time
    #[inline(always)]
    pub fn set_gps_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 604800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsTime::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[16..48].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Time
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_time(&self) -> u8 {
        self.accuracy_gps_time_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Time
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_time_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Time
    #[inline(always)]
    pub fn set_accuracy_gps_time(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsTime::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsTime::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Week
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_week(&self) -> bool {
        self.validity_gps_week_raw()
    }
    
    /// Get raw value of Validity_GPS_Week
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_week_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Week
    #[inline(always)]
    pub fn set_validity_gps_week(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Time
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_time(&self) -> bool {
        self.validity_gps_time_raw()
    }
    
    /// Get raw value of Validity_GPS_Time
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_time_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Time
    #[inline(always)]
    pub fn set_validity_gps_time(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3GpsTime {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3GpsTime {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_GPS_Pos_LLH_2
///
/// - Extended ID: 156659492 (0x9566f24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3GpsPosLlh2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3GpsPosLlh2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566f24)});
    
    pub const GPS_POS_LLH_ALTITUDE_MIN: f32 = -1000_f32;
    pub const GPS_POS_LLH_ALTITUDE_MAX: f32 = 100000_f32;
    pub const GPS_POS_LLH_LONGITUDE_MIN: f32 = -180_f32;
    pub const GPS_POS_LLH_LONGITUDE_MAX: f32 = 180_f32;
    
    /// Construct new RT_DL1MK3_GPS_Pos_LLH_2 from values
    pub fn new(gps_pos_llh_altitude: f32, gps_pos_llh_longitude: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_llh_altitude(gps_pos_llh_altitude)?;
        res.set_gps_pos_llh_longitude(gps_pos_llh_longitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_LLH_Altitude
    ///
    /// - Min: -1000
    /// - Max: 100000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_altitude(&self) -> f32 {
        self.gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_altitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_gps_pos_llh_altitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -1000_f32 || 100000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Pos_LLH_Longitude
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_longitude(&self) -> f32 {
        self.gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_longitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_gps_pos_llh_longitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3GpsPosLlh2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3GpsPosLlh2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_GPS_Pos_LLH_1
///
/// - Extended ID: 156659236 (0x9566e24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3GpsPosLlh1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3GpsPosLlh1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566e24)});
    
    pub const GPS_POS_LLH_LATITUDE_MIN: f32 = -90_f32;
    pub const GPS_POS_LLH_LATITUDE_MAX: f32 = 90_f32;
    pub const ACCURACY_GPS_POS_LLH_ALTITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_ALTITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_LLH_LONGITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_LONGITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_LLH_LATITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_LATITUDE_MAX: u8 = 255_u8;
    
    /// Construct new RT_DL1MK3_GPS_Pos_LLH_1 from values
    pub fn new(gps_pos_llh_latitude: f32, accuracy_gps_pos_llh_altitude: u8, accuracy_gps_pos_llh_longitude: u8, accuracy_gps_pos_llh_latitude: u8, validity_gps_pos_llh_altitude: bool, validity_gps_pos_llh_longitude: bool, validity_gps_pos_llh_latitude: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_llh_latitude(gps_pos_llh_latitude)?;
        res.set_accuracy_gps_pos_llh_altitude(accuracy_gps_pos_llh_altitude)?;
        res.set_accuracy_gps_pos_llh_longitude(accuracy_gps_pos_llh_longitude)?;
        res.set_accuracy_gps_pos_llh_latitude(accuracy_gps_pos_llh_latitude)?;
        res.set_validity_gps_pos_llh_altitude(validity_gps_pos_llh_altitude)?;
        res.set_validity_gps_pos_llh_longitude(validity_gps_pos_llh_longitude)?;
        res.set_validity_gps_pos_llh_latitude(validity_gps_pos_llh_latitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_LLH_Latitude
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_latitude(&self) -> f32 {
        self.gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_latitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_gps_pos_llh_latitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Altitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_altitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_altitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_altitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Longitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_longitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_longitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_longitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Latitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_latitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_latitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_latitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Altitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_altitude(&self) -> bool {
        self.validity_gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_altitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_altitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Longitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_longitude(&self) -> bool {
        self.validity_gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_longitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_longitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Latitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_latitude(&self) -> bool {
        self.validity_gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_latitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_latitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3GpsPosLlh1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3GpsPosLlh1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_GPS_Speed
///
/// - Extended ID: 156662820 (0x9567c24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3GpsSpeed {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3GpsSpeed {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567c24)});
    
    pub const GPS_SPEED_3D_MIN: f32 = 0_f32;
    pub const GPS_SPEED_3D_MAX: f32 = 1675_f32;
    pub const GPS_SPEED_2D_MIN: f32 = 0_f32;
    pub const GPS_SPEED_2D_MAX: f32 = 1675_f32;
    pub const ACCURACY_GPS_SPEED_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_SPEED_MAX: u8 = 255_u8;
    
    /// Construct new RT_DL1MK3_GPS_Speed from values
    pub fn new(gps_speed_3d: f32, gps_speed_2d: f32, accuracy_gps_speed: u8, validity_gps_speed_3d: bool, validity_gps_speed_2d: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_speed_3d(gps_speed_3d)?;
        res.set_gps_speed_2d(gps_speed_2d)?;
        res.set_accuracy_gps_speed(accuracy_gps_speed)?;
        res.set_validity_gps_speed_3d(validity_gps_speed_3d)?;
        res.set_validity_gps_speed_2d(validity_gps_speed_2d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Speed_3D
    ///
    /// This is GPS scalar 3D speed - scalar speed with the local Z axis component included.
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_speed_3d(&self) -> f32 {
        self.gps_speed_3d_raw()
    }
    
    /// Get raw value of GPS_Speed_3D
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_speed_3d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Speed_3D
    #[inline(always)]
    pub fn set_gps_speed_3d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsSpeed::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Speed_2D
    ///
    /// This is GPS scalar 2D speed - scalar speed with no local Z axis component included.
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_speed_2d(&self) -> f32 {
        self.gps_speed_2d_raw()
    }
    
    /// Get raw value of GPS_Speed_2D
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_speed_2d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Speed_2D
    #[inline(always)]
    pub fn set_gps_speed_2d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsSpeed::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Speed
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_speed(&self) -> u8 {
        self.accuracy_gps_speed_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Speed
    #[inline(always)]
    pub fn set_accuracy_gps_speed(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsSpeed::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3GpsSpeed::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Speed_3D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_speed_3d(&self) -> bool {
        self.validity_gps_speed_3d_raw()
    }
    
    /// Get raw value of Validity_GPS_Speed_3D
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_speed_3d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Speed_3D
    #[inline(always)]
    pub fn set_validity_gps_speed_3d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Speed_2D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_speed_2d(&self) -> bool {
        self.validity_gps_speed_2d_raw()
    }
    
    /// Get raw value of Validity_GPS_Speed_2D
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_speed_2d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Speed_2D
    #[inline(always)]
    pub fn set_validity_gps_speed_2d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3GpsSpeed {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3GpsSpeed {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_7
///
/// - Extended ID: 156988197 (0x95b7325)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp7 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp7 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7325)});
    
    pub const IR_TEMPERATURE_7_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_7_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_7 from values
    pub fn new(ir_temperature_7: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_7(ir_temperature_7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_7(&self) -> f32 {
        self.ir_temperature_7_raw()
    }
    
    /// Get raw value of IR_Temperature_7
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_7_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_7
    #[inline(always)]
    pub fn set_ir_temperature_7(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp7::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp7 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_RR_2
///
/// - Extended ID: 157447205 (0x9627425)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempRr2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempRr2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9627425)});
    
    pub const IR_TEMPERATURE_32_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_32_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_31_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_31_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_30_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_30_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_29_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_29_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_RR_2 from values
    pub fn new(ir_temperature_32: f32, ir_temperature_31: f32, ir_temperature_30: f32, ir_temperature_29: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_32(ir_temperature_32)?;
        res.set_ir_temperature_31(ir_temperature_31)?;
        res.set_ir_temperature_30(ir_temperature_30)?;
        res.set_ir_temperature_29(ir_temperature_29)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_32
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_32(&self) -> f32 {
        self.ir_temperature_32_raw()
    }
    
    /// Get raw value of IR_Temperature_32
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_32_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_32
    #[inline(always)]
    pub fn set_ir_temperature_32(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_31
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_31(&self) -> f32 {
        self.ir_temperature_31_raw()
    }
    
    /// Get raw value of IR_Temperature_31
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_31_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_31
    #[inline(always)]
    pub fn set_ir_temperature_31(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_30
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_30(&self) -> f32 {
        self.ir_temperature_30_raw()
    }
    
    /// Get raw value of IR_Temperature_30
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_30_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_30
    #[inline(always)]
    pub fn set_ir_temperature_30(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_29
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_29(&self) -> f32 {
        self.ir_temperature_29_raw()
    }
    
    /// Get raw value of IR_Temperature_29
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_29_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_29
    #[inline(always)]
    pub fn set_ir_temperature_29(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempRr2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempRr2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_RL_2
///
/// - Extended ID: 157446693 (0x9627225)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempRl2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempRl2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9627225)});
    
    pub const IR_TEMPERATURE_24_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_24_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_23_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_23_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_22_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_22_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_21_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_21_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_RL_2 from values
    pub fn new(ir_temperature_24: f32, ir_temperature_23: f32, ir_temperature_22: f32, ir_temperature_21: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_24(ir_temperature_24)?;
        res.set_ir_temperature_23(ir_temperature_23)?;
        res.set_ir_temperature_22(ir_temperature_22)?;
        res.set_ir_temperature_21(ir_temperature_21)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_24
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_24(&self) -> f32 {
        self.ir_temperature_24_raw()
    }
    
    /// Get raw value of IR_Temperature_24
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_24_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_24
    #[inline(always)]
    pub fn set_ir_temperature_24(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_23
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_23(&self) -> f32 {
        self.ir_temperature_23_raw()
    }
    
    /// Get raw value of IR_Temperature_23
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_23_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_23
    #[inline(always)]
    pub fn set_ir_temperature_23(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_22
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_22(&self) -> f32 {
        self.ir_temperature_22_raw()
    }
    
    /// Get raw value of IR_Temperature_22
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_22_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_22
    #[inline(always)]
    pub fn set_ir_temperature_22(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_21
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_21(&self) -> f32 {
        self.ir_temperature_21_raw()
    }
    
    /// Get raw value of IR_Temperature_21
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_21_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_21
    #[inline(always)]
    pub fn set_ir_temperature_21(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempRl2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempRl2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_FR_2
///
/// - Extended ID: 157446181 (0x9627025)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempFr2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempFr2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9627025)});
    
    pub const IR_TEMPERATURE_16_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_16_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_15_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_15_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_14_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_14_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_13_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_13_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_FR_2 from values
    pub fn new(ir_temperature_16: f32, ir_temperature_15: f32, ir_temperature_14: f32, ir_temperature_13: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_16(ir_temperature_16)?;
        res.set_ir_temperature_15(ir_temperature_15)?;
        res.set_ir_temperature_14(ir_temperature_14)?;
        res.set_ir_temperature_13(ir_temperature_13)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_16
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_16(&self) -> f32 {
        self.ir_temperature_16_raw()
    }
    
    /// Get raw value of IR_Temperature_16
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_16_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_16
    #[inline(always)]
    pub fn set_ir_temperature_16(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_15
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_15(&self) -> f32 {
        self.ir_temperature_15_raw()
    }
    
    /// Get raw value of IR_Temperature_15
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_15_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_15
    #[inline(always)]
    pub fn set_ir_temperature_15(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_14
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_14(&self) -> f32 {
        self.ir_temperature_14_raw()
    }
    
    /// Get raw value of IR_Temperature_14
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_14_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_14
    #[inline(always)]
    pub fn set_ir_temperature_14(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_13
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_13(&self) -> f32 {
        self.ir_temperature_13_raw()
    }
    
    /// Get raw value of IR_Temperature_13
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_13_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_13
    #[inline(always)]
    pub fn set_ir_temperature_13(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempFr2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempFr2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_FL_2
///
/// - Extended ID: 157445669 (0x9626e25)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempFl2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempFl2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9626e25)});
    
    pub const IR_TEMPERATURE_8_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_8_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_7_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_7_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_6_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_6_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_5_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_FL_2 from values
    pub fn new(ir_temperature_8: f32, ir_temperature_7: f32, ir_temperature_6: f32, ir_temperature_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_8(ir_temperature_8)?;
        res.set_ir_temperature_7(ir_temperature_7)?;
        res.set_ir_temperature_6(ir_temperature_6)?;
        res.set_ir_temperature_5(ir_temperature_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_8(&self) -> f32 {
        self.ir_temperature_8_raw()
    }
    
    /// Get raw value of IR_Temperature_8
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_8_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_8
    #[inline(always)]
    pub fn set_ir_temperature_8(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_7(&self) -> f32 {
        self.ir_temperature_7_raw()
    }
    
    /// Get raw value of IR_Temperature_7
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_7_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_7
    #[inline(always)]
    pub fn set_ir_temperature_7(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_6(&self) -> f32 {
        self.ir_temperature_6_raw()
    }
    
    /// Get raw value of IR_Temperature_6
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_6_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_6
    #[inline(always)]
    pub fn set_ir_temperature_6(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_5(&self) -> f32 {
        self.ir_temperature_5_raw()
    }
    
    /// Get raw value of IR_Temperature_5
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_5
    #[inline(always)]
    pub fn set_ir_temperature_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempFl2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempFl2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_RR_1
///
/// - Extended ID: 157446949 (0x9627325)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempRr1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempRr1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9627325)});
    
    pub const IR_TEMPERATURE_28_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_28_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_27_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_27_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_26_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_26_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_25_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_25_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_RR_1 from values
    pub fn new(ir_temperature_28: f32, ir_temperature_27: f32, ir_temperature_26: f32, ir_temperature_25: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_28(ir_temperature_28)?;
        res.set_ir_temperature_27(ir_temperature_27)?;
        res.set_ir_temperature_26(ir_temperature_26)?;
        res.set_ir_temperature_25(ir_temperature_25)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_28
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_28(&self) -> f32 {
        self.ir_temperature_28_raw()
    }
    
    /// Get raw value of IR_Temperature_28
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_28_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_28
    #[inline(always)]
    pub fn set_ir_temperature_28(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_27
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_27(&self) -> f32 {
        self.ir_temperature_27_raw()
    }
    
    /// Get raw value of IR_Temperature_27
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_27_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_27
    #[inline(always)]
    pub fn set_ir_temperature_27(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_26
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_26(&self) -> f32 {
        self.ir_temperature_26_raw()
    }
    
    /// Get raw value of IR_Temperature_26
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_26_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_26
    #[inline(always)]
    pub fn set_ir_temperature_26(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_25
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_25(&self) -> f32 {
        self.ir_temperature_25_raw()
    }
    
    /// Get raw value of IR_Temperature_25
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_25_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_25
    #[inline(always)]
    pub fn set_ir_temperature_25(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempRr1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempRr1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_RL_1
///
/// - Extended ID: 157446437 (0x9627125)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempRl1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempRl1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9627125)});
    
    pub const IR_TEMPERATURE_20_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_20_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_19_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_19_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_18_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_18_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_17_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_17_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_RL_1 from values
    pub fn new(ir_temperature_20: f32, ir_temperature_19: f32, ir_temperature_18: f32, ir_temperature_17: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_20(ir_temperature_20)?;
        res.set_ir_temperature_19(ir_temperature_19)?;
        res.set_ir_temperature_18(ir_temperature_18)?;
        res.set_ir_temperature_17(ir_temperature_17)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_20
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_20(&self) -> f32 {
        self.ir_temperature_20_raw()
    }
    
    /// Get raw value of IR_Temperature_20
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_20_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_20
    #[inline(always)]
    pub fn set_ir_temperature_20(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_19
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_19(&self) -> f32 {
        self.ir_temperature_19_raw()
    }
    
    /// Get raw value of IR_Temperature_19
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_19_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_19
    #[inline(always)]
    pub fn set_ir_temperature_19(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_18
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_18(&self) -> f32 {
        self.ir_temperature_18_raw()
    }
    
    /// Get raw value of IR_Temperature_18
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_18_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_18
    #[inline(always)]
    pub fn set_ir_temperature_18(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_17
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_17(&self) -> f32 {
        self.ir_temperature_17_raw()
    }
    
    /// Get raw value of IR_Temperature_17
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_17_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_17
    #[inline(always)]
    pub fn set_ir_temperature_17(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempRl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempRl1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempRl1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_FR_1
///
/// - Extended ID: 157445925 (0x9626f25)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempFr1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempFr1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9626f25)});
    
    pub const IR_TEMPERATURE_12_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_12_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_11_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_11_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_10_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_10_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_9_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_9_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_FR_1 from values
    pub fn new(ir_temperature_12: f32, ir_temperature_11: f32, ir_temperature_10: f32, ir_temperature_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_12(ir_temperature_12)?;
        res.set_ir_temperature_11(ir_temperature_11)?;
        res.set_ir_temperature_10(ir_temperature_10)?;
        res.set_ir_temperature_9(ir_temperature_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_12(&self) -> f32 {
        self.ir_temperature_12_raw()
    }
    
    /// Get raw value of IR_Temperature_12
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_12_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_12
    #[inline(always)]
    pub fn set_ir_temperature_12(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_11(&self) -> f32 {
        self.ir_temperature_11_raw()
    }
    
    /// Get raw value of IR_Temperature_11
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_11_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_11
    #[inline(always)]
    pub fn set_ir_temperature_11(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_10(&self) -> f32 {
        self.ir_temperature_10_raw()
    }
    
    /// Get raw value of IR_Temperature_10
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_10_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_10
    #[inline(always)]
    pub fn set_ir_temperature_10(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_9(&self) -> f32 {
        self.ir_temperature_9_raw()
    }
    
    /// Get raw value of IR_Temperature_9
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_9
    #[inline(always)]
    pub fn set_ir_temperature_9(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFr1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempFr1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempFr1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_FL_1
///
/// - Extended ID: 157445413 (0x9626d25)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTempFl1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTempFl1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9626d25)});
    
    pub const IR_TEMPERATURE_4_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_4_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_3_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_3_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_2_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_2_MAX: f32 = 0_f32;
    pub const IR_TEMPERATURE_1_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_FL_1 from values
    pub fn new(ir_temperature_4: f32, ir_temperature_3: f32, ir_temperature_2: f32, ir_temperature_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ir_temperature_4(ir_temperature_4)?;
        res.set_ir_temperature_3(ir_temperature_3)?;
        res.set_ir_temperature_2(ir_temperature_2)?;
        res.set_ir_temperature_1(ir_temperature_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// IR_Temperature_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_4(&self) -> f32 {
        self.ir_temperature_4_raw()
    }
    
    /// Get raw value of IR_Temperature_4
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_4
    #[inline(always)]
    pub fn set_ir_temperature_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_3(&self) -> f32 {
        self.ir_temperature_3_raw()
    }
    
    /// Get raw value of IR_Temperature_3
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_3
    #[inline(always)]
    pub fn set_ir_temperature_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_2(&self) -> f32 {
        self.ir_temperature_2_raw()
    }
    
    /// Get raw value of IR_Temperature_2
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_2
    #[inline(always)]
    pub fn set_ir_temperature_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// IR_Temperature_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_1(&self) -> f32 {
        self.ir_temperature_1_raw()
    }
    
    /// Get raw value of IR_Temperature_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_1
    #[inline(always)]
    pub fn set_ir_temperature_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTempFl1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTempFl1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTempFl1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_32
///
/// - Extended ID: 156994597 (0x95b8c25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp32 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp32 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8c25)});
    
    pub const IR_TEMPERATURE_32_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_32_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_32 from values
    pub fn new(ir_temperature_32: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_32(ir_temperature_32)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_32
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_32(&self) -> f32 {
        self.ir_temperature_32_raw()
    }
    
    /// Get raw value of IR_Temperature_32
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_32_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_32
    #[inline(always)]
    pub fn set_ir_temperature_32(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp32::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp32 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp32 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_31
///
/// - Extended ID: 156994341 (0x95b8b25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp31 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp31 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8b25)});
    
    pub const IR_TEMPERATURE_31_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_31_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_31 from values
    pub fn new(ir_temperature_31: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_31(ir_temperature_31)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_31
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_31(&self) -> f32 {
        self.ir_temperature_31_raw()
    }
    
    /// Get raw value of IR_Temperature_31
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_31_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_31
    #[inline(always)]
    pub fn set_ir_temperature_31(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp31::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp31 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp31 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_30
///
/// - Extended ID: 156994085 (0x95b8a25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp30 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp30 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8a25)});
    
    pub const IR_TEMPERATURE_30_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_30_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_30 from values
    pub fn new(ir_temperature_30: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_30(ir_temperature_30)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_30
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_30(&self) -> f32 {
        self.ir_temperature_30_raw()
    }
    
    /// Get raw value of IR_Temperature_30
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_30_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_30
    #[inline(always)]
    pub fn set_ir_temperature_30(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp30::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp30 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp30 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_29
///
/// - Extended ID: 156993829 (0x95b8925)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp29 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp29 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8925)});
    
    pub const IR_TEMPERATURE_29_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_29_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_29 from values
    pub fn new(ir_temperature_29: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_29(ir_temperature_29)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_29
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_29(&self) -> f32 {
        self.ir_temperature_29_raw()
    }
    
    /// Get raw value of IR_Temperature_29
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_29_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_29
    #[inline(always)]
    pub fn set_ir_temperature_29(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp29::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp29 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp29 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_28
///
/// - Extended ID: 156993573 (0x95b8825)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp28 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp28 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8825)});
    
    pub const IR_TEMPERATURE_28_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_28_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_28 from values
    pub fn new(ir_temperature_28: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_28(ir_temperature_28)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_28
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_28(&self) -> f32 {
        self.ir_temperature_28_raw()
    }
    
    /// Get raw value of IR_Temperature_28
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_28_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_28
    #[inline(always)]
    pub fn set_ir_temperature_28(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp28::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp28 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp28 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_27
///
/// - Extended ID: 156993317 (0x95b8725)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp27 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp27 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8725)});
    
    pub const IR_TEMPERATURE_27_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_27_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_27 from values
    pub fn new(ir_temperature_27: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_27(ir_temperature_27)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_27
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_27(&self) -> f32 {
        self.ir_temperature_27_raw()
    }
    
    /// Get raw value of IR_Temperature_27
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_27_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_27
    #[inline(always)]
    pub fn set_ir_temperature_27(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp27::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp27 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp27 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_26
///
/// - Extended ID: 156993061 (0x95b8625)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp26 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp26 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8625)});
    
    pub const IR_TEMPERATURE_26_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_26_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_26 from values
    pub fn new(ir_temperature_26: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_26(ir_temperature_26)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_26
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_26(&self) -> f32 {
        self.ir_temperature_26_raw()
    }
    
    /// Get raw value of IR_Temperature_26
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_26_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_26
    #[inline(always)]
    pub fn set_ir_temperature_26(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp26::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp26 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp26 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_25
///
/// - Extended ID: 156992805 (0x95b8525)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp25 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp25 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8525)});
    
    pub const IR_TEMPERATURE_25_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_25_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_25 from values
    pub fn new(ir_temperature_25: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_25(ir_temperature_25)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_25
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_25(&self) -> f32 {
        self.ir_temperature_25_raw()
    }
    
    /// Get raw value of IR_Temperature_25
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_25_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_25
    #[inline(always)]
    pub fn set_ir_temperature_25(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp25::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp25 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp25 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_24
///
/// - Extended ID: 156992549 (0x95b8425)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp24 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp24 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8425)});
    
    pub const IR_TEMPERATURE_24_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_24_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_24 from values
    pub fn new(ir_temperature_24: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_24(ir_temperature_24)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_24
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_24(&self) -> f32 {
        self.ir_temperature_24_raw()
    }
    
    /// Get raw value of IR_Temperature_24
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_24_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_24
    #[inline(always)]
    pub fn set_ir_temperature_24(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp24::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp24 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp24 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_22
///
/// - Extended ID: 156992037 (0x95b8225)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp22 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp22 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8225)});
    
    pub const IR_TEMPERATURE_22_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_22_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_22 from values
    pub fn new(ir_temperature_22: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_22(ir_temperature_22)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_22
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_22(&self) -> f32 {
        self.ir_temperature_22_raw()
    }
    
    /// Get raw value of IR_Temperature_22
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_22_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_22
    #[inline(always)]
    pub fn set_ir_temperature_22(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp22::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp22 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp22 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_23
///
/// - Extended ID: 156992293 (0x95b8325)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp23 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp23 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8325)});
    
    pub const IR_TEMPERATURE_23_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_23_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_23 from values
    pub fn new(ir_temperature_23: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_23(ir_temperature_23)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_23
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_23(&self) -> f32 {
        self.ir_temperature_23_raw()
    }
    
    /// Get raw value of IR_Temperature_23
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_23_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_23
    #[inline(always)]
    pub fn set_ir_temperature_23(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp23::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp23 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp23 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_21
///
/// - Extended ID: 156991781 (0x95b8125)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp21 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp21 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8125)});
    
    pub const IR_TEMPERATURE_21_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_21_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_21 from values
    pub fn new(ir_temperature_21: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_21(ir_temperature_21)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_21
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_21(&self) -> f32 {
        self.ir_temperature_21_raw()
    }
    
    /// Get raw value of IR_Temperature_21
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_21_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_21
    #[inline(always)]
    pub fn set_ir_temperature_21(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp21::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp21 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp21 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_20
///
/// - Extended ID: 156991525 (0x95b8025)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp20 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp20 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8025)});
    
    pub const IR_TEMPERATURE_20_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_20_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_20 from values
    pub fn new(ir_temperature_20: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_20(ir_temperature_20)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_20
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_20(&self) -> f32 {
        self.ir_temperature_20_raw()
    }
    
    /// Get raw value of IR_Temperature_20
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_20_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_20
    #[inline(always)]
    pub fn set_ir_temperature_20(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp20::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp20 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp20 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_19
///
/// - Extended ID: 156991269 (0x95b7f25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp19 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp19 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7f25)});
    
    pub const IR_TEMPERATURE_19_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_19_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_19 from values
    pub fn new(ir_temperature_19: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_19(ir_temperature_19)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_19
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_19(&self) -> f32 {
        self.ir_temperature_19_raw()
    }
    
    /// Get raw value of IR_Temperature_19
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_19_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_19
    #[inline(always)]
    pub fn set_ir_temperature_19(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp19::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp19 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp19 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_18
///
/// - Extended ID: 156991013 (0x95b7e25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp18 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp18 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7e25)});
    
    pub const IR_TEMPERATURE_18_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_18_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_18 from values
    pub fn new(ir_temperature_18: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_18(ir_temperature_18)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_18
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_18(&self) -> f32 {
        self.ir_temperature_18_raw()
    }
    
    /// Get raw value of IR_Temperature_18
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_18_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_18
    #[inline(always)]
    pub fn set_ir_temperature_18(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp18::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp18 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp18 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_16
///
/// - Extended ID: 156990501 (0x95b7c25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp16 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp16 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7c25)});
    
    pub const IR_TEMPERATURE_16_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_16_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_16 from values
    pub fn new(ir_temperature_16: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_16(ir_temperature_16)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_16
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_16(&self) -> f32 {
        self.ir_temperature_16_raw()
    }
    
    /// Get raw value of IR_Temperature_16
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_16_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_16
    #[inline(always)]
    pub fn set_ir_temperature_16(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp16::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp16 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_15
///
/// - Extended ID: 156990245 (0x95b7b25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp15 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp15 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7b25)});
    
    pub const IR_TEMPERATURE_15_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_15_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_15 from values
    pub fn new(ir_temperature_15: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_15(ir_temperature_15)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_15
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_15(&self) -> f32 {
        self.ir_temperature_15_raw()
    }
    
    /// Get raw value of IR_Temperature_15
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_15_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_15
    #[inline(always)]
    pub fn set_ir_temperature_15(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp15::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp15 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_14
///
/// - Extended ID: 156989989 (0x95b7a25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp14 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp14 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7a25)});
    
    pub const IR_TEMPERATURE_14_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_14_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_14 from values
    pub fn new(ir_temperature_14: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_14(ir_temperature_14)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_14
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_14(&self) -> f32 {
        self.ir_temperature_14_raw()
    }
    
    /// Get raw value of IR_Temperature_14
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_14_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_14
    #[inline(always)]
    pub fn set_ir_temperature_14(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp14::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp14 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_13
///
/// - Extended ID: 156989733 (0x95b7925)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp13 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp13 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7925)});
    
    pub const IR_TEMPERATURE_13_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_13_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_13 from values
    pub fn new(ir_temperature_13: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_13(ir_temperature_13)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_13
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_13(&self) -> f32 {
        self.ir_temperature_13_raw()
    }
    
    /// Get raw value of IR_Temperature_13
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_13_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_13
    #[inline(always)]
    pub fn set_ir_temperature_13(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp13::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp13 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_12
///
/// - Extended ID: 156989477 (0x95b7825)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp12 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp12 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7825)});
    
    pub const IR_TEMPERATURE_12_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_12_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_12 from values
    pub fn new(ir_temperature_12: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_12(ir_temperature_12)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_12(&self) -> f32 {
        self.ir_temperature_12_raw()
    }
    
    /// Get raw value of IR_Temperature_12
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_12_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_12
    #[inline(always)]
    pub fn set_ir_temperature_12(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp12::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp12 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_11
///
/// - Extended ID: 156989221 (0x95b7725)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp11 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp11 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7725)});
    
    pub const IR_TEMPERATURE_11_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_11_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_11 from values
    pub fn new(ir_temperature_11: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_11(ir_temperature_11)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_11(&self) -> f32 {
        self.ir_temperature_11_raw()
    }
    
    /// Get raw value of IR_Temperature_11
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_11_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_11
    #[inline(always)]
    pub fn set_ir_temperature_11(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp11::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp11 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_10
///
/// - Extended ID: 156988965 (0x95b7625)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp10 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp10 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7625)});
    
    pub const IR_TEMPERATURE_10_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_10_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_10 from values
    pub fn new(ir_temperature_10: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_10(ir_temperature_10)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_10(&self) -> f32 {
        self.ir_temperature_10_raw()
    }
    
    /// Get raw value of IR_Temperature_10
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_10_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_10
    #[inline(always)]
    pub fn set_ir_temperature_10(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp10::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp10 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_8
///
/// - Extended ID: 156988453 (0x95b7425)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp8 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp8 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7425)});
    
    pub const IR_TEMPERATURE_8_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_8_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_8 from values
    pub fn new(ir_temperature_8: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_8(ir_temperature_8)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_8(&self) -> f32 {
        self.ir_temperature_8_raw()
    }
    
    /// Get raw value of IR_Temperature_8
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_8_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_8
    #[inline(always)]
    pub fn set_ir_temperature_8(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp8::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp8 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp8 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_9
///
/// - Extended ID: 156988709 (0x95b7525)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp9 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp9 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7525)});
    
    pub const IR_TEMPERATURE_9_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_9_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_9 from values
    pub fn new(ir_temperature_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_9(ir_temperature_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_9(&self) -> f32 {
        self.ir_temperature_9_raw()
    }
    
    /// Get raw value of IR_Temperature_9
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_9
    #[inline(always)]
    pub fn set_ir_temperature_9(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp9::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp9 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp9 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_17
///
/// - Extended ID: 156990757 (0x95b7d25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp17 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp17 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7d25)});
    
    pub const IR_TEMPERATURE_17_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_17_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_17 from values
    pub fn new(ir_temperature_17: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_17(ir_temperature_17)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_17
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_17(&self) -> f32 {
        self.ir_temperature_17_raw()
    }
    
    /// Get raw value of IR_Temperature_17
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_17_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_17
    #[inline(always)]
    pub fn set_ir_temperature_17(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp17::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp17 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp17 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_6
///
/// - Extended ID: 156987941 (0x95b7225)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp6 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp6 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7225)});
    
    pub const IR_TEMPERATURE_6_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_6_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_6 from values
    pub fn new(ir_temperature_6: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_6(ir_temperature_6)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_6(&self) -> f32 {
        self.ir_temperature_6_raw()
    }
    
    /// Get raw value of IR_Temperature_6
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_6_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_6
    #[inline(always)]
    pub fn set_ir_temperature_6(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp6::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp6 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_5
///
/// - Extended ID: 156987685 (0x95b7125)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp5 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7125)});
    
    pub const IR_TEMPERATURE_5_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_5 from values
    pub fn new(ir_temperature_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_5(ir_temperature_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_5(&self) -> f32 {
        self.ir_temperature_5_raw()
    }
    
    /// Get raw value of IR_Temperature_5
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_5
    #[inline(always)]
    pub fn set_ir_temperature_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp5::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_4
///
/// - Extended ID: 156987429 (0x95b7025)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp4 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7025)});
    
    pub const IR_TEMPERATURE_4_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_4 from values
    pub fn new(ir_temperature_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_4(ir_temperature_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_4(&self) -> f32 {
        self.ir_temperature_4_raw()
    }
    
    /// Get raw value of IR_Temperature_4
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_4
    #[inline(always)]
    pub fn set_ir_temperature_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp4::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_3
///
/// - Extended ID: 156987173 (0x95b6f25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6f25)});
    
    pub const IR_TEMPERATURE_3_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_3 from values
    pub fn new(ir_temperature_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_3(ir_temperature_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_3(&self) -> f32 {
        self.ir_temperature_3_raw()
    }
    
    /// Get raw value of IR_Temperature_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_3
    #[inline(always)]
    pub fn set_ir_temperature_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_2
///
/// - Extended ID: 156986917 (0x95b6e25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6e25)});
    
    pub const IR_TEMPERATURE_2_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_2 from values
    pub fn new(ir_temperature_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_2(ir_temperature_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_2(&self) -> f32 {
        self.ir_temperature_2_raw()
    }
    
    /// Get raw value of IR_Temperature_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_2
    #[inline(always)]
    pub fn set_ir_temperature_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IRTemp_Temp_1
///
/// - Extended ID: 156986661 (0x95b6d25)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtIrTempTemp1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtIrTempTemp1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6d25)});
    
    pub const IR_TEMPERATURE_1_MIN: f32 = 0_f32;
    pub const IR_TEMPERATURE_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_IRTemp_Temp_1 from values
    pub fn new(ir_temperature_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_ir_temperature_1(ir_temperature_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// IR_Temperature_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ir_temperature_1(&self) -> f32 {
        self.ir_temperature_1_raw()
    }
    
    /// Get raw value of IR_Temperature_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ir_temperature_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of IR_Temperature_1
    #[inline(always)]
    pub fn set_ir_temperature_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtIrTempTemp1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtIrTempTemp1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtIrTempTemp1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Final_Condition
///
/// - Extended ID: 156726050 (0x9577322)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigFinalCondition {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigFinalCondition {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9577322)});
    
    pub const FINAL_SPEED_MIN: f32 = 0_f32;
    pub const FINAL_SPEED_MAX: f32 = 1675_f32;
    
    /// Construct new RT_SB_Trig_Final_Condition from values
    pub fn new(final_speed: f32, validity_final_speed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_final_speed(final_speed)?;
        res.set_validity_final_speed(validity_final_speed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Final_Speed
    ///
    /// Speed at end of triggered test
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn final_speed(&self) -> f32 {
        self.final_speed_raw()
    }
    
    /// Get raw value of Final_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn final_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Final_Speed
    #[inline(always)]
    pub fn set_final_speed(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigFinalCondition::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_Final_Speed
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_final_speed(&self) -> bool {
        self.validity_final_speed_raw()
    }
    
    /// Get raw value of Validity_Final_Speed
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_final_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Final_Speed
    #[inline(always)]
    pub fn set_validity_final_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigFinalCondition {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigFinalCondition {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Initial_Condition
///
/// - Extended ID: 156725794 (0x9577222)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigInitialCondition {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigInitialCondition {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9577222)});
    
    pub const MFDD_END_THRESHOLD_MIN: u8 = 0_u8;
    pub const MFDD_END_THRESHOLD_MAX: u8 = 100_u8;
    pub const MFDD_START_THRESHOLD_MIN: u8 = 0_u8;
    pub const MFDD_START_THRESHOLD_MAX: u8 = 100_u8;
    pub const INITIAL_HEADING_MIN: f32 = -180_f32;
    pub const INITIAL_HEADING_MAX: f32 = 180_f32;
    pub const INITIAL_SPEED_MIN: f32 = 0_f32;
    pub const INITIAL_SPEED_MAX: f32 = 1675_f32;
    
    /// Construct new RT_SB_Trig_Initial_Condition from values
    pub fn new(mfdd_end_threshold: u8, mfdd_start_threshold: u8, initial_heading: f32, initial_speed: f32, validity_initial_heading: bool, validity_initial_speed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_mfdd_end_threshold(mfdd_end_threshold)?;
        res.set_mfdd_start_threshold(mfdd_start_threshold)?;
        res.set_initial_heading(initial_heading)?;
        res.set_initial_speed(initial_speed)?;
        res.set_validity_initial_heading(validity_initial_heading)?;
        res.set_validity_initial_speed(validity_initial_speed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// MFDD_End_Threshold
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn mfdd_end_threshold(&self) -> u8 {
        self.mfdd_end_threshold_raw()
    }
    
    /// Get raw value of MFDD_End_Threshold
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn mfdd_end_threshold_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of MFDD_End_Threshold
    #[inline(always)]
    pub fn set_mfdd_end_threshold(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
    /// MFDD_Start_Threshold
    ///
    /// - Min: 0
    /// - Max: 100
    /// - Unit: "%"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn mfdd_start_threshold(&self) -> u8 {
        self.mfdd_start_threshold_raw()
    }
    
    /// Get raw value of MFDD_Start_Threshold
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn mfdd_start_threshold_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of MFDD_Start_Threshold
    #[inline(always)]
    pub fn set_mfdd_start_threshold(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 100_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// Initial_Heading
    ///
    /// Heading (track) at start of triggered test
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn initial_heading(&self) -> f32 {
        self.initial_heading_raw()
    }
    
    /// Get raw value of Initial_Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn initial_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Initial_Heading
    #[inline(always)]
    pub fn set_initial_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Initial_Speed
    ///
    /// Speed at start of triggered test
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn initial_speed(&self) -> f32 {
        self.initial_speed_raw()
    }
    
    /// Get raw value of Initial_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn initial_speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Initial_Speed
    #[inline(always)]
    pub fn set_initial_speed(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigInitialCondition::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_Initial_Heading
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_initial_heading(&self) -> bool {
        self.validity_initial_heading_raw()
    }
    
    /// Get raw value of Validity_Initial_Heading
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_initial_heading_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Initial_Heading
    #[inline(always)]
    pub fn set_validity_initial_heading(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Initial_Speed
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_initial_speed(&self) -> bool {
        self.validity_initial_speed_raw()
    }
    
    /// Get raw value of Validity_Initial_Speed
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_initial_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Initial_Speed
    #[inline(always)]
    pub fn set_validity_initial_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigInitialCondition {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigInitialCondition {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Direct_Dist
///
/// - Extended ID: 156725538 (0x9577122)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigDirectDist {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigDirectDist {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9577122)});
    
    pub const PATH_DISTANCE_2D_MIN: f32 = 0_f32;
    pub const PATH_DISTANCE_2D_MAX: f32 = 4294967_f32;
    pub const DIRECT_DISTANCE_MIN: f32 = 0_f32;
    pub const DIRECT_DISTANCE_MAX: f32 = 4294967_f32;
    
    /// Construct new RT_SB_Trig_Direct_Dist from values
    pub fn new(path_distance_2d: f32, direct_distance: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_path_distance_2d(path_distance_2d)?;
        res.set_direct_distance(direct_distance)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Path_Distance_2D
    ///
    /// 2D path distance (horizontal components only)
    ///
    /// - Min: 0
    /// - Max: 4294967
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn path_distance_2d(&self) -> f32 {
        self.path_distance_2d_raw()
    }
    
    /// Get raw value of Path_Distance_2D
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn path_distance_2d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Path_Distance_2D
    #[inline(always)]
    pub fn set_path_distance_2d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 4294967_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigDirectDist::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Direct_Distance
    ///
    /// Direct distance from start of test to current position
    ///
    /// - Min: 0
    /// - Max: 4294967
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn direct_distance(&self) -> f32 {
        self.direct_distance_raw()
    }
    
    /// Get raw value of Direct_Distance
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn direct_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Direct_Distance
    #[inline(always)]
    pub fn set_direct_distance(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 4294967_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigDirectDist::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigDirectDist {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigDirectDist {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Forward_Dist
///
/// - Extended ID: 156725282 (0x9577022)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigForwardDist {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigForwardDist {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9577022)});
    
    pub const DEVIATION_DISTANCE_MIN: f32 = -2147483.648_f32;
    pub const DEVIATION_DISTANCE_MAX: f32 = 2147483.647_f32;
    pub const FORWARD_DISTANCE_MIN: f32 = -2147483.648_f32;
    pub const FORWARD_DISTANCE_MAX: f32 = 2147483.647_f32;
    
    /// Construct new RT_SB_Trig_Forward_Dist from values
    pub fn new(deviation_distance: f32, forward_distance: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_deviation_distance(deviation_distance)?;
        res.set_forward_distance(forward_distance)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Deviation_Distance
    ///
    /// Current deviation distance from a line projected along the initial heading at start of test, +ve for deviation to the right.
    ///
    /// - Min: -2147483.648
    /// - Max: 2147483.647
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn deviation_distance(&self) -> f32 {
        self.deviation_distance_raw()
    }
    
    /// Get raw value of Deviation_Distance
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn deviation_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Deviation_Distance
    #[inline(always)]
    pub fn set_deviation_distance(&mut self, value: f32) -> Result<(), CanError> {
        if value < -2147483.648_f32 || 2147483.647_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigForwardDist::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Forward_Distance
    ///
    /// Current forward distance from start of test in direction of initial heading at start of test
    ///
    /// - Min: -2147483.648
    /// - Max: 2147483.647
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn forward_distance(&self) -> f32 {
        self.forward_distance_raw()
    }
    
    /// Get raw value of Forward_Distance
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn forward_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Forward_Distance
    #[inline(always)]
    pub fn set_forward_distance(&mut self, value: f32) -> Result<(), CanError> {
        if value < -2147483.648_f32 || 2147483.647_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigForwardDist::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigForwardDist {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigForwardDist {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Path_Dist
///
/// - Extended ID: 156725026 (0x9576f22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigPathDist {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigPathDist {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9576f22)});
    
    pub const PATH_DISTANCE_3D_MIN: f32 = 0_f32;
    pub const PATH_DISTANCE_3D_MAX: f32 = 4294967_f32;
    
    /// Construct new RT_SB_Trig_Path_Dist from values
    pub fn new(path_distance_3d: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_path_distance_3d(path_distance_3d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Path_Distance_3D
    ///
    /// 3D path distance
    ///
    /// - Min: 0
    /// - Max: 4294967
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn path_distance_3d(&self) -> f32 {
        self.path_distance_3d_raw()
    }
    
    /// Get raw value of Path_Distance_3D
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn path_distance_3d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Path_Distance_3D
    #[inline(always)]
    pub fn set_path_distance_3d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 4294967_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigPathDist::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigPathDist {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigPathDist {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trig_Accel
///
/// - Extended ID: 156724770 (0x9576e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTrigAccel {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTrigAccel {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9576e22)});
    
    pub const TRIGGERED_TIME_MIN: f32 = 0_f32;
    pub const TRIGGERED_TIME_MAX: f32 = 167772_f32;
    pub const AVERAGE_ACCEL_MIN: f32 = -65_f32;
    pub const AVERAGE_ACCEL_MAX: f32 = 65_f32;
    pub const MFDD_MIN: f32 = -65_f32;
    pub const MFDD_MAX: f32 = 65_f32;
    
    /// Construct new RT_SB_Trig_Accel from values
    pub fn new(triggered_time: f32, average_accel: f32, mfdd: f32, validity_triggered_time: bool, validity_average_accel: bool, validity_mfdd: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_triggered_time(triggered_time)?;
        res.set_average_accel(average_accel)?;
        res.set_mfdd(mfdd)?;
        res.set_validity_triggered_time(validity_triggered_time)?;
        res.set_validity_average_accel(validity_average_accel)?;
        res.set_validity_mfdd(validity_mfdd)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Triggered_Time
    ///
    /// Cumulative time from start of triggered test to current time.
    ///
    /// - Min: 0
    /// - Max: 167772
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn triggered_time(&self) -> f32 {
        self.triggered_time_raw()
    }
    
    /// Get raw value of Triggered_Time
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn triggered_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<u32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Triggered_Time
    #[inline(always)]
    pub fn set_triggered_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 167772_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigAccel::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// Average_Accel
    ///
    /// Average acceleration from start of triggered test to current time.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn average_accel(&self) -> f32 {
        self.average_accel_raw()
    }
    
    /// Get raw value of Average_Accel
    ///
    /// - Start bit: 24
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn average_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..40].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Average_Accel
    #[inline(always)]
    pub fn set_average_accel(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigAccel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[24..40].store_le(value);
        Ok(())
    }
    
    /// MFDD
    ///
    /// Mean fully-developed decelleration of triggered test.  Thresholds used are as set in the logger configuration.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn mfdd(&self) -> f32 {
        self.mfdd_raw()
    }
    
    /// Get raw value of MFDD
    ///
    /// - Start bit: 8
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn mfdd_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..24].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of MFDD
    #[inline(always)]
    pub fn set_mfdd(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTrigAccel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[8..24].store_le(value);
        Ok(())
    }
    
    /// Validity_Triggered_Time
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_triggered_time(&self) -> bool {
        self.validity_triggered_time_raw()
    }
    
    /// Get raw value of Validity_Triggered_Time
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_triggered_time_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Triggered_Time
    #[inline(always)]
    pub fn set_validity_triggered_time(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Average_Accel
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_average_accel(&self) -> bool {
        self.validity_average_accel_raw()
    }
    
    /// Get raw value of Validity_Average_Accel
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_average_accel_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Average_Accel
    #[inline(always)]
    pub fn set_validity_average_accel(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_MFDD
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_mfdd(&self) -> bool {
        self.validity_mfdd_raw()
    }
    
    /// Get raw value of Validity_MFDD
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_mfdd_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_MFDD
    #[inline(always)]
    pub fn set_validity_mfdd(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTrigAccel {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTrigAccel {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_12
///
/// - Extended ID: 157317156 (0x9607824)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime12 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime12 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607824)});
    
    pub const MEASURED_TIME_12_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_12_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_12 from values
    pub fn new(measured_time_12: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_12(measured_time_12)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_12(&self) -> u32 {
        self.measured_time_12_raw()
    }
    
    /// Get raw value of Measured_Time_12
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_12_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_12
    #[inline(always)]
    pub fn set_measured_time_12(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime12::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime12::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime12 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_11
///
/// - Extended ID: 157316900 (0x9607724)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime11 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime11 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607724)});
    
    pub const MEASURED_TIME_11_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_11_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_11 from values
    pub fn new(measured_time_11: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_11(measured_time_11)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_11(&self) -> u32 {
        self.measured_time_11_raw()
    }
    
    /// Get raw value of Measured_Time_11
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_11_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_11
    #[inline(always)]
    pub fn set_measured_time_11(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime11::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime11::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime11 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_10
///
/// - Extended ID: 157316644 (0x9607624)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime10 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime10 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607624)});
    
    pub const MEASURED_TIME_10_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_10_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_10 from values
    pub fn new(measured_time_10: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_10(measured_time_10)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_10(&self) -> u32 {
        self.measured_time_10_raw()
    }
    
    /// Get raw value of Measured_Time_10
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_10_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_10
    #[inline(always)]
    pub fn set_measured_time_10(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime10::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime10::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime10 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_9
///
/// - Extended ID: 157316388 (0x9607524)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime9 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime9 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607524)});
    
    pub const MEASURED_TIME_9_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_9_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_9 from values
    pub fn new(measured_time_9: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_9(measured_time_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_9(&self) -> u32 {
        self.measured_time_9_raw()
    }
    
    /// Get raw value of Measured_Time_9
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_9_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_9
    #[inline(always)]
    pub fn set_measured_time_9(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime9::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime9::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime9 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime9 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_8
///
/// - Extended ID: 157316132 (0x9607424)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime8 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime8 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607424)});
    
    pub const MEASURED_TIME_8_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_8_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_8 from values
    pub fn new(measured_time_8: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_8(measured_time_8)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_8(&self) -> u32 {
        self.measured_time_8_raw()
    }
    
    /// Get raw value of Measured_Time_8
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_8_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_8
    #[inline(always)]
    pub fn set_measured_time_8(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime8::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime8::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime8 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime8 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_7
///
/// - Extended ID: 157315876 (0x9607324)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime7 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime7 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607324)});
    
    pub const MEASURED_TIME_7_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_7_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_7 from values
    pub fn new(measured_time_7: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_7(measured_time_7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_7(&self) -> u32 {
        self.measured_time_7_raw()
    }
    
    /// Get raw value of Measured_Time_7
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_7_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_7
    #[inline(always)]
    pub fn set_measured_time_7(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime7::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime7::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime7 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_6
///
/// - Extended ID: 157315620 (0x9607224)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime6 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime6 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607224)});
    
    pub const MEASURED_TIME_6_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_6_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_6 from values
    pub fn new(measured_time_6: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_6(measured_time_6)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_6(&self) -> u32 {
        self.measured_time_6_raw()
    }
    
    /// Get raw value of Measured_Time_6
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_6_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_6
    #[inline(always)]
    pub fn set_measured_time_6(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime6::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime6::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime6 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_5
///
/// - Extended ID: 157315364 (0x9607124)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime5 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607124)});
    
    pub const MEASURED_TIME_5_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_5_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_5 from values
    pub fn new(measured_time_5: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_5(measured_time_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_5(&self) -> u32 {
        self.measured_time_5_raw()
    }
    
    /// Get raw value of Measured_Time_5
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_5_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_5
    #[inline(always)]
    pub fn set_measured_time_5(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime5::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime5::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_4
///
/// - Extended ID: 157315108 (0x9607024)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime4 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9607024)});
    
    pub const MEASURED_TIME_4_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_4_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_4 from values
    pub fn new(measured_time_4: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_4(measured_time_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_4(&self) -> u32 {
        self.measured_time_4_raw()
    }
    
    /// Get raw value of Measured_Time_4
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_4_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_4
    #[inline(always)]
    pub fn set_measured_time_4(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime4::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime4::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_3
///
/// - Extended ID: 157314852 (0x9606f24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime3 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9606f24)});
    
    pub const MEASURED_TIME_3_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_3_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_3 from values
    pub fn new(measured_time_3: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_3(measured_time_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_3(&self) -> u32 {
        self.measured_time_3_raw()
    }
    
    /// Get raw value of Measured_Time_3
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_3_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_3
    #[inline(always)]
    pub fn set_measured_time_3(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime3::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime3::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_2
///
/// - Extended ID: 157314596 (0x9606e24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime2 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9606e24)});
    
    pub const MEASURED_TIME_2_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_2_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_2 from values
    pub fn new(measured_time_2: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_2(measured_time_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_2(&self) -> u32 {
        self.measured_time_2_raw()
    }
    
    /// Get raw value of Measured_Time_2
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_2_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_2
    #[inline(always)]
    pub fn set_measured_time_2(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime2::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Measure_Time_1
///
/// - Extended ID: 157314340 (0x9606d24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3MeasureTime1 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3MeasureTime1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9606d24)});
    
    pub const MEASURED_TIME_1_MIN: u32 = 0_u32;
    pub const MEASURED_TIME_1_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Measure_Time_1 from values
    pub fn new(measured_time_1: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_measured_time_1(measured_time_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Measured_Time_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn measured_time_1(&self) -> u32 {
        self.measured_time_1_raw()
    }
    
    /// Get raw value of Measured_Time_1
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn measured_time_1_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 1;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Measured_Time_1
    #[inline(always)]
    pub fn set_measured_time_1(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3MeasureTime1::MESSAGE_ID })?;
        let value = (value / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3MeasureTime1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3MeasureTime1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_RPM
///
/// - Extended ID: 157251620 (0x95f7824)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Rpm {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Rpm {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95f7824)});
    
    pub const RPM_MIN: u16 = 0_u16;
    pub const RPM_MAX: u16 = 0_u16;
    
    /// Construct new RT_DL1MK3_RPM from values
    pub fn new(rpm: u16) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_rpm(rpm)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// RPM
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rpm(&self) -> u16 {
        self.rpm_raw()
    }
    
    /// Get raw value of RPM
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rpm_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 1;
        u16::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of RPM
    #[inline(always)]
    pub fn set_rpm(&mut self, value: u16) -> Result<(), CanError> {
        if value < 0_u16 || 0_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Rpm::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3Rpm::MESSAGE_ID })?;
        let value = (value / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Rpm {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Rpm {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Freq_4
///
/// - Extended ID: 157251364 (0x95f7724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Freq4 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Freq4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95f7724)});
    
    pub const FREQUENCY_4_MIN: f32 = 0_f32;
    pub const FREQUENCY_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Freq_4 from values
    pub fn new(frequency_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_frequency_4(frequency_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Frequency_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn frequency_4(&self) -> f32 {
        self.frequency_4_raw()
    }
    
    /// Get raw value of Frequency_4
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn frequency_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Frequency_4
    #[inline(always)]
    pub fn set_frequency_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Freq4::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Freq4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Freq4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Freq_3
///
/// - Extended ID: 157251108 (0x95f7624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Freq3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Freq3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95f7624)});
    
    pub const FREQUENCY_3_MIN: f32 = 0_f32;
    pub const FREQUENCY_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Freq_3 from values
    pub fn new(frequency_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_frequency_3(frequency_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Frequency_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn frequency_3(&self) -> f32 {
        self.frequency_3_raw()
    }
    
    /// Get raw value of Frequency_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn frequency_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Frequency_3
    #[inline(always)]
    pub fn set_frequency_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Freq3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Freq3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Freq3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Freq_2
///
/// - Extended ID: 157250852 (0x95f7524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Freq2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Freq2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95f7524)});
    
    pub const FREQUENCY_2_MIN: f32 = 0_f32;
    pub const FREQUENCY_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Freq_2 from values
    pub fn new(frequency_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_frequency_2(frequency_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Frequency_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn frequency_2(&self) -> f32 {
        self.frequency_2_raw()
    }
    
    /// Get raw value of Frequency_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn frequency_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Frequency_2
    #[inline(always)]
    pub fn set_frequency_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Freq2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Freq2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Freq2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Misc_3
///
/// - Extended ID: 157380388 (0x9616f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Misc3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Misc3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9616f24)});
    
    pub const MISC_3_MIN: f32 = 0_f32;
    pub const MISC_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Misc_3 from values
    pub fn new(misc_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_misc_3(misc_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Misc_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn misc_3(&self) -> f32 {
        self.misc_3_raw()
    }
    
    /// Get raw value of Misc_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn misc_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Misc_3
    #[inline(always)]
    pub fn set_misc_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Misc3::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Misc3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Misc3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Misc_2
///
/// - Extended ID: 157380132 (0x9616e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Misc2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Misc2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9616e24)});
    
    pub const MISC_2_MIN: f32 = 0_f32;
    pub const MISC_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Misc_2 from values
    pub fn new(misc_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_misc_2(misc_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Misc_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn misc_2(&self) -> f32 {
        self.misc_2_raw()
    }
    
    /// Get raw value of Misc_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn misc_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Misc_2
    #[inline(always)]
    pub fn set_misc_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Misc2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Misc2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Misc2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Misc_1
///
/// - Extended ID: 157379876 (0x9616d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Misc1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Misc1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9616d24)});
    
    pub const MISC_1_MIN: f32 = 0_f32;
    pub const MISC_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Misc_1 from values
    pub fn new(misc_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_misc_1(misc_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Misc_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn misc_1(&self) -> f32 {
        self.misc_1_raw()
    }
    
    /// Get raw value of Misc_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn misc_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Misc_1
    #[inline(always)]
    pub fn set_misc_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Misc1::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Misc1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Misc1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_31
///
/// - Extended ID: 157190948 (0x95e8b24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux31 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux31 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8b24)});
    
    pub const AUX_31_MIN: f32 = 0_f32;
    pub const AUX_31_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_31 from values
    pub fn new(aux_31: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_31(aux_31)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_31
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_31(&self) -> f32 {
        self.aux_31_raw()
    }
    
    /// Get raw value of AUX_31
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_31_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_31
    #[inline(always)]
    pub fn set_aux_31(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux31::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux31 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux31 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_30
///
/// - Extended ID: 157190692 (0x95e8a24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux30 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux30 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8a24)});
    
    pub const AUX_30_MIN: f32 = 0_f32;
    pub const AUX_30_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_30 from values
    pub fn new(aux_30: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_30(aux_30)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_30
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_30(&self) -> f32 {
        self.aux_30_raw()
    }
    
    /// Get raw value of AUX_30
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_30_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_30
    #[inline(always)]
    pub fn set_aux_30(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux30::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux30 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux30 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_29
///
/// - Extended ID: 157190436 (0x95e8924)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux29 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux29 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8924)});
    
    pub const AUX_29_MIN: f32 = 0_f32;
    pub const AUX_29_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_29 from values
    pub fn new(aux_29: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_29(aux_29)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_29
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_29(&self) -> f32 {
        self.aux_29_raw()
    }
    
    /// Get raw value of AUX_29
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_29_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_29
    #[inline(always)]
    pub fn set_aux_29(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux29::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux29 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux29 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_28
///
/// - Extended ID: 157190180 (0x95e8824)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux28 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux28 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8824)});
    
    pub const AUX_28_MIN: f32 = 0_f32;
    pub const AUX_28_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_28 from values
    pub fn new(aux_28: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_28(aux_28)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_28
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_28(&self) -> f32 {
        self.aux_28_raw()
    }
    
    /// Get raw value of AUX_28
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_28_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_28
    #[inline(always)]
    pub fn set_aux_28(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux28::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux28 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux28 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_27
///
/// - Extended ID: 157189924 (0x95e8724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux27 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux27 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8724)});
    
    pub const AUX_27_MIN: f32 = 0_f32;
    pub const AUX_27_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_27 from values
    pub fn new(aux_27: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_27(aux_27)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_27
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_27(&self) -> f32 {
        self.aux_27_raw()
    }
    
    /// Get raw value of AUX_27
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_27_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_27
    #[inline(always)]
    pub fn set_aux_27(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux27::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux27 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux27 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_26
///
/// - Extended ID: 157189668 (0x95e8624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux26 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux26 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8624)});
    
    pub const AUX_26_MIN: f32 = 0_f32;
    pub const AUX_26_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_26 from values
    pub fn new(aux_26: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_26(aux_26)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_26
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_26(&self) -> f32 {
        self.aux_26_raw()
    }
    
    /// Get raw value of AUX_26
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_26_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_26
    #[inline(always)]
    pub fn set_aux_26(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux26::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux26 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux26 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_25
///
/// - Extended ID: 157189412 (0x95e8524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux25 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux25 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8524)});
    
    pub const AUX_25_MIN: f32 = 0_f32;
    pub const AUX_25_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_25 from values
    pub fn new(aux_25: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_25(aux_25)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_25
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_25(&self) -> f32 {
        self.aux_25_raw()
    }
    
    /// Get raw value of AUX_25
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_25_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_25
    #[inline(always)]
    pub fn set_aux_25(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux25::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux25 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux25 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_24
///
/// - Extended ID: 157189156 (0x95e8424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux24 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux24 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8424)});
    
    pub const AUX_24_MIN: f32 = 0_f32;
    pub const AUX_24_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_24 from values
    pub fn new(aux_24: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_24(aux_24)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_24
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_24(&self) -> f32 {
        self.aux_24_raw()
    }
    
    /// Get raw value of AUX_24
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_24_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_24
    #[inline(always)]
    pub fn set_aux_24(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux24::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux24 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux24 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_23
///
/// - Extended ID: 157188900 (0x95e8324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux23 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux23 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8324)});
    
    pub const AUX_23_MIN: f32 = 0_f32;
    pub const AUX_23_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_23 from values
    pub fn new(aux_23: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_23(aux_23)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_23
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_23(&self) -> f32 {
        self.aux_23_raw()
    }
    
    /// Get raw value of AUX_23
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_23_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_23
    #[inline(always)]
    pub fn set_aux_23(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux23::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux23 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux23 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_22
///
/// - Extended ID: 157188644 (0x95e8224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux22 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux22 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8224)});
    
    pub const AUX_22_MIN: u32 = 0_u32;
    pub const AUX_22_MAX: u32 = 0_u32;
    
    /// Construct new RT_DL1MK3_Aux_22 from values
    pub fn new(aux_22: u32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_22(aux_22)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_22
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_22(&self) -> u32 {
        self.aux_22_raw()
    }
    
    /// Get raw value of AUX_22
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 10
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_22_raw(&self) -> u32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 10;
        u32::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of AUX_22
    #[inline(always)]
    pub fn set_aux_22(&mut self, value: u32) -> Result<(), CanError> {
        if value < 0_u32 || 0_u32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux22::MESSAGE_ID });
        }
        let factor = 10;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux22::MESSAGE_ID })?;
        let value = (value / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux22 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux22 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_21
///
/// - Extended ID: 157188388 (0x95e8124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux21 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux21 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8124)});
    
    pub const AUX_21_MIN: f32 = 0_f32;
    pub const AUX_21_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_21 from values
    pub fn new(aux_21: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_21(aux_21)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_21
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_21(&self) -> f32 {
        self.aux_21_raw()
    }
    
    /// Get raw value of AUX_21
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_21_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_21
    #[inline(always)]
    pub fn set_aux_21(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux21::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux21 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux21 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_20
///
/// - Extended ID: 157188132 (0x95e8024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux20 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux20 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e8024)});
    
    pub const AUX_20_MIN: f32 = 0_f32;
    pub const AUX_20_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_20 from values
    pub fn new(aux_20: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_20(aux_20)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_20
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_20(&self) -> f32 {
        self.aux_20_raw()
    }
    
    /// Get raw value of AUX_20
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_20_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_20
    #[inline(always)]
    pub fn set_aux_20(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux20::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux20 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux20 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_19
///
/// - Extended ID: 157187876 (0x95e7f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux19 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux19 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7f24)});
    
    pub const AUX_19_MIN: f32 = 0_f32;
    pub const AUX_19_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_19 from values
    pub fn new(aux_19: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_19(aux_19)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_19
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_19(&self) -> f32 {
        self.aux_19_raw()
    }
    
    /// Get raw value of AUX_19
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_19_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_19
    #[inline(always)]
    pub fn set_aux_19(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux19::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux19 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux19 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_18
///
/// - Extended ID: 157187620 (0x95e7e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux18 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux18 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7e24)});
    
    pub const AUX_18_MIN: f32 = 0_f32;
    pub const AUX_18_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_18 from values
    pub fn new(aux_18: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_18(aux_18)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_18
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_18(&self) -> f32 {
        self.aux_18_raw()
    }
    
    /// Get raw value of AUX_18
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_18_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_18
    #[inline(always)]
    pub fn set_aux_18(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux18::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux18 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux18 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_17
///
/// - Extended ID: 157187364 (0x95e7d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux17 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux17 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7d24)});
    
    pub const AUX_17_MIN: f32 = 0_f32;
    pub const AUX_17_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_17 from values
    pub fn new(aux_17: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_17(aux_17)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_17
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_17(&self) -> f32 {
        self.aux_17_raw()
    }
    
    /// Get raw value of AUX_17
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_17_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_17
    #[inline(always)]
    pub fn set_aux_17(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux17::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux17 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux17 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_16
///
/// - Extended ID: 157187108 (0x95e7c24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux16 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux16 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7c24)});
    
    pub const AUX_16_MIN: f32 = 0_f32;
    pub const AUX_16_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_16 from values
    pub fn new(aux_16: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_16(aux_16)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_16
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_16(&self) -> f32 {
        self.aux_16_raw()
    }
    
    /// Get raw value of AUX_16
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_16_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_16
    #[inline(always)]
    pub fn set_aux_16(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux16::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux16 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_15
///
/// - Extended ID: 157186852 (0x95e7b24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux15 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux15 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7b24)});
    
    pub const AUX_15_MIN: f32 = 0_f32;
    pub const AUX_15_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_15 from values
    pub fn new(aux_15: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_15(aux_15)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_15
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_15(&self) -> f32 {
        self.aux_15_raw()
    }
    
    /// Get raw value of AUX_15
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_15_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_15
    #[inline(always)]
    pub fn set_aux_15(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux15::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux15 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_14
///
/// - Extended ID: 157186596 (0x95e7a24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux14 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux14 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7a24)});
    
    pub const AUX_14_MIN: f32 = 0_f32;
    pub const AUX_14_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_14 from values
    pub fn new(aux_14: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_14(aux_14)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_14
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_14(&self) -> f32 {
        self.aux_14_raw()
    }
    
    /// Get raw value of AUX_14
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_14_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_14
    #[inline(always)]
    pub fn set_aux_14(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux14::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux14 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_13
///
/// - Extended ID: 157186340 (0x95e7924)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux13 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux13 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7924)});
    
    pub const AUX_13_MIN: f32 = 0_f32;
    pub const AUX_13_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_13 from values
    pub fn new(aux_13: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_13(aux_13)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_13
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_13(&self) -> f32 {
        self.aux_13_raw()
    }
    
    /// Get raw value of AUX_13
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_13_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_13
    #[inline(always)]
    pub fn set_aux_13(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux13::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux13 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_12
///
/// - Extended ID: 157186084 (0x95e7824)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux12 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux12 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7824)});
    
    pub const AUX_12_MIN: f32 = 0_f32;
    pub const AUX_12_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_12 from values
    pub fn new(aux_12: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_12(aux_12)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_12(&self) -> f32 {
        self.aux_12_raw()
    }
    
    /// Get raw value of AUX_12
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_12_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_12
    #[inline(always)]
    pub fn set_aux_12(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux12::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux12 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_11
///
/// - Extended ID: 157185828 (0x95e7724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux11 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux11 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7724)});
    
    pub const AUX_11_MIN: f32 = 0_f32;
    pub const AUX_11_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_11 from values
    pub fn new(aux_11: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_11(aux_11)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_11(&self) -> f32 {
        self.aux_11_raw()
    }
    
    /// Get raw value of AUX_11
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_11_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_11
    #[inline(always)]
    pub fn set_aux_11(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux11::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux11 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_9
///
/// - Extended ID: 157185316 (0x95e7524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux9 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux9 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7524)});
    
    pub const AUX_9_MIN: f32 = 0_f32;
    pub const AUX_9_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_9 from values
    pub fn new(aux_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_9(aux_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_9(&self) -> f32 {
        self.aux_9_raw()
    }
    
    /// Get raw value of AUX_9
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_9
    #[inline(always)]
    pub fn set_aux_9(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux9::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux9 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux9 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_10
///
/// - Extended ID: 157185572 (0x95e7624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux10 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux10 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7624)});
    
    pub const AUX_10_MIN: f32 = 0_f32;
    pub const AUX_10_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_10 from values
    pub fn new(aux_10: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_10(aux_10)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_10(&self) -> f32 {
        self.aux_10_raw()
    }
    
    /// Get raw value of AUX_10
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_10_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_10
    #[inline(always)]
    pub fn set_aux_10(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux10::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux10 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_8
///
/// - Extended ID: 157185060 (0x95e7424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux8 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux8 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7424)});
    
    pub const AUX_8_MIN: f32 = 0_f32;
    pub const AUX_8_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_8 from values
    pub fn new(aux_8: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_8(aux_8)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_8(&self) -> f32 {
        self.aux_8_raw()
    }
    
    /// Get raw value of AUX_8
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_8_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_8
    #[inline(always)]
    pub fn set_aux_8(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux8::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux8 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux8 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_7
///
/// - Extended ID: 157184804 (0x95e7324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux7 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux7 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7324)});
    
    pub const AUX_7_MIN: f32 = 0_f32;
    pub const AUX_7_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_7 from values
    pub fn new(aux_7: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_7(aux_7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_7(&self) -> f32 {
        self.aux_7_raw()
    }
    
    /// Get raw value of AUX_7
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_7_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_7
    #[inline(always)]
    pub fn set_aux_7(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux7::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux7 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_6
///
/// - Extended ID: 157184548 (0x95e7224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux6 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux6 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7224)});
    
    pub const AUX_6_MIN: f32 = 0_f32;
    pub const AUX_6_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_6 from values
    pub fn new(aux_6: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_6(aux_6)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_6(&self) -> f32 {
        self.aux_6_raw()
    }
    
    /// Get raw value of AUX_6
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_6_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_6
    #[inline(always)]
    pub fn set_aux_6(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux6::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux6 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_5
///
/// - Extended ID: 157184292 (0x95e7124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux5 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7124)});
    
    pub const AUX_5_MIN: f32 = 0_f32;
    pub const AUX_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_5 from values
    pub fn new(aux_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_5(aux_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_5(&self) -> f32 {
        self.aux_5_raw()
    }
    
    /// Get raw value of AUX_5
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_5
    #[inline(always)]
    pub fn set_aux_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux5::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_4
///
/// - Extended ID: 157184036 (0x95e7024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux4 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e7024)});
    
    pub const AUX_4_MIN: f32 = 0_f32;
    pub const AUX_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_4 from values
    pub fn new(aux_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_4(aux_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_4(&self) -> f32 {
        self.aux_4_raw()
    }
    
    /// Get raw value of AUX_4
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_4
    #[inline(always)]
    pub fn set_aux_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux4::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_3
///
/// - Extended ID: 157183780 (0x95e6f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e6f24)});
    
    pub const AUX_3_MIN: f32 = 0_f32;
    pub const AUX_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_3 from values
    pub fn new(aux_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_3(aux_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_3(&self) -> f32 {
        self.aux_3_raw()
    }
    
    /// Get raw value of AUX_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_3
    #[inline(always)]
    pub fn set_aux_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_2
///
/// - Extended ID: 157183524 (0x95e6e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e6e24)});
    
    pub const AUX_2_MIN: f32 = 0_f32;
    pub const AUX_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_2 from values
    pub fn new(aux_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_2(aux_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_2(&self) -> f32 {
        self.aux_2_raw()
    }
    
    /// Get raw value of AUX_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_2
    #[inline(always)]
    pub fn set_aux_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Aux_1
///
/// - Extended ID: 157183268 (0x95e6d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Aux1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Aux1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95e6d24)});
    
    pub const AUX_1_MIN: f32 = 0_f32;
    pub const AUX_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Aux_1 from values
    pub fn new(aux_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_aux_1(aux_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// AUX_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn aux_1(&self) -> f32 {
        self.aux_1_raw()
    }
    
    /// Get raw value of AUX_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn aux_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<u16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of AUX_1
    #[inline(always)]
    pub fn set_aux_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Aux1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Aux1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Aux1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Pressure_5
///
/// - Extended ID: 156922148 (0x95a7124)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Pressure5 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Pressure5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95a7124)});
    
    pub const PRESSURE_5_MIN: f32 = 0_f32;
    pub const PRESSURE_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Pressure_5 from values
    pub fn new(pressure_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_pressure_5(pressure_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Pressure_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pressure_5(&self) -> f32 {
        self.pressure_5_raw()
    }
    
    /// Get raw value of Pressure_5
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Pressure_5
    #[inline(always)]
    pub fn set_pressure_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Pressure5::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Pressure5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Pressure5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Pressure_4
///
/// - Extended ID: 156921892 (0x95a7024)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Pressure4 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Pressure4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95a7024)});
    
    pub const PRESSURE_4_MIN: f32 = 0_f32;
    pub const PRESSURE_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Pressure_4 from values
    pub fn new(pressure_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_pressure_4(pressure_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Pressure_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pressure_4(&self) -> f32 {
        self.pressure_4_raw()
    }
    
    /// Get raw value of Pressure_4
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Pressure_4
    #[inline(always)]
    pub fn set_pressure_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Pressure4::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Pressure4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Pressure4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Pressure_3
///
/// - Extended ID: 156921636 (0x95a6f24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Pressure3 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Pressure3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95a6f24)});
    
    pub const PRESSURE_3_MIN: f32 = 0_f32;
    pub const PRESSURE_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Pressure_3 from values
    pub fn new(pressure_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_pressure_3(pressure_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Pressure_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pressure_3(&self) -> f32 {
        self.pressure_3_raw()
    }
    
    /// Get raw value of Pressure_3
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Pressure_3
    #[inline(always)]
    pub fn set_pressure_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Pressure3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Pressure3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Pressure3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Pressure_2
///
/// - Extended ID: 156921380 (0x95a6e24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Pressure2 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Pressure2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95a6e24)});
    
    pub const PRESSURE_2_MIN: f32 = 0_f32;
    pub const PRESSURE_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Pressure_2 from values
    pub fn new(pressure_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_pressure_2(pressure_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Pressure_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pressure_2(&self) -> f32 {
        self.pressure_2_raw()
    }
    
    /// Get raw value of Pressure_2
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Pressure_2
    #[inline(always)]
    pub fn set_pressure_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Pressure2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Pressure2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Pressure2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Pressure_1
///
/// - Extended ID: 156921124 (0x95a6d24)
/// - Size: 3 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Pressure1 {
    raw: [u8; 3],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Pressure1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95a6d24)});
    
    pub const PRESSURE_1_MIN: f32 = 0_f32;
    pub const PRESSURE_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Pressure_1 from values
    pub fn new(pressure_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 3] };
        res.set_pressure_1(pressure_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 3] {
        &self.raw
    }
    
    /// Pressure_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn pressure_1(&self) -> f32 {
        self.pressure_1_raw()
    }
    
    /// Get raw value of Pressure_1
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn pressure_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<u32>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Pressure_1
    #[inline(always)]
    pub fn set_pressure_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Pressure1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Pressure1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 3 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 3];
        raw.copy_from_slice(&payload[..3]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Pressure1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Angle_3
///
/// - Extended ID: 157052708 (0x95c6f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Angle3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Angle3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95c6f24)});
    
    pub const ANGLE_3_MIN: f32 = 0_f32;
    pub const ANGLE_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Angle_3 from values
    pub fn new(angle_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_angle_3(angle_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Angle_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn angle_3(&self) -> f32 {
        self.angle_3_raw()
    }
    
    /// Get raw value of Angle_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn angle_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Angle_3
    #[inline(always)]
    pub fn set_angle_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Angle3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Angle3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Angle3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Angle_2
///
/// - Extended ID: 157052452 (0x95c6e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Angle2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Angle2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95c6e24)});
    
    pub const ANGLE_2_MIN: f32 = 0_f32;
    pub const ANGLE_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Angle_2 from values
    pub fn new(angle_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_angle_2(angle_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Angle_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn angle_2(&self) -> f32 {
        self.angle_2_raw()
    }
    
    /// Get raw value of Angle_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn angle_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Angle_2
    #[inline(always)]
    pub fn set_angle_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Angle2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Angle2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Angle2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Angle_1
///
/// - Extended ID: 157052196 (0x95c6d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Angle1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Angle1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95c6d24)});
    
    pub const ANGLE_1_MIN: f32 = 0_f32;
    pub const ANGLE_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Angle_1 from values
    pub fn new(angle_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_angle_1(angle_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Angle_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn angle_1(&self) -> f32 {
        self.angle_1_raw()
    }
    
    /// Get raw value of Angle_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn angle_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Angle_1
    #[inline(always)]
    pub fn set_angle_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Angle1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Angle1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Angle1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_25
///
/// - Extended ID: 156992804 (0x95b8524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp25 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp25 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8524)});
    
    pub const TEMPERATURE_25_MIN: f32 = 0_f32;
    pub const TEMPERATURE_25_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_25 from values
    pub fn new(temperature_25: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_25(temperature_25)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_25
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_25(&self) -> f32 {
        self.temperature_25_raw()
    }
    
    /// Get raw value of Temperature_25
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_25_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_25
    #[inline(always)]
    pub fn set_temperature_25(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp25::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp25 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp25 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_24
///
/// - Extended ID: 156992548 (0x95b8424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp24 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp24 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8424)});
    
    pub const TEMPERATURE_24_MIN: f32 = 0_f32;
    pub const TEMPERATURE_24_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_24 from values
    pub fn new(temperature_24: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_24(temperature_24)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_24
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_24(&self) -> f32 {
        self.temperature_24_raw()
    }
    
    /// Get raw value of Temperature_24
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_24_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_24
    #[inline(always)]
    pub fn set_temperature_24(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp24::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp24 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp24 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_23
///
/// - Extended ID: 156992292 (0x95b8324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp23 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp23 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8324)});
    
    pub const TEMPERATURE_23_MIN: f32 = 0_f32;
    pub const TEMPERATURE_23_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_23 from values
    pub fn new(temperature_23: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_23(temperature_23)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_23
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_23(&self) -> f32 {
        self.temperature_23_raw()
    }
    
    /// Get raw value of Temperature_23
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_23_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_23
    #[inline(always)]
    pub fn set_temperature_23(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp23::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp23 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp23 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_22
///
/// - Extended ID: 156992036 (0x95b8224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp22 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp22 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8224)});
    
    pub const TEMPERATURE_22_MIN: f32 = 0_f32;
    pub const TEMPERATURE_22_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_22 from values
    pub fn new(temperature_22: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_22(temperature_22)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_22
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_22(&self) -> f32 {
        self.temperature_22_raw()
    }
    
    /// Get raw value of Temperature_22
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_22_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_22
    #[inline(always)]
    pub fn set_temperature_22(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp22::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp22 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp22 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_21
///
/// - Extended ID: 156991780 (0x95b8124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp21 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp21 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8124)});
    
    pub const TEMPERATURE_21_MIN: f32 = 0_f32;
    pub const TEMPERATURE_21_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_21 from values
    pub fn new(temperature_21: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_21(temperature_21)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_21
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_21(&self) -> f32 {
        self.temperature_21_raw()
    }
    
    /// Get raw value of Temperature_21
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_21_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_21
    #[inline(always)]
    pub fn set_temperature_21(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp21::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp21 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp21 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_20
///
/// - Extended ID: 156991524 (0x95b8024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp20 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp20 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b8024)});
    
    pub const TEMPERATURE_20_MIN: f32 = 0_f32;
    pub const TEMPERATURE_20_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_20 from values
    pub fn new(temperature_20: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_20(temperature_20)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_20
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_20(&self) -> f32 {
        self.temperature_20_raw()
    }
    
    /// Get raw value of Temperature_20
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_20_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_20
    #[inline(always)]
    pub fn set_temperature_20(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp20::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp20 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp20 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_19
///
/// - Extended ID: 156991268 (0x95b7f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp19 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp19 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7f24)});
    
    pub const TEMPERATURE_19_MIN: f32 = 0_f32;
    pub const TEMPERATURE_19_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_19 from values
    pub fn new(temperature_19: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_19(temperature_19)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_19
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_19(&self) -> f32 {
        self.temperature_19_raw()
    }
    
    /// Get raw value of Temperature_19
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_19_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_19
    #[inline(always)]
    pub fn set_temperature_19(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp19::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp19 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp19 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_18
///
/// - Extended ID: 156991012 (0x95b7e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp18 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp18 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7e24)});
    
    pub const TEMPERATURE_18_MIN: f32 = 0_f32;
    pub const TEMPERATURE_18_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_18 from values
    pub fn new(temperature_18: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_18(temperature_18)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_18
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_18(&self) -> f32 {
        self.temperature_18_raw()
    }
    
    /// Get raw value of Temperature_18
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_18_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_18
    #[inline(always)]
    pub fn set_temperature_18(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp18::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp18 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp18 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_17
///
/// - Extended ID: 156990756 (0x95b7d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp17 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp17 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7d24)});
    
    pub const TEMPERATURE_17_MIN: f32 = 0_f32;
    pub const TEMPERATURE_17_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_17 from values
    pub fn new(temperature_17: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_17(temperature_17)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_17
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_17(&self) -> f32 {
        self.temperature_17_raw()
    }
    
    /// Get raw value of Temperature_17
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_17_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_17
    #[inline(always)]
    pub fn set_temperature_17(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp17::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp17 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp17 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_16
///
/// - Extended ID: 156990500 (0x95b7c24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp16 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp16 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7c24)});
    
    pub const TEMPERATURE_16_MIN: f32 = 0_f32;
    pub const TEMPERATURE_16_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_16 from values
    pub fn new(temperature_16: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_16(temperature_16)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_16
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_16(&self) -> f32 {
        self.temperature_16_raw()
    }
    
    /// Get raw value of Temperature_16
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_16_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_16
    #[inline(always)]
    pub fn set_temperature_16(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp16::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp16 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_15
///
/// - Extended ID: 156990244 (0x95b7b24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp15 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp15 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7b24)});
    
    pub const TEMPERATURE_15_MIN: f32 = 0_f32;
    pub const TEMPERATURE_15_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_15 from values
    pub fn new(temperature_15: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_15(temperature_15)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_15
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_15(&self) -> f32 {
        self.temperature_15_raw()
    }
    
    /// Get raw value of Temperature_15
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_15_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_15
    #[inline(always)]
    pub fn set_temperature_15(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp15::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp15 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_14
///
/// - Extended ID: 156989988 (0x95b7a24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp14 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp14 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7a24)});
    
    pub const TEMPERATURE_14_MIN: f32 = 0_f32;
    pub const TEMPERATURE_14_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_14 from values
    pub fn new(temperature_14: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_14(temperature_14)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_14
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_14(&self) -> f32 {
        self.temperature_14_raw()
    }
    
    /// Get raw value of Temperature_14
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_14_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_14
    #[inline(always)]
    pub fn set_temperature_14(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp14::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp14 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_13
///
/// - Extended ID: 156989732 (0x95b7924)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp13 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp13 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7924)});
    
    pub const TEMPERATURE_13_MIN: f32 = 0_f32;
    pub const TEMPERATURE_13_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_13 from values
    pub fn new(temperature_13: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_13(temperature_13)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_13
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_13(&self) -> f32 {
        self.temperature_13_raw()
    }
    
    /// Get raw value of Temperature_13
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_13_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_13
    #[inline(always)]
    pub fn set_temperature_13(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp13::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp13 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp13 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_12
///
/// - Extended ID: 156989476 (0x95b7824)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp12 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp12 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7824)});
    
    pub const TEMPERATURE_12_MIN: f32 = 0_f32;
    pub const TEMPERATURE_12_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_12 from values
    pub fn new(temperature_12: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_12(temperature_12)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_12(&self) -> f32 {
        self.temperature_12_raw()
    }
    
    /// Get raw value of Temperature_12
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_12_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_12
    #[inline(always)]
    pub fn set_temperature_12(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp12::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp12 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_11
///
/// - Extended ID: 156989220 (0x95b7724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp11 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp11 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7724)});
    
    pub const TEMPERATURE_11_MIN: f32 = 0_f32;
    pub const TEMPERATURE_11_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_11 from values
    pub fn new(temperature_11: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_11(temperature_11)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_11(&self) -> f32 {
        self.temperature_11_raw()
    }
    
    /// Get raw value of Temperature_11
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_11_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_11
    #[inline(always)]
    pub fn set_temperature_11(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp11::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp11 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_10
///
/// - Extended ID: 156988964 (0x95b7624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp10 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp10 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7624)});
    
    pub const TEMPERATURE_10_MIN: f32 = 0_f32;
    pub const TEMPERATURE_10_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_10 from values
    pub fn new(temperature_10: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_10(temperature_10)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_10(&self) -> f32 {
        self.temperature_10_raw()
    }
    
    /// Get raw value of Temperature_10
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_10_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_10
    #[inline(always)]
    pub fn set_temperature_10(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp10::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp10 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_9
///
/// - Extended ID: 156988708 (0x95b7524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp9 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp9 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7524)});
    
    pub const TEMPERATURE_9_MIN: f32 = 0_f32;
    pub const TEMPERATURE_9_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_9 from values
    pub fn new(temperature_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_9(temperature_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_9(&self) -> f32 {
        self.temperature_9_raw()
    }
    
    /// Get raw value of Temperature_9
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_9
    #[inline(always)]
    pub fn set_temperature_9(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp9::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp9 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp9 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_8
///
/// - Extended ID: 156988452 (0x95b7424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp8 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp8 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7424)});
    
    pub const TEMPERATURE_8_MIN: f32 = 0_f32;
    pub const TEMPERATURE_8_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_8 from values
    pub fn new(temperature_8: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_8(temperature_8)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_8(&self) -> f32 {
        self.temperature_8_raw()
    }
    
    /// Get raw value of Temperature_8
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_8_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_8
    #[inline(always)]
    pub fn set_temperature_8(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp8::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp8 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp8 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_7
///
/// - Extended ID: 156988196 (0x95b7324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp7 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp7 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7324)});
    
    pub const TEMPERATURE_7_MIN: f32 = 0_f32;
    pub const TEMPERATURE_7_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_7 from values
    pub fn new(temperature_7: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_7(temperature_7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_7(&self) -> f32 {
        self.temperature_7_raw()
    }
    
    /// Get raw value of Temperature_7
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_7_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_7
    #[inline(always)]
    pub fn set_temperature_7(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp7::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp7 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_6
///
/// - Extended ID: 156987940 (0x95b7224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp6 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp6 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7224)});
    
    pub const TEMPERATURE_6_MIN: f32 = 0_f32;
    pub const TEMPERATURE_6_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_6 from values
    pub fn new(temperature_6: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_6(temperature_6)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_6(&self) -> f32 {
        self.temperature_6_raw()
    }
    
    /// Get raw value of Temperature_6
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_6_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_6
    #[inline(always)]
    pub fn set_temperature_6(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp6::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp6 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_5
///
/// - Extended ID: 156987684 (0x95b7124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp5 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7124)});
    
    pub const TEMPERATURE_5_MIN: f32 = 0_f32;
    pub const TEMPERATURE_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_5 from values
    pub fn new(temperature_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_5(temperature_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_5(&self) -> f32 {
        self.temperature_5_raw()
    }
    
    /// Get raw value of Temperature_5
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_5
    #[inline(always)]
    pub fn set_temperature_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp5::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_4
///
/// - Extended ID: 156987428 (0x95b7024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp4 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b7024)});
    
    pub const TEMPERATURE_4_MIN: f32 = 0_f32;
    pub const TEMPERATURE_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_4 from values
    pub fn new(temperature_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_4(temperature_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_4(&self) -> f32 {
        self.temperature_4_raw()
    }
    
    /// Get raw value of Temperature_4
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_4
    #[inline(always)]
    pub fn set_temperature_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp4::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_3
///
/// - Extended ID: 156987172 (0x95b6f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6f24)});
    
    pub const TEMPERATURE_3_MIN: f32 = 0_f32;
    pub const TEMPERATURE_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_3 from values
    pub fn new(temperature_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_3(temperature_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_3(&self) -> f32 {
        self.temperature_3_raw()
    }
    
    /// Get raw value of Temperature_3
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_3
    #[inline(always)]
    pub fn set_temperature_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp3::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_2
///
/// - Extended ID: 156986916 (0x95b6e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6e24)});
    
    pub const TEMPERATURE_2_MIN: f32 = 0_f32;
    pub const TEMPERATURE_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_2 from values
    pub fn new(temperature_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_2(temperature_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_2(&self) -> f32 {
        self.temperature_2_raw()
    }
    
    /// Get raw value of Temperature_2
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_2
    #[inline(always)]
    pub fn set_temperature_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp2::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Temp_1
///
/// - Extended ID: 156986660 (0x95b6d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Temp1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Temp1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x95b6d24)});
    
    pub const TEMPERATURE_1_MIN: f32 = 0_f32;
    pub const TEMPERATURE_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Temp_1 from values
    pub fn new(temperature_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_temperature_1(temperature_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Temperature_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn temperature_1(&self) -> f32 {
        self.temperature_1_raw()
    }
    
    /// Get raw value of Temperature_1
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn temperature_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.1_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Temperature_1
    #[inline(always)]
    pub fn set_temperature_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Temp1::MESSAGE_ID });
        }
        let factor = 0.1_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Temp1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Temp1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_32
///
/// - Extended ID: 156011300 (0x94c8b24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog32 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog32 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8b24)});
    
    pub const ANALOG_32_MIN: f32 = 0_f32;
    pub const ANALOG_32_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_32 from values
    pub fn new(analog_32: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_32(analog_32)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_32
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_32(&self) -> f32 {
        self.analog_32_raw()
    }
    
    /// Get raw value of Analog_32
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_32_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_32
    #[inline(always)]
    pub fn set_analog_32(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog32::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog32 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog32 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_31
///
/// - Extended ID: 156011044 (0x94c8a24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog31 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog31 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8a24)});
    
    pub const ANALOG_31_MIN: f32 = 0_f32;
    pub const ANALOG_31_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_31 from values
    pub fn new(analog_31: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_31(analog_31)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_31
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_31(&self) -> f32 {
        self.analog_31_raw()
    }
    
    /// Get raw value of Analog_31
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_31_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_31
    #[inline(always)]
    pub fn set_analog_31(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog31::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog31 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog31 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_30
///
/// - Extended ID: 156010788 (0x94c8924)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog30 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog30 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8924)});
    
    pub const ANALOG_30_MIN: f32 = 0_f32;
    pub const ANALOG_30_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_30 from values
    pub fn new(analog_30: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_30(analog_30)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_30
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_30(&self) -> f32 {
        self.analog_30_raw()
    }
    
    /// Get raw value of Analog_30
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_30_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_30
    #[inline(always)]
    pub fn set_analog_30(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog30::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog30 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog30 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_29
///
/// - Extended ID: 156010532 (0x94c8824)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog29 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog29 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8824)});
    
    pub const ANALOG_29_MIN: f32 = 0_f32;
    pub const ANALOG_29_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_29 from values
    pub fn new(analog_29: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_29(analog_29)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_29
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_29(&self) -> f32 {
        self.analog_29_raw()
    }
    
    /// Get raw value of Analog_29
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_29_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_29
    #[inline(always)]
    pub fn set_analog_29(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog29::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog29 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog29 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_28
///
/// - Extended ID: 156010276 (0x94c8724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog28 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog28 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8724)});
    
    pub const ANALOG_28_MIN: f32 = 0_f32;
    pub const ANALOG_28_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_28 from values
    pub fn new(analog_28: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_28(analog_28)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_28
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_28(&self) -> f32 {
        self.analog_28_raw()
    }
    
    /// Get raw value of Analog_28
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_28_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_28
    #[inline(always)]
    pub fn set_analog_28(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog28::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog28 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog28 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_27
///
/// - Extended ID: 156010020 (0x94c8624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog27 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog27 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8624)});
    
    pub const ANALOG_27_MIN: f32 = 0_f32;
    pub const ANALOG_27_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_27 from values
    pub fn new(analog_27: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_27(analog_27)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_27
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_27(&self) -> f32 {
        self.analog_27_raw()
    }
    
    /// Get raw value of Analog_27
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_27_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_27
    #[inline(always)]
    pub fn set_analog_27(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog27::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog27 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog27 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_26
///
/// - Extended ID: 156009764 (0x94c8524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog26 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog26 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8524)});
    
    pub const ANALOG_26_MIN: f32 = 0_f32;
    pub const ANALOG_26_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_26 from values
    pub fn new(analog_26: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_26(analog_26)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_26
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_26(&self) -> f32 {
        self.analog_26_raw()
    }
    
    /// Get raw value of Analog_26
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_26_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_26
    #[inline(always)]
    pub fn set_analog_26(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog26::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog26 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog26 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_25
///
/// - Extended ID: 156009508 (0x94c8424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog25 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog25 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8424)});
    
    pub const ANALOG_25_MIN: f32 = 0_f32;
    pub const ANALOG_25_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_25 from values
    pub fn new(analog_25: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_25(analog_25)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_25
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_25(&self) -> f32 {
        self.analog_25_raw()
    }
    
    /// Get raw value of Analog_25
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_25_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_25
    #[inline(always)]
    pub fn set_analog_25(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog25::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog25 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog25 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_15
///
/// - Extended ID: 156006948 (0x94c7a24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog15 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog15 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7a24)});
    
    pub const ANALOG_15_MIN: f32 = 0_f32;
    pub const ANALOG_15_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_15 from values
    pub fn new(analog_15: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_15(analog_15)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_15
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_15(&self) -> f32 {
        self.analog_15_raw()
    }
    
    /// Get raw value of Analog_15
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_15_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_15
    #[inline(always)]
    pub fn set_analog_15(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog15::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog15 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog15 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_14
///
/// - Extended ID: 156006692 (0x94c7924)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog14 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog14 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7924)});
    
    pub const ANALOG_14_MIN: f32 = 0_f32;
    pub const ANALOG_14_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_14 from values
    pub fn new(analog_14: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_14(analog_14)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_14
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_14(&self) -> f32 {
        self.analog_14_raw()
    }
    
    /// Get raw value of Analog_14
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_14_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_14
    #[inline(always)]
    pub fn set_analog_14(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog14::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog14 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog14 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_17
///
/// - Extended ID: 156007460 (0x94c7c24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog17 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog17 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7c24)});
    
    pub const ANALOG_17_MIN: f32 = 0_f32;
    pub const ANALOG_17_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_17 from values
    pub fn new(analog_17: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_17(analog_17)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_17
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_17(&self) -> f32 {
        self.analog_17_raw()
    }
    
    /// Get raw value of Analog_17
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_17_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_17
    #[inline(always)]
    pub fn set_analog_17(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog17::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog17 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog17 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_24
///
/// - Extended ID: 156009252 (0x94c8324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog24 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog24 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8324)});
    
    pub const ANALOG_24_MIN: f32 = 0_f32;
    pub const ANALOG_24_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_24 from values
    pub fn new(analog_24: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_24(analog_24)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_24
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_24(&self) -> f32 {
        self.analog_24_raw()
    }
    
    /// Get raw value of Analog_24
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_24_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_24
    #[inline(always)]
    pub fn set_analog_24(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog24::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog24 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog24 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_23
///
/// - Extended ID: 156008996 (0x94c8224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog23 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog23 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8224)});
    
    pub const ANALOG_23_MIN: f32 = 0_f32;
    pub const ANALOG_23_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_23 from values
    pub fn new(analog_23: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_23(analog_23)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_23
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_23(&self) -> f32 {
        self.analog_23_raw()
    }
    
    /// Get raw value of Analog_23
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_23_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_23
    #[inline(always)]
    pub fn set_analog_23(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog23::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog23 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog23 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_22
///
/// - Extended ID: 156008740 (0x94c8124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog22 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog22 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8124)});
    
    pub const ANALOG_22_MIN: f32 = 0_f32;
    pub const ANALOG_22_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_22 from values
    pub fn new(analog_22: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_22(analog_22)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_22
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_22(&self) -> f32 {
        self.analog_22_raw()
    }
    
    /// Get raw value of Analog_22
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_22_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_22
    #[inline(always)]
    pub fn set_analog_22(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog22::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog22 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog22 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_21
///
/// - Extended ID: 156008484 (0x94c8024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog21 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog21 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c8024)});
    
    pub const ANALOG_21_MIN: f32 = 0_f32;
    pub const ANALOG_21_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_21 from values
    pub fn new(analog_21: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_21(analog_21)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_21
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_21(&self) -> f32 {
        self.analog_21_raw()
    }
    
    /// Get raw value of Analog_21
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_21_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_21
    #[inline(always)]
    pub fn set_analog_21(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog21::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog21 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog21 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_20
///
/// - Extended ID: 156008228 (0x94c7f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog20 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog20 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7f24)});
    
    pub const ANALOG_20_MIN: f32 = 0_f32;
    pub const ANALOG_20_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_20 from values
    pub fn new(analog_20: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_20(analog_20)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_20
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_20(&self) -> f32 {
        self.analog_20_raw()
    }
    
    /// Get raw value of Analog_20
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_20_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_20
    #[inline(always)]
    pub fn set_analog_20(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog20::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog20 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog20 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_19
///
/// - Extended ID: 156007972 (0x94c7e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog19 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog19 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7e24)});
    
    pub const ANALOG_19_MIN: f32 = 0_f32;
    pub const ANALOG_19_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_19 from values
    pub fn new(analog_19: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_19(analog_19)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_19
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_19(&self) -> f32 {
        self.analog_19_raw()
    }
    
    /// Get raw value of Analog_19
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_19_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_19
    #[inline(always)]
    pub fn set_analog_19(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog19::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog19 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog19 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_16
///
/// - Extended ID: 156007204 (0x94c7b24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog16 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog16 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7b24)});
    
    pub const ANALOG_16_MIN: f32 = 0_f32;
    pub const ANALOG_16_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_16 from values
    pub fn new(analog_16: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_16(analog_16)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_16
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_16(&self) -> f32 {
        self.analog_16_raw()
    }
    
    /// Get raw value of Analog_16
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_16_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_16
    #[inline(always)]
    pub fn set_analog_16(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog16::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog16 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog16 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_18
///
/// - Extended ID: 156007716 (0x94c7d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog18 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog18 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7d24)});
    
    pub const ANALOG_18_MIN: f32 = 0_f32;
    pub const ANALOG_18_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_18 from values
    pub fn new(analog_18: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_18(analog_18)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_18
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_18(&self) -> f32 {
        self.analog_18_raw()
    }
    
    /// Get raw value of Analog_18
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_18_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_18
    #[inline(always)]
    pub fn set_analog_18(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog18::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog18 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog18 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_12
///
/// - Extended ID: 156006180 (0x94c7724)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog12 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog12 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7724)});
    
    pub const ANALOG_12_MIN: f32 = 0_f32;
    pub const ANALOG_12_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_12 from values
    pub fn new(analog_12: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_12(analog_12)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_12
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_12(&self) -> f32 {
        self.analog_12_raw()
    }
    
    /// Get raw value of Analog_12
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_12_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_12
    #[inline(always)]
    pub fn set_analog_12(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog12::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog12 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog12 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_11
///
/// - Extended ID: 156005924 (0x94c7624)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog11 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog11 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7624)});
    
    pub const ANALOG_11_MIN: f32 = 0_f32;
    pub const ANALOG_11_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_11 from values
    pub fn new(analog_11: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_11(analog_11)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_11
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_11(&self) -> f32 {
        self.analog_11_raw()
    }
    
    /// Get raw value of Analog_11
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_11_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_11
    #[inline(always)]
    pub fn set_analog_11(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog11::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog11 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog11 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_10
///
/// - Extended ID: 156005668 (0x94c7524)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog10 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog10 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7524)});
    
    pub const ANALOG_10_MIN: f32 = 0_f32;
    pub const ANALOG_10_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_10 from values
    pub fn new(analog_10: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_10(analog_10)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_10
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_10(&self) -> f32 {
        self.analog_10_raw()
    }
    
    /// Get raw value of Analog_10
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_10_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_10
    #[inline(always)]
    pub fn set_analog_10(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog10::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog10 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog10 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_9
///
/// - Extended ID: 156005412 (0x94c7424)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog9 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog9 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7424)});
    
    pub const ANALOG_9_MIN: f32 = 0_f32;
    pub const ANALOG_9_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_9 from values
    pub fn new(analog_9: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_9(analog_9)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_9
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_9(&self) -> f32 {
        self.analog_9_raw()
    }
    
    /// Get raw value of Analog_9
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_9_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_9
    #[inline(always)]
    pub fn set_analog_9(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog9::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog9 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog9 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_8
///
/// - Extended ID: 156005156 (0x94c7324)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog8 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog8 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7324)});
    
    pub const ANALOG_8_MIN: f32 = 0_f32;
    pub const ANALOG_8_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_8 from values
    pub fn new(analog_8: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_8(analog_8)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_8
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_8(&self) -> f32 {
        self.analog_8_raw()
    }
    
    /// Get raw value of Analog_8
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_8_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_8
    #[inline(always)]
    pub fn set_analog_8(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog8::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog8 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog8 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_7
///
/// - Extended ID: 156004900 (0x94c7224)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog7 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog7 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7224)});
    
    pub const ANALOG_7_MIN: f32 = 0_f32;
    pub const ANALOG_7_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_7 from values
    pub fn new(analog_7: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_7(analog_7)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_7
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_7(&self) -> f32 {
        self.analog_7_raw()
    }
    
    /// Get raw value of Analog_7
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_7_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_7
    #[inline(always)]
    pub fn set_analog_7(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog7::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog7 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog7 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_6
///
/// - Extended ID: 156004644 (0x94c7124)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog6 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog6 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7124)});
    
    pub const ANALOG_6_MIN: f32 = 0_f32;
    pub const ANALOG_6_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_6 from values
    pub fn new(analog_6: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_6(analog_6)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_6
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_6(&self) -> f32 {
        self.analog_6_raw()
    }
    
    /// Get raw value of Analog_6
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_6_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_6
    #[inline(always)]
    pub fn set_analog_6(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog6::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog6 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog6 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_5
///
/// - Extended ID: 156004388 (0x94c7024)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog5 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog5 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c7024)});
    
    pub const ANALOG_5_MIN: f32 = 0_f32;
    pub const ANALOG_5_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_5 from values
    pub fn new(analog_5: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_5(analog_5)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_5
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_5(&self) -> f32 {
        self.analog_5_raw()
    }
    
    /// Get raw value of Analog_5
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_5_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_5
    #[inline(always)]
    pub fn set_analog_5(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog5::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog5 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog5 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_4
///
/// - Extended ID: 156004132 (0x94c6f24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog4 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog4 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c6f24)});
    
    pub const ANALOG_4_MIN: f32 = 0_f32;
    pub const ANALOG_4_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_4 from values
    pub fn new(analog_4: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_4(analog_4)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_4
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_4(&self) -> f32 {
        self.analog_4_raw()
    }
    
    /// Get raw value of Analog_4
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_4_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_4
    #[inline(always)]
    pub fn set_analog_4(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog4::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog4 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog4 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_3
///
/// - Extended ID: 156003876 (0x94c6e24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog3 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog3 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c6e24)});
    
    pub const ANALOG_3_MIN: f32 = 0_f32;
    pub const ANALOG_3_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_3 from values
    pub fn new(analog_3: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_3(analog_3)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_3
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_3(&self) -> f32 {
        self.analog_3_raw()
    }
    
    /// Get raw value of Analog_3
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_3_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_3
    #[inline(always)]
    pub fn set_analog_3(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog3::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog3 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog3 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_2
///
/// - Extended ID: 156003620 (0x94c6d24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog2 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c6d24)});
    
    pub const ANALOG_2_MIN: f32 = 0_f32;
    pub const ANALOG_2_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_2 from values
    pub fn new(analog_2: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_2(analog_2)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_2
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_2(&self) -> f32 {
        self.analog_2_raw()
    }
    
    /// Get raw value of Analog_2
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_2
    #[inline(always)]
    pub fn set_analog_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Analog_1
///
/// - Extended ID: 156003364 (0x94c6c24)
/// - Size: 2 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Analog1 {
    raw: [u8; 2],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Analog1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94c6c24)});
    
    pub const ANALOG_1_MIN: f32 = 0_f32;
    pub const ANALOG_1_MAX: f32 = 0_f32;
    
    /// Construct new RT_DL1MK3_Analog_1 from values
    pub fn new(analog_1: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 2] };
        res.set_analog_1(analog_1)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 2] {
        &self.raw
    }
    
    /// Analog_1
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn analog_1(&self) -> f32 {
        self.analog_1_raw()
    }
    
    /// Get raw value of Analog_1
    ///
    /// - Start bit: 7
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: BigEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn analog_1_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Msb0>()[0..16].load_be::<u16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Analog_1
    #[inline(always)]
    pub fn set_analog_1(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 0_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Analog1::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Msb0>()[0..16].store_be(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Analog1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 2 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 2];
        raw.copy_from_slice(&payload[..2]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Analog1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_DL1MK3_Accel
///
/// - Extended ID: 155872292 (0x94a6c24)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtDl1mk3Accel {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtDl1mk3Accel {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a6c24)});
    
    pub const ACCEL_VERTICAL_MIN: f32 = -65_f32;
    pub const ACCEL_VERTICAL_MAX: f32 = 65_f32;
    pub const ACCEL_LATERAL_MIN: f32 = -65_f32;
    pub const ACCEL_LATERAL_MAX: f32 = 65_f32;
    pub const ACCEL_LONGITUDINAL_MIN: f32 = -65_f32;
    pub const ACCEL_LONGITUDINAL_MAX: f32 = 65_f32;
    pub const ACCURACY_ACCEL_MIN: u8 = 0_u8;
    pub const ACCURACY_ACCEL_MAX: u8 = 255_u8;
    
    /// Construct new RT_DL1MK3_Accel from values
    pub fn new(accel_vertical: f32, accel_lateral: f32, accel_longitudinal: f32, accuracy_accel: u8, validity_accel_vertical: bool, validity_accel_lateral: bool, validity_accel_longitudinal: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_accel_vertical(accel_vertical)?;
        res.set_accel_lateral(accel_lateral)?;
        res.set_accel_longitudinal(accel_longitudinal)?;
        res.set_accuracy_accel(accuracy_accel)?;
        res.set_validity_accel_vertical(validity_accel_vertical)?;
        res.set_validity_accel_lateral(validity_accel_lateral)?;
        res.set_validity_accel_longitudinal(validity_accel_longitudinal)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Accel_Vertical
    ///
    /// Vertical acceleration.  This is positive when the vehicle accelerates in an upwards direction, e.g. when travelling through a dip.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_vertical(&self) -> f32 {
        self.accel_vertical_raw()
    }
    
    /// Get raw value of Accel_Vertical
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_vertical_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Vertical
    #[inline(always)]
    pub fn set_accel_vertical(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Accel_Lateral
    ///
    /// Lateral acceleration.  This is positive when the vehicle accelerates towards the right, e.g. when cornering around a right-hand bend.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_lateral(&self) -> f32 {
        self.accel_lateral_raw()
    }
    
    /// Get raw value of Accel_Lateral
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_lateral_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Lateral
    #[inline(always)]
    pub fn set_accel_lateral(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Accel_Longitudinal
    ///
    /// Longitudinal acceleration.  This is positive when the vehicle accelerates in a forwards direction.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_longitudinal(&self) -> f32 {
        self.accel_longitudinal_raw()
    }
    
    /// Get raw value of Accel_Longitudinal
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_longitudinal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Longitudinal
    #[inline(always)]
    pub fn set_accel_longitudinal(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Accel
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_accel(&self) -> u8 {
        self.accuracy_accel_raw()
    }
    
    /// Get raw value of Accuracy_Accel
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_accel_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Accel
    #[inline(always)]
    pub fn set_accuracy_accel(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtDl1mk3Accel::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtDl1mk3Accel::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Vertical
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_vertical(&self) -> bool {
        self.validity_accel_vertical_raw()
    }
    
    /// Get raw value of Validity_Accel_Vertical
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_vertical_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Vertical
    #[inline(always)]
    pub fn set_validity_accel_vertical(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Lateral
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_lateral(&self) -> bool {
        self.validity_accel_lateral_raw()
    }
    
    /// Get raw value of Validity_Accel_Lateral
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_lateral_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Lateral
    #[inline(always)]
    pub fn set_validity_accel_lateral(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Longitudinal
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_longitudinal(&self) -> bool {
        self.validity_accel_longitudinal_raw()
    }
    
    /// Get raw value of Validity_Accel_Longitudinal
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_longitudinal_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Longitudinal
    #[inline(always)]
    pub fn set_validity_accel_longitudinal(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtDl1mk3Accel {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtDl1mk3Accel {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_4_Vel_NED_2
///
/// - Extended ID: 156868130 (0x9599e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt4VelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt4VelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9599e22)});
    
    pub const VIRTUAL_4_SLIP_MIN: f32 = -180_f32;
    pub const VIRTUAL_4_SLIP_MAX: f32 = 180_f32;
    pub const VIRTUAL_4_HEADING_MIN: f32 = -180_f32;
    pub const VIRTUAL_4_HEADING_MAX: f32 = 180_f32;
    pub const VIRTUAL_4_VEL_NED_D_MIN: f32 = -838_f32;
    pub const VIRTUAL_4_VEL_NED_D_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_4_Vel_NED_2 from values
    pub fn new(virtual_4_slip: f32, virtual_4_heading: f32, virtual_4_vel_ned_d: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_4_slip(virtual_4_slip)?;
        res.set_virtual_4_heading(virtual_4_heading)?;
        res.set_virtual_4_vel_ned_d(virtual_4_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_4_Slip
    ///
    /// Slip is defined as the difference between yaw and heading.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_slip(&self) -> f32 {
        self.virtual_4_slip_raw()
    }
    
    /// Get raw value of Virtual_4_Slip
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Slip
    #[inline(always)]
    pub fn set_virtual_4_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Virtual_4_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_heading(&self) -> f32 {
        self.virtual_4_heading_raw()
    }
    
    /// Get raw value of Virtual_4_Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Heading
    #[inline(always)]
    pub fn set_virtual_4_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_4_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_vel_ned_d(&self) -> f32 {
        self.virtual_4_vel_ned_d_raw()
    }
    
    /// Get raw value of Virtual_4_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Vel_NED_D
    #[inline(always)]
    pub fn set_virtual_4_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4VelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt4VelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt4VelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_4_Vel_NED_1
///
/// - Extended ID: 156867874 (0x9599d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt4VelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt4VelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9599d22)});
    
    pub const VIRTUAL_4_VEL_NED_E_MIN: f32 = -838_f32;
    pub const VIRTUAL_4_VEL_NED_E_MAX: f32 = 838_f32;
    pub const VIRTUAL_4_VEL_NED_N_MIN: f32 = -838_f32;
    pub const VIRTUAL_4_VEL_NED_N_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_4_Vel_NED_1 from values
    pub fn new(virtual_4_vel_ned_e: f32, virtual_4_vel_ned_n: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_4_vel_ned_e(virtual_4_vel_ned_e)?;
        res.set_virtual_4_vel_ned_n(virtual_4_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_4_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_vel_ned_e(&self) -> f32 {
        self.virtual_4_vel_ned_e_raw()
    }
    
    /// Get raw value of Virtual_4_Vel_NED_E
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Vel_NED_E
    #[inline(always)]
    pub fn set_virtual_4_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Virtual_4_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_vel_ned_n(&self) -> f32 {
        self.virtual_4_vel_ned_n_raw()
    }
    
    /// Get raw value of Virtual_4_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Vel_NED_N
    #[inline(always)]
    pub fn set_virtual_4_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt4VelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt4VelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_4_Offset
///
/// - Extended ID: 156867618 (0x9599c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt4Offset {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt4Offset {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9599c22)});
    
    pub const VIRTUAL_4_OFFSET_Z_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_4_OFFSET_Z_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_4_OFFSET_Y_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_4_OFFSET_Y_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_4_OFFSET_X_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_4_OFFSET_X_MAX: f32 = 32.767_f32;
    
    /// Construct new RT_SB_INS_Vpt_4_Offset from values
    pub fn new(virtual_4_offset_z: f32, virtual_4_offset_y: f32, virtual_4_offset_x: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_4_offset_z(virtual_4_offset_z)?;
        res.set_virtual_4_offset_y(virtual_4_offset_y)?;
        res.set_virtual_4_offset_x(virtual_4_offset_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_4_Offset_Z
    ///
    /// Z offset (+ve downwards) of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_offset_z(&self) -> f32 {
        self.virtual_4_offset_z_raw()
    }
    
    /// Get raw value of Virtual_4_Offset_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_offset_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Offset_Z
    #[inline(always)]
    pub fn set_virtual_4_offset_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_4_Offset_Y
    ///
    /// Y offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_offset_y(&self) -> f32 {
        self.virtual_4_offset_y_raw()
    }
    
    /// Get raw value of Virtual_4_Offset_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_offset_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Offset_Y
    #[inline(always)]
    pub fn set_virtual_4_offset_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Virtual_4_Offset_X
    ///
    /// X offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_4_offset_x(&self) -> f32 {
        self.virtual_4_offset_x_raw()
    }
    
    /// Get raw value of Virtual_4_Offset_X
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_4_offset_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_4_Offset_X
    #[inline(always)]
    pub fn set_virtual_4_offset_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt4Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt4Offset {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt4Offset {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_3_Vel_NED_2
///
/// - Extended ID: 156864034 (0x9598e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt3VelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt3VelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9598e22)});
    
    pub const VIRTUAL_3_SLIP_MIN: f32 = -180_f32;
    pub const VIRTUAL_3_SLIP_MAX: f32 = 180_f32;
    pub const VIRTUAL_3_HEADING_MIN: f32 = -180_f32;
    pub const VIRTUAL_3_HEADING_MAX: f32 = 180_f32;
    pub const VIRTUAL_3_VEL_NED_D_MIN: f32 = -838_f32;
    pub const VIRTUAL_3_VEL_NED_D_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_3_Vel_NED_2 from values
    pub fn new(virtual_3_slip: f32, virtual_3_heading: f32, virtual_3_vel_ned_d: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_3_slip(virtual_3_slip)?;
        res.set_virtual_3_heading(virtual_3_heading)?;
        res.set_virtual_3_vel_ned_d(virtual_3_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_3_Slip
    ///
    /// Slip is defined as the difference between yaw and heading.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_slip(&self) -> f32 {
        self.virtual_3_slip_raw()
    }
    
    /// Get raw value of Virtual_3_Slip
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Slip
    #[inline(always)]
    pub fn set_virtual_3_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Virtual_3_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_heading(&self) -> f32 {
        self.virtual_3_heading_raw()
    }
    
    /// Get raw value of Virtual_3_Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Heading
    #[inline(always)]
    pub fn set_virtual_3_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_3_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_vel_ned_d(&self) -> f32 {
        self.virtual_3_vel_ned_d_raw()
    }
    
    /// Get raw value of Virtual_3_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Vel_NED_D
    #[inline(always)]
    pub fn set_virtual_3_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3VelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt3VelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt3VelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_3_Vel_NED_1
///
/// - Extended ID: 156863778 (0x9598d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt3VelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt3VelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9598d22)});
    
    pub const VIRTUAL_3_VEL_NED_E_MIN: f32 = -838_f32;
    pub const VIRTUAL_3_VEL_NED_E_MAX: f32 = 838_f32;
    pub const VIRTUAL_3_VEL_NED_N_MIN: f32 = -838_f32;
    pub const VIRTUAL_3_VEL_NED_N_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_3_Vel_NED_1 from values
    pub fn new(virtual_3_vel_ned_e: f32, virtual_3_vel_ned_n: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_3_vel_ned_e(virtual_3_vel_ned_e)?;
        res.set_virtual_3_vel_ned_n(virtual_3_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_3_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_vel_ned_e(&self) -> f32 {
        self.virtual_3_vel_ned_e_raw()
    }
    
    /// Get raw value of Virtual_3_Vel_NED_E
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Vel_NED_E
    #[inline(always)]
    pub fn set_virtual_3_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Virtual_3_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_vel_ned_n(&self) -> f32 {
        self.virtual_3_vel_ned_n_raw()
    }
    
    /// Get raw value of Virtual_3_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Vel_NED_N
    #[inline(always)]
    pub fn set_virtual_3_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt3VelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt3VelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_3_Offset
///
/// - Extended ID: 156863522 (0x9598c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt3Offset {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt3Offset {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9598c22)});
    
    pub const VIRTUAL_3_OFFSET_Z_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_3_OFFSET_Z_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_3_OFFSET_Y_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_3_OFFSET_Y_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_3_OFFSET_X_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_3_OFFSET_X_MAX: f32 = 32.767_f32;
    
    /// Construct new RT_SB_INS_Vpt_3_Offset from values
    pub fn new(virtual_3_offset_z: f32, virtual_3_offset_y: f32, virtual_3_offset_x: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_3_offset_z(virtual_3_offset_z)?;
        res.set_virtual_3_offset_y(virtual_3_offset_y)?;
        res.set_virtual_3_offset_x(virtual_3_offset_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_3_Offset_Z
    ///
    /// Z offset (+ve downwards) of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_offset_z(&self) -> f32 {
        self.virtual_3_offset_z_raw()
    }
    
    /// Get raw value of Virtual_3_Offset_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_offset_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Offset_Z
    #[inline(always)]
    pub fn set_virtual_3_offset_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_3_Offset_Y
    ///
    /// Y offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_offset_y(&self) -> f32 {
        self.virtual_3_offset_y_raw()
    }
    
    /// Get raw value of Virtual_3_Offset_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_offset_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Offset_Y
    #[inline(always)]
    pub fn set_virtual_3_offset_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Virtual_3_Offset_X
    ///
    /// X offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_3_offset_x(&self) -> f32 {
        self.virtual_3_offset_x_raw()
    }
    
    /// Get raw value of Virtual_3_Offset_X
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_3_offset_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_3_Offset_X
    #[inline(always)]
    pub fn set_virtual_3_offset_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt3Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt3Offset {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt3Offset {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_2_Vel_NED_2
///
/// - Extended ID: 156859938 (0x9597e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt2VelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt2VelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9597e22)});
    
    pub const VIRTUAL_2_SLIP_MIN: f32 = -180_f32;
    pub const VIRTUAL_2_SLIP_MAX: f32 = 180_f32;
    pub const VIRTUAL_2_HEADING_MIN: f32 = -180_f32;
    pub const VIRTUAL_2_HEADING_MAX: f32 = 180_f32;
    pub const VIRTUAL_2_VEL_NED_D_MIN: f32 = -838_f32;
    pub const VIRTUAL_2_VEL_NED_D_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_2_Vel_NED_2 from values
    pub fn new(virtual_2_slip: f32, virtual_2_heading: f32, virtual_2_vel_ned_d: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_2_slip(virtual_2_slip)?;
        res.set_virtual_2_heading(virtual_2_heading)?;
        res.set_virtual_2_vel_ned_d(virtual_2_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_2_Slip
    ///
    /// Slip is defined as the difference between yaw and heading.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_slip(&self) -> f32 {
        self.virtual_2_slip_raw()
    }
    
    /// Get raw value of Virtual_2_Slip
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Slip
    #[inline(always)]
    pub fn set_virtual_2_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Virtual_2_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_heading(&self) -> f32 {
        self.virtual_2_heading_raw()
    }
    
    /// Get raw value of Virtual_2_Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Heading
    #[inline(always)]
    pub fn set_virtual_2_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_2_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_vel_ned_d(&self) -> f32 {
        self.virtual_2_vel_ned_d_raw()
    }
    
    /// Get raw value of Virtual_2_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Vel_NED_D
    #[inline(always)]
    pub fn set_virtual_2_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2VelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt2VelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt2VelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_2_Vel_NED_1
///
/// - Extended ID: 156859682 (0x9597d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt2VelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt2VelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9597d22)});
    
    pub const VIRTUAL_2_VEL_NED_E_MIN: f32 = -838_f32;
    pub const VIRTUAL_2_VEL_NED_E_MAX: f32 = 838_f32;
    pub const VIRTUAL_2_VEL_NED_N_MIN: f32 = -838_f32;
    pub const VIRTUAL_2_VEL_NED_N_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_2_Vel_NED_1 from values
    pub fn new(virtual_2_vel_ned_e: f32, virtual_2_vel_ned_n: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_2_vel_ned_e(virtual_2_vel_ned_e)?;
        res.set_virtual_2_vel_ned_n(virtual_2_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_2_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_vel_ned_e(&self) -> f32 {
        self.virtual_2_vel_ned_e_raw()
    }
    
    /// Get raw value of Virtual_2_Vel_NED_E
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Vel_NED_E
    #[inline(always)]
    pub fn set_virtual_2_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Virtual_2_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_vel_ned_n(&self) -> f32 {
        self.virtual_2_vel_ned_n_raw()
    }
    
    /// Get raw value of Virtual_2_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Vel_NED_N
    #[inline(always)]
    pub fn set_virtual_2_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt2VelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt2VelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_2_Offset
///
/// - Extended ID: 156859426 (0x9597c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt2Offset {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt2Offset {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9597c22)});
    
    pub const VIRTUAL_2_OFFSET_Z_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_2_OFFSET_Z_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_2_OFFSET_Y_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_2_OFFSET_Y_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_2_OFFSET_X_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_2_OFFSET_X_MAX: f32 = 32.767_f32;
    
    /// Construct new RT_SB_INS_Vpt_2_Offset from values
    pub fn new(virtual_2_offset_z: f32, virtual_2_offset_y: f32, virtual_2_offset_x: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_2_offset_z(virtual_2_offset_z)?;
        res.set_virtual_2_offset_y(virtual_2_offset_y)?;
        res.set_virtual_2_offset_x(virtual_2_offset_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_2_Offset_Z
    ///
    /// Z offset (+ve downwards) of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_offset_z(&self) -> f32 {
        self.virtual_2_offset_z_raw()
    }
    
    /// Get raw value of Virtual_2_Offset_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_offset_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Offset_Z
    #[inline(always)]
    pub fn set_virtual_2_offset_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_2_Offset_Y
    ///
    /// Y offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_offset_y(&self) -> f32 {
        self.virtual_2_offset_y_raw()
    }
    
    /// Get raw value of Virtual_2_Offset_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_offset_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Offset_Y
    #[inline(always)]
    pub fn set_virtual_2_offset_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Virtual_2_Offset_X
    ///
    /// X offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_2_offset_x(&self) -> f32 {
        self.virtual_2_offset_x_raw()
    }
    
    /// Get raw value of Virtual_2_Offset_X
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_2_offset_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_2_Offset_X
    #[inline(always)]
    pub fn set_virtual_2_offset_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt2Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt2Offset {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt2Offset {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_1_Vel_NED_2
///
/// - Extended ID: 156855842 (0x9596e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt1VelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt1VelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9596e22)});
    
    pub const VIRTUAL_1_SLIP_MIN: f32 = -180_f32;
    pub const VIRTUAL_1_SLIP_MAX: f32 = 180_f32;
    pub const VIRTUAL_1_HEADING_MIN: f32 = -180_f32;
    pub const VIRTUAL_1_HEADING_MAX: f32 = 180_f32;
    pub const VIRTUAL_1_VEL_NED_D_MIN: f32 = -838_f32;
    pub const VIRTUAL_1_VEL_NED_D_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_1_Vel_NED_2 from values
    pub fn new(virtual_1_slip: f32, virtual_1_heading: f32, virtual_1_vel_ned_d: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_1_slip(virtual_1_slip)?;
        res.set_virtual_1_heading(virtual_1_heading)?;
        res.set_virtual_1_vel_ned_d(virtual_1_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_1_Slip
    ///
    /// Slip is defined as the difference between yaw and heading.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_slip(&self) -> f32 {
        self.virtual_1_slip_raw()
    }
    
    /// Get raw value of Virtual_1_Slip
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Slip
    #[inline(always)]
    pub fn set_virtual_1_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Virtual_1_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_heading(&self) -> f32 {
        self.virtual_1_heading_raw()
    }
    
    /// Get raw value of Virtual_1_Heading
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Heading
    #[inline(always)]
    pub fn set_virtual_1_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1VelNed2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_1_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_vel_ned_d(&self) -> f32 {
        self.virtual_1_vel_ned_d_raw()
    }
    
    /// Get raw value of Virtual_1_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Vel_NED_D
    #[inline(always)]
    pub fn set_virtual_1_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1VelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt1VelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt1VelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_1_Vel_NED_1
///
/// - Extended ID: 156855586 (0x9596d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt1VelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt1VelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9596d22)});
    
    pub const VIRTUAL_1_VEL_NED_E_MIN: f32 = -838_f32;
    pub const VIRTUAL_1_VEL_NED_E_MAX: f32 = 838_f32;
    pub const VIRTUAL_1_VEL_NED_N_MIN: f32 = -838_f32;
    pub const VIRTUAL_1_VEL_NED_N_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vpt_1_Vel_NED_1 from values
    pub fn new(virtual_1_vel_ned_e: f32, virtual_1_vel_ned_n: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_1_vel_ned_e(virtual_1_vel_ned_e)?;
        res.set_virtual_1_vel_ned_n(virtual_1_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_1_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_vel_ned_e(&self) -> f32 {
        self.virtual_1_vel_ned_e_raw()
    }
    
    /// Get raw value of Virtual_1_Vel_NED_E
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Vel_NED_E
    #[inline(always)]
    pub fn set_virtual_1_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Virtual_1_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_vel_ned_n(&self) -> f32 {
        self.virtual_1_vel_ned_n_raw()
    }
    
    /// Get raw value of Virtual_1_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..24].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Vel_NED_N
    #[inline(always)]
    pub fn set_virtual_1_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1VelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..24].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt1VelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt1VelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vpt_1_Offset
///
/// - Extended ID: 156855330 (0x9596c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVpt1Offset {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVpt1Offset {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9596c22)});
    
    pub const VIRTUAL_1_OFFSET_Z_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_1_OFFSET_Z_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_1_OFFSET_Y_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_1_OFFSET_Y_MAX: f32 = 32.767_f32;
    pub const VIRTUAL_1_OFFSET_X_MIN: f32 = -32.768_f32;
    pub const VIRTUAL_1_OFFSET_X_MAX: f32 = 32.767_f32;
    
    /// Construct new RT_SB_INS_Vpt_1_Offset from values
    pub fn new(virtual_1_offset_z: f32, virtual_1_offset_y: f32, virtual_1_offset_x: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_virtual_1_offset_z(virtual_1_offset_z)?;
        res.set_virtual_1_offset_y(virtual_1_offset_y)?;
        res.set_virtual_1_offset_x(virtual_1_offset_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Virtual_1_Offset_Z
    ///
    /// Z offset (+ve downwards) of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_offset_z(&self) -> f32 {
        self.virtual_1_offset_z_raw()
    }
    
    /// Get raw value of Virtual_1_Offset_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_offset_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Offset_Z
    #[inline(always)]
    pub fn set_virtual_1_offset_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Virtual_1_Offset_Y
    ///
    /// Y offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_offset_y(&self) -> f32 {
        self.virtual_1_offset_y_raw()
    }
    
    /// Get raw value of Virtual_1_Offset_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_offset_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Offset_Y
    #[inline(always)]
    pub fn set_virtual_1_offset_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Virtual_1_Offset_X
    ///
    /// X offset of the virtual point in the vehicle body frame.
    ///
    /// - Min: -32.768
    /// - Max: 32.767
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn virtual_1_offset_x(&self) -> f32 {
        self.virtual_1_offset_x_raw()
    }
    
    /// Get raw value of Virtual_1_Offset_X
    ///
    /// - Start bit: 0
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn virtual_1_offset_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..16].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Virtual_1_Offset_X
    #[inline(always)]
    pub fn set_virtual_1_offset_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -32.768_f32 || 32.767_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVpt1Offset::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..16].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVpt1Offset {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVpt1Offset {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Slip
///
/// - Extended ID: 156795426 (0x9588222)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsSlip {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsSlip {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9588222)});
    
    pub const INS_SQUAT_MIN: f32 = -360_f32;
    pub const INS_SQUAT_MAX: f32 = 360_f32;
    pub const ACCURACY_INS_SQUAT_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_SQUAT_MAX: u8 = 255_u8;
    pub const INS_SLIP_MIN: f32 = -360_f32;
    pub const INS_SLIP_MAX: f32 = 360_f32;
    pub const ACCURACY_INS_SLIP_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_SLIP_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Slip from values
    pub fn new(ins_squat: f32, accuracy_ins_squat: u8, ins_slip: f32, accuracy_ins_slip: u8, validity_ins_squat: bool, validity_ins_slip: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_squat(ins_squat)?;
        res.set_accuracy_ins_squat(accuracy_ins_squat)?;
        res.set_ins_slip(ins_slip)?;
        res.set_accuracy_ins_slip(accuracy_ins_slip)?;
        res.set_validity_ins_squat(validity_ins_squat)?;
        res.set_validity_ins_slip(validity_ins_slip)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Squat
    ///
    /// Squat is defined as the difference between pitch and gradient
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_squat(&self) -> f32 {
        self.ins_squat_raw()
    }
    
    /// Get raw value of INS_Squat
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_squat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Squat
    #[inline(always)]
    pub fn set_ins_squat(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Squat
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_squat(&self) -> u8 {
        self.accuracy_ins_squat_raw()
    }
    
    /// Get raw value of Accuracy_INS_Squat
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_squat_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Squat
    #[inline(always)]
    pub fn set_accuracy_ins_squat(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// INS_Slip
    ///
    /// Slip is defined as the difference between yaw and heading
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_slip(&self) -> f32 {
        self.ins_slip_raw()
    }
    
    /// Get raw value of INS_Slip
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Slip
    #[inline(always)]
    pub fn set_ins_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Slip
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_slip(&self) -> u8 {
        self.accuracy_ins_slip_raw()
    }
    
    /// Get raw value of Accuracy_INS_Slip
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_slip_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Slip
    #[inline(always)]
    pub fn set_accuracy_ins_slip(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsSlip::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Squat
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_squat(&self) -> bool {
        self.validity_ins_squat_raw()
    }
    
    /// Get raw value of Validity_INS_Squat
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_squat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Squat
    #[inline(always)]
    pub fn set_validity_ins_squat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Slip
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_slip(&self) -> bool {
        self.validity_ins_slip_raw()
    }
    
    /// Get raw value of Validity_INS_Slip
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_slip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Slip
    #[inline(always)]
    pub fn set_validity_ins_slip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsSlip {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsSlip {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vel_ECEF_2
///
/// - Extended ID: 156794658 (0x9587f22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVelEcef2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVelEcef2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587f22)});
    
    pub const INS_VEL_ECEF_Z_MIN: f32 = -838_f32;
    pub const INS_VEL_ECEF_Z_MAX: f32 = 838_f32;
    pub const INS_VEL_ECEF_Y_MIN: f32 = -838_f32;
    pub const INS_VEL_ECEF_Y_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_INS_Vel_ECEF_2 from values
    pub fn new(ins_vel_ecef_z: f32, ins_vel_ecef_y: f32, validity_ins_vel_ecef_z: bool, validity_ins_vel_ecef_y: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_vel_ecef_z(ins_vel_ecef_z)?;
        res.set_ins_vel_ecef_y(ins_vel_ecef_y)?;
        res.set_validity_ins_vel_ecef_z(validity_ins_vel_ecef_z)?;
        res.set_validity_ins_vel_ecef_y(validity_ins_vel_ecef_y)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Vel_ECEF_Z
    ///
    /// ECEF Z velocity.  The ECEF Z axis originates from the Earth centre, and the positive Z axis intersects the Earth surface at the North Pole.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ecef_z(&self) -> f32 {
        self.ins_vel_ecef_z_raw()
    }
    
    /// Get raw value of INS_Vel_ECEF_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ecef_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_ins_vel_ecef_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// INS_Vel_ECEF_Y
    ///
    /// ECEF Y velocity.  The ECEF Y axis originates from the Earth centre, and the positive Y axis intersects the Earth surface at zero degrees latittude and 90 degrees longitude.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ecef_y(&self) -> f32 {
        self.ins_vel_ecef_y_raw()
    }
    
    /// Get raw value of INS_Vel_ECEF_Y
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ecef_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_ins_vel_ecef_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_ECEF_Z
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ecef_z(&self) -> bool {
        self.validity_ins_vel_ecef_z_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_ECEF_Z
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ecef_z_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_validity_ins_vel_ecef_z(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_ECEF_Y
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ecef_y(&self) -> bool {
        self.validity_ins_vel_ecef_y_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_ECEF_Y
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ecef_y_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_validity_ins_vel_ecef_y(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVelEcef2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVelEcef2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vel_ECEF_1
///
/// - Extended ID: 156794402 (0x9587e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVelEcef1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVelEcef1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587e22)});
    
    pub const INS_VEL_ECEF_X_MIN: f32 = -838_f32;
    pub const INS_VEL_ECEF_X_MAX: f32 = 838_f32;
    pub const ACCURACY_INS_VEL_ECEF_Z_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_ECEF_Z_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_VEL_ECEF_Y_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_ECEF_Y_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_VEL_ECEF_X_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_ECEF_X_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Vel_ECEF_1 from values
    pub fn new(ins_vel_ecef_x: f32, accuracy_ins_vel_ecef_z: u8, accuracy_ins_vel_ecef_y: u8, accuracy_ins_vel_ecef_x: u8, validity_ins_vel_ecef_x: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_vel_ecef_x(ins_vel_ecef_x)?;
        res.set_accuracy_ins_vel_ecef_z(accuracy_ins_vel_ecef_z)?;
        res.set_accuracy_ins_vel_ecef_y(accuracy_ins_vel_ecef_y)?;
        res.set_accuracy_ins_vel_ecef_x(accuracy_ins_vel_ecef_x)?;
        res.set_validity_ins_vel_ecef_x(validity_ins_vel_ecef_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Vel_ECEF_X
    ///
    /// ECEF X velocity.  The ECEF X axis originates from the Earth centre, and the positive X axis intersects the Earth surface at zero degrees latittude and zero degrees longitude (the intersection of the equator and the prime meridian).
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ecef_x(&self) -> f32 {
        self.ins_vel_ecef_x_raw()
    }
    
    /// Get raw value of INS_Vel_ECEF_X
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ecef_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_ins_vel_ecef_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_ECEF_Z
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_z(&self) -> u8 {
        self.accuracy_ins_vel_ecef_z_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_ECEF_Z
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_z_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_accuracy_ins_vel_ecef_z(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_ECEF_Y
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_y(&self) -> u8 {
        self.accuracy_ins_vel_ecef_y_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_ECEF_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_y_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_accuracy_ins_vel_ecef_y(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_ECEF_X
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_x(&self) -> u8 {
        self.accuracy_ins_vel_ecef_x_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_ECEF_X
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_ecef_x_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_accuracy_ins_vel_ecef_x(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_ECEF_X
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ecef_x(&self) -> bool {
        self.validity_ins_vel_ecef_x_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_ECEF_X
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ecef_x_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_validity_ins_vel_ecef_x(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVelEcef1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVelEcef1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vel_NED_2
///
/// - Extended ID: 156794146 (0x9587d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587d22)});
    
    pub const INS_VEL_NED_D_MIN: f32 = -838_f32;
    pub const INS_VEL_NED_D_MAX: f32 = 838_f32;
    pub const ACCURACY_INS_VEL_D_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_D_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Vel_NED_2 from values
    pub fn new(ins_vel_ned_d: f32, accuracy_ins_vel_d: u8, validity_ins_vel_ned_d: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_vel_ned_d(ins_vel_ned_d)?;
        res.set_accuracy_ins_vel_d(accuracy_ins_vel_d)?;
        res.set_validity_ins_vel_ned_d(validity_ins_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ned_d(&self) -> f32 {
        self.ins_vel_ned_d_raw()
    }
    
    /// Get raw value of INS_Vel_NED_D
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_NED_D
    #[inline(always)]
    pub fn set_ins_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_D
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_d(&self) -> u8 {
        self.accuracy_ins_vel_d_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_D
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_d_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_D
    #[inline(always)]
    pub fn set_accuracy_ins_vel_d(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_NED_D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ned_d(&self) -> bool {
        self.validity_ins_vel_ned_d_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ned_d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_NED_D
    #[inline(always)]
    pub fn set_validity_ins_vel_ned_d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Vel_NED_1
///
/// - Extended ID: 156793890 (0x9587c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsVelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsVelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587c22)});
    
    pub const INS_VEL_NED_E_MIN: f32 = -838_f32;
    pub const INS_VEL_NED_E_MAX: f32 = 838_f32;
    pub const INS_VEL_NED_N_MIN: f32 = -838_f32;
    pub const INS_VEL_NED_N_MAX: f32 = 838_f32;
    pub const ACCURACY_INS_VEL_NE_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_VEL_NE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Vel_NED_1 from values
    pub fn new(ins_vel_ned_e: f32, ins_vel_ned_n: f32, accuracy_ins_vel_ne: u8, validity_ins_vel_ned_e: bool, validity_ins_vel_ned_n: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_vel_ned_e(ins_vel_ned_e)?;
        res.set_ins_vel_ned_n(ins_vel_ned_n)?;
        res.set_accuracy_ins_vel_ne(accuracy_ins_vel_ne)?;
        res.set_validity_ins_vel_ned_e(validity_ins_vel_ned_e)?;
        res.set_validity_ins_vel_ned_n(validity_ins_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ned_e(&self) -> f32 {
        self.ins_vel_ned_e_raw()
    }
    
    /// Get raw value of INS_Vel_NED_E
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_NED_E
    #[inline(always)]
    pub fn set_ins_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// INS_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_vel_ned_n(&self) -> f32 {
        self.ins_vel_ned_n_raw()
    }
    
    /// Get raw value of INS_Vel_NED_N
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Vel_NED_N
    #[inline(always)]
    pub fn set_ins_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Vel_NE
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_vel_ne(&self) -> u8 {
        self.accuracy_ins_vel_ne_raw()
    }
    
    /// Get raw value of Accuracy_INS_Vel_NE
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_vel_ne_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Vel_NE
    #[inline(always)]
    pub fn set_accuracy_ins_vel_ne(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsVelNed1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_NED_E
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ned_e(&self) -> bool {
        self.validity_ins_vel_ned_e_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_NED_E
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ned_e_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_NED_E
    #[inline(always)]
    pub fn set_validity_ins_vel_ned_e(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Vel_NED_N
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_vel_ned_n(&self) -> bool {
        self.validity_ins_vel_ned_n_raw()
    }
    
    /// Get raw value of Validity_INS_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_vel_ned_n_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Vel_NED_N
    #[inline(always)]
    pub fn set_validity_ins_vel_ned_n(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsVelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsVelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Pos_ECEF_2
///
/// - Extended ID: 156791074 (0x9587122)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsPosEcef2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsPosEcef2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587122)});
    
    pub const INS_POS_ECEF_Z_MIN: f32 = -10000000_f32;
    pub const INS_POS_ECEF_Z_MAX: f32 = 10000000_f32;
    pub const INS_POS_ECEF_Y_MIN: f32 = -10000000_f32;
    pub const INS_POS_ECEF_Y_MAX: f32 = 10000000_f32;
    
    /// Construct new RT_SB_INS_Pos_ECEF_2 from values
    pub fn new(ins_pos_ecef_z: f32, ins_pos_ecef_y: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_pos_ecef_z(ins_pos_ecef_z)?;
        res.set_ins_pos_ecef_y(ins_pos_ecef_y)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Pos_ECEF_Z
    ///
    /// ECEF Z position.  The ECEF Z axis originates from the Earth centre, and the positive Z axis intersects the Earth surface at the North Pole.
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_ecef_z(&self) -> f32 {
        self.ins_pos_ecef_z_raw()
    }
    
    /// Get raw value of INS_Pos_ECEF_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_ecef_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_ins_pos_ecef_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// INS_Pos_ECEF_Y
    ///
    /// ECEF Y position.  The ECEF Y axis originates from the Earth centre, and the positive Y axis intersects the Earth surface at zero degrees latittude and 90 degrees longitude.
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_ecef_y(&self) -> f32 {
        self.ins_pos_ecef_y_raw()
    }
    
    /// Get raw value of INS_Pos_ECEF_Y
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_ecef_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_ins_pos_ecef_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsPosEcef2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsPosEcef2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Pos_ECEF_1
///
/// - Extended ID: 156790818 (0x9587022)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsPosEcef1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsPosEcef1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9587022)});
    
    pub const INS_POS_ECEF_X_MIN: f32 = -10000000_f32;
    pub const INS_POS_ECEF_X_MAX: f32 = 10000000_f32;
    pub const ACCURACY_INS_POS_ECEF_Z_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_ECEF_Z_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_POS_ECEF_Y_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_ECEF_Y_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_POS_ECEF_X_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_ECEF_X_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Pos_ECEF_1 from values
    pub fn new(ins_pos_ecef_x: f32, accuracy_ins_pos_ecef_z: u8, accuracy_ins_pos_ecef_y: u8, accuracy_ins_pos_ecef_x: u8, validity_ins_pos_ecef_z: bool, validity_ins_pos_ecef_y: bool, validity_ins_pos_ecef_x: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_pos_ecef_x(ins_pos_ecef_x)?;
        res.set_accuracy_ins_pos_ecef_z(accuracy_ins_pos_ecef_z)?;
        res.set_accuracy_ins_pos_ecef_y(accuracy_ins_pos_ecef_y)?;
        res.set_accuracy_ins_pos_ecef_x(accuracy_ins_pos_ecef_x)?;
        res.set_validity_ins_pos_ecef_z(validity_ins_pos_ecef_z)?;
        res.set_validity_ins_pos_ecef_y(validity_ins_pos_ecef_y)?;
        res.set_validity_ins_pos_ecef_x(validity_ins_pos_ecef_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Pos_ECEF_X
    ///
    /// ECEF X position.  The ECEF X axis originates from the Earth centre, and the positive X axis intersects the Earth surface at zero degrees latittude and zero degrees longitude (the intersection of the equator and the prime meridian).
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_ecef_x(&self) -> f32 {
        self.ins_pos_ecef_x_raw()
    }
    
    /// Get raw value of INS_Pos_ECEF_X
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_ecef_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_ins_pos_ecef_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_ECEF_Z
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_z(&self) -> u8 {
        self.accuracy_ins_pos_ecef_z_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_ECEF_Z
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_z_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_accuracy_ins_pos_ecef_z(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_ECEF_Y
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_y(&self) -> u8 {
        self.accuracy_ins_pos_ecef_y_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_ECEF_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_y_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_accuracy_ins_pos_ecef_y(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_ECEF_X
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_x(&self) -> u8 {
        self.accuracy_ins_pos_ecef_x_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_ECEF_X
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_ecef_x_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_accuracy_ins_pos_ecef_x(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_ECEF_Z
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_ecef_z(&self) -> bool {
        self.validity_ins_pos_ecef_z_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_ECEF_Z
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_ecef_z_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_validity_ins_pos_ecef_z(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_ECEF_Y
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_ecef_y(&self) -> bool {
        self.validity_ins_pos_ecef_y_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_ECEF_Y
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_ecef_y_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_validity_ins_pos_ecef_y(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_ECEF_X
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_ecef_x(&self) -> bool {
        self.validity_ins_pos_ecef_x_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_ECEF_X
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_ecef_x_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_validity_ins_pos_ecef_x(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsPosEcef1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsPosEcef1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Pos_LLH_2
///
/// - Extended ID: 156790562 (0x9586f22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsPosLlh2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsPosLlh2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9586f22)});
    
    pub const INS_POS_LLH_ALTITUDE_MIN: f32 = -1000_f32;
    pub const INS_POS_LLH_ALTITUDE_MAX: f32 = 100000_f32;
    pub const INS_POS_LLH_LONGITUDE_MIN: f32 = -180_f32;
    pub const INS_POS_LLH_LONGITUDE_MAX: f32 = 180_f32;
    
    /// Construct new RT_SB_INS_Pos_LLH_2 from values
    pub fn new(ins_pos_llh_altitude: f32, ins_pos_llh_longitude: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_pos_llh_altitude(ins_pos_llh_altitude)?;
        res.set_ins_pos_llh_longitude(ins_pos_llh_longitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Pos_LLH_Altitude
    ///
    /// - Min: -1000
    /// - Max: 100000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_llh_altitude(&self) -> f32 {
        self.ins_pos_llh_altitude_raw()
    }
    
    /// Get raw value of INS_Pos_LLH_Altitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_llh_altitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_ins_pos_llh_altitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -1000_f32 || 100000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// INS_Pos_LLH_Longitude
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_llh_longitude(&self) -> f32 {
        self.ins_pos_llh_longitude_raw()
    }
    
    /// Get raw value of INS_Pos_LLH_Longitude
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_llh_longitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_ins_pos_llh_longitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsPosLlh2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsPosLlh2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Pos_LLH_1
///
/// - Extended ID: 156790306 (0x9586e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsPosLlh1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsPosLlh1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9586e22)});
    
    pub const INS_POS_LLH_LATITUDE_MIN: f32 = -90_f32;
    pub const INS_POS_LLH_LATITUDE_MAX: f32 = 90_f32;
    pub const ACCURACY_INS_POS_LLH_ALTITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_LLH_ALTITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_POS_LLH_LONGITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_LLH_LONGITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_INS_POS_LLH_LATITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_POS_LLH_LATITUDE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Pos_LLH_1 from values
    pub fn new(ins_pos_llh_latitude: f32, accuracy_ins_pos_llh_altitude: u8, accuracy_ins_pos_llh_longitude: u8, accuracy_ins_pos_llh_latitude: u8, validity_ins_pos_llh_altitude: bool, validity_ins_pos_llh_longitude: bool, validity_ins_pos_llh_latitude: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_pos_llh_latitude(ins_pos_llh_latitude)?;
        res.set_accuracy_ins_pos_llh_altitude(accuracy_ins_pos_llh_altitude)?;
        res.set_accuracy_ins_pos_llh_longitude(accuracy_ins_pos_llh_longitude)?;
        res.set_accuracy_ins_pos_llh_latitude(accuracy_ins_pos_llh_latitude)?;
        res.set_validity_ins_pos_llh_altitude(validity_ins_pos_llh_altitude)?;
        res.set_validity_ins_pos_llh_longitude(validity_ins_pos_llh_longitude)?;
        res.set_validity_ins_pos_llh_latitude(validity_ins_pos_llh_latitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Pos_LLH_Latitude
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_pos_llh_latitude(&self) -> f32 {
        self.ins_pos_llh_latitude_raw()
    }
    
    /// Get raw value of INS_Pos_LLH_Latitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_pos_llh_latitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_ins_pos_llh_latitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_LLH_Altitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_altitude(&self) -> u8 {
        self.accuracy_ins_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_LLH_Altitude
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_altitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_accuracy_ins_pos_llh_altitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_LLH_Longitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_longitude(&self) -> u8 {
        self.accuracy_ins_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_LLH_Longitude
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_longitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_accuracy_ins_pos_llh_longitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Pos_LLH_Latitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_latitude(&self) -> u8 {
        self.accuracy_ins_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Accuracy_INS_Pos_LLH_Latitude
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_pos_llh_latitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_accuracy_ins_pos_llh_latitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_LLH_Altitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_llh_altitude(&self) -> bool {
        self.validity_ins_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_LLH_Altitude
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_llh_altitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_validity_ins_pos_llh_altitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_LLH_Longitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_llh_longitude(&self) -> bool {
        self.validity_ins_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_LLH_Longitude
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_llh_longitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_validity_ins_pos_llh_longitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Pos_LLH_Latitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_pos_llh_latitude(&self) -> bool {
        self.validity_ins_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Validity_INS_Pos_LLH_Latitude
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_pos_llh_latitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_validity_ins_pos_llh_latitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsPosLlh1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsPosLlh1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Heading_Gradient_2
///
/// - Extended ID: 156795170 (0x9588122)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsHeadingGradient2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsHeadingGradient2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9588122)});
    
    pub const INS_GRADIENT_MIN: f32 = -90_f32;
    pub const INS_GRADIENT_MAX: f32 = 90_f32;
    pub const ACCURACY_INS_GRADIENT_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_GRADIENT_MAX: u8 = 255_u8;
    pub const INS_HEADING_2_MIN: f32 = 0_f32;
    pub const INS_HEADING_2_MAX: f32 = 360_f32;
    pub const ACCURACY_INS_HEADING_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_HEADING_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Heading_Gradient_2 from values
    pub fn new(ins_gradient: f32, accuracy_ins_gradient: u8, ins_heading_2: f32, accuracy_ins_heading: u8, validity_ins_gradient: bool, validity_ins_heading: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_gradient(ins_gradient)?;
        res.set_accuracy_ins_gradient(accuracy_ins_gradient)?;
        res.set_ins_heading_2(ins_heading_2)?;
        res.set_accuracy_ins_heading(accuracy_ins_heading)?;
        res.set_validity_ins_gradient(validity_ins_gradient)?;
        res.set_validity_ins_heading(validity_ins_heading)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Gradient
    ///
    /// This is GPS gradient, i.e. the vertical direction that the vehicle is travelling, NOT pointing (pitch).
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_gradient(&self) -> f32 {
        self.ins_gradient_raw()
    }
    
    /// Get raw value of INS_Gradient
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_gradient_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Gradient
    #[inline(always)]
    pub fn set_ins_gradient(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Gradient
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_gradient(&self) -> u8 {
        self.accuracy_ins_gradient_raw()
    }
    
    /// Get raw value of Accuracy_INS_Gradient
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_gradient_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Gradient
    #[inline(always)]
    pub fn set_accuracy_ins_gradient(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// INS_Heading_2
    ///
    /// This is GPS heading in the range 0 - 360, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: 0
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_heading_2(&self) -> f32 {
        self.ins_heading_2_raw()
    }
    
    /// Get raw value of INS_Heading_2
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ins_heading_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Heading_2
    #[inline(always)]
    pub fn set_ins_heading_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Heading
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_heading(&self) -> u8 {
        self.accuracy_ins_heading_raw()
    }
    
    /// Get raw value of Accuracy_INS_Heading
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_heading_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Heading
    #[inline(always)]
    pub fn set_accuracy_ins_heading(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Gradient
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_gradient(&self) -> bool {
        self.validity_ins_gradient_raw()
    }
    
    /// Get raw value of Validity_INS_Gradient
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_gradient_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Gradient
    #[inline(always)]
    pub fn set_validity_ins_gradient(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Heading
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_heading(&self) -> bool {
        self.validity_ins_heading_raw()
    }
    
    /// Get raw value of Validity_INS_Heading
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_heading_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Heading
    #[inline(always)]
    pub fn set_validity_ins_heading(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsHeadingGradient2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsHeadingGradient2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Heading_Gradient
///
/// - Extended ID: 156794914 (0x9588022)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsHeadingGradient {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsHeadingGradient {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9588022)});
    
    pub const INS_GRADIENT_MIN: f32 = -90_f32;
    pub const INS_GRADIENT_MAX: f32 = 90_f32;
    pub const ACCURACY_INS_GRADIENT_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_GRADIENT_MAX: u8 = 255_u8;
    pub const INS_HEADING_MIN: f32 = -180_f32;
    pub const INS_HEADING_MAX: f32 = 180_f32;
    pub const ACCURACY_INS_HEADING_MIN: u8 = 0_u8;
    pub const ACCURACY_INS_HEADING_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Heading_Gradient from values
    pub fn new(ins_gradient: f32, accuracy_ins_gradient: u8, ins_heading: f32, accuracy_ins_heading: u8, validity_ins_gradient: bool, validity_ins_heading: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_gradient(ins_gradient)?;
        res.set_accuracy_ins_gradient(accuracy_ins_gradient)?;
        res.set_ins_heading(ins_heading)?;
        res.set_accuracy_ins_heading(accuracy_ins_heading)?;
        res.set_validity_ins_gradient(validity_ins_gradient)?;
        res.set_validity_ins_heading(validity_ins_heading)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Gradient
    ///
    /// This is GPS gradient, i.e. the vertical direction that the vehicle is travelling, NOT pointing (pitch).
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_gradient(&self) -> f32 {
        self.ins_gradient_raw()
    }
    
    /// Get raw value of INS_Gradient
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_gradient_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Gradient
    #[inline(always)]
    pub fn set_ins_gradient(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Gradient
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_gradient(&self) -> u8 {
        self.accuracy_ins_gradient_raw()
    }
    
    /// Get raw value of Accuracy_INS_Gradient
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_gradient_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Gradient
    #[inline(always)]
    pub fn set_accuracy_ins_gradient(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// INS_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_heading(&self) -> f32 {
        self.ins_heading_raw()
    }
    
    /// Get raw value of INS_Heading
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn ins_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of INS_Heading
    #[inline(always)]
    pub fn set_ins_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_INS_Heading
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_ins_heading(&self) -> u8 {
        self.accuracy_ins_heading_raw()
    }
    
    /// Get raw value of Accuracy_INS_Heading
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_ins_heading_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_INS_Heading
    #[inline(always)]
    pub fn set_accuracy_ins_heading(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsHeadingGradient::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Gradient
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_gradient(&self) -> bool {
        self.validity_ins_gradient_raw()
    }
    
    /// Get raw value of Validity_INS_Gradient
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_gradient_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Gradient
    #[inline(always)]
    pub fn set_validity_ins_gradient(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_INS_Heading
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_ins_heading(&self) -> bool {
        self.validity_ins_heading_raw()
    }
    
    /// Get raw value of Validity_INS_Heading
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_ins_heading_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_INS_Heading
    #[inline(always)]
    pub fn set_validity_ins_heading(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsHeadingGradient {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsHeadingGradient {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_INS_Status
///
/// - Extended ID: 156789794 (0x9586c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsStatus {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsStatus {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9586c22)});
    
    pub const INS_STATUS_MIN: u8 = 0_u8;
    pub const INS_STATUS_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Status from values
    pub fn new(ins_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_ins_status(ins_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// INS_Status
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn ins_status(&self) -> RtSbInsStatusInsStatus {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        match signal {
            2 => RtSbInsStatusInsStatus::Converged,
            1 => RtSbInsStatusInsStatus::Initialised,
            0 => RtSbInsStatusInsStatus::Uninitialised,
            _ => RtSbInsStatusInsStatus::_Other(self.ins_status_raw()),
        }
    }
    
    /// Get raw value of INS_Status
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn ins_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of INS_Status
    #[inline(always)]
    pub fn set_ins_status(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsStatus {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}
/// Defined values for INS_Status
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbInsStatusInsStatus {
    Converged,
    Initialised,
    Uninitialised,
    _Other(u8),
}

impl From<RtSbInsStatusInsStatus> for u8 {
    fn from(val: RtSbInsStatusInsStatus) -> u8 {
        match val {
            RtSbInsStatusInsStatus::Converged => 2,
            RtSbInsStatusInsStatus::Initialised => 1,
            RtSbInsStatusInsStatus::Uninitialised => 0,
            RtSbInsStatusInsStatus::_Other(x) => x,
        }
    }
}


/// RT_SB_INS_Attitude
///
/// - Extended ID: 156790050 (0x9586d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbInsAttitude {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbInsAttitude {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9586d22)});
    
    pub const ATTITUDE_ROLL_MIN: f32 = -360_f32;
    pub const ATTITUDE_ROLL_MAX: f32 = 360_f32;
    pub const ATTITUDE_PITCH_MIN: f32 = -360_f32;
    pub const ATTITUDE_PITCH_MAX: f32 = 360_f32;
    pub const ATTITUDE_YAW_MIN: f32 = -360_f32;
    pub const ATTITUDE_YAW_MAX: f32 = 360_f32;
    pub const ACCURACY_ATTITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_ATTITUDE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_INS_Attitude from values
    pub fn new(attitude_roll: f32, attitude_pitch: f32, attitude_yaw: f32, accuracy_attitude: u8, validity_roll: bool, validity_pitch: bool, validity_yaw: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_attitude_roll(attitude_roll)?;
        res.set_attitude_pitch(attitude_pitch)?;
        res.set_attitude_yaw(attitude_yaw)?;
        res.set_accuracy_attitude(accuracy_attitude)?;
        res.set_validity_roll(validity_roll)?;
        res.set_validity_pitch(validity_pitch)?;
        res.set_validity_yaw(validity_yaw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Attitude_Roll
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn attitude_roll(&self) -> f32 {
        self.attitude_roll_raw()
    }
    
    /// Get raw value of Attitude_Roll
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn attitude_roll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Attitude_Roll
    #[inline(always)]
    pub fn set_attitude_roll(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Attitude_Pitch
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn attitude_pitch(&self) -> f32 {
        self.attitude_pitch_raw()
    }
    
    /// Get raw value of Attitude_Pitch
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn attitude_pitch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Attitude_Pitch
    #[inline(always)]
    pub fn set_attitude_pitch(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Attitude_Yaw
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn attitude_yaw(&self) -> f32 {
        self.attitude_yaw_raw()
    }
    
    /// Get raw value of Attitude_Yaw
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn attitude_yaw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Attitude_Yaw
    #[inline(always)]
    pub fn set_attitude_yaw(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Attitude
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_attitude(&self) -> u8 {
        self.accuracy_attitude_raw()
    }
    
    /// Get raw value of Accuracy_Attitude
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_attitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Attitude
    #[inline(always)]
    pub fn set_accuracy_attitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbInsAttitude::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbInsAttitude::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Roll
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_roll(&self) -> RtSbInsAttitudeValidityRoll {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        match signal {
            1 => RtSbInsAttitudeValidityRoll::Valid,
            0 => RtSbInsAttitudeValidityRoll::Invalid,
            _ => RtSbInsAttitudeValidityRoll::_Other(self.validity_roll_raw()),
        }
    }
    
    /// Get raw value of Validity_Roll
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_roll_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Roll
    #[inline(always)]
    pub fn set_validity_roll(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Pitch
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_pitch(&self) -> RtSbInsAttitudeValidityPitch {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        match signal {
            1 => RtSbInsAttitudeValidityPitch::Valid,
            0 => RtSbInsAttitudeValidityPitch::Invalid,
            _ => RtSbInsAttitudeValidityPitch::_Other(self.validity_pitch_raw()),
        }
    }
    
    /// Get raw value of Validity_Pitch
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_pitch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Pitch
    #[inline(always)]
    pub fn set_validity_pitch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Yaw
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_yaw(&self) -> RtSbInsAttitudeValidityYaw {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        match signal {
            1 => RtSbInsAttitudeValidityYaw::Valid,
            0 => RtSbInsAttitudeValidityYaw::Invalid,
            _ => RtSbInsAttitudeValidityYaw::_Other(self.validity_yaw_raw()),
        }
    }
    
    /// Get raw value of Validity_Yaw
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_yaw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Yaw
    #[inline(always)]
    pub fn set_validity_yaw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbInsAttitude {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbInsAttitude {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}
/// Defined values for Validity_Roll
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbInsAttitudeValidityRoll {
    Valid,
    Invalid,
    _Other(bool),
}

impl From<RtSbInsAttitudeValidityRoll> for bool {
    fn from(val: RtSbInsAttitudeValidityRoll) -> bool {
        match val {
            RtSbInsAttitudeValidityRoll::Valid => true,
            RtSbInsAttitudeValidityRoll::Invalid => false,
            RtSbInsAttitudeValidityRoll::_Other(x) => x,
        }
    }
}

/// Defined values for Validity_Pitch
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbInsAttitudeValidityPitch {
    Valid,
    Invalid,
    _Other(bool),
}

impl From<RtSbInsAttitudeValidityPitch> for bool {
    fn from(val: RtSbInsAttitudeValidityPitch) -> bool {
        match val {
            RtSbInsAttitudeValidityPitch::Valid => true,
            RtSbInsAttitudeValidityPitch::Invalid => false,
            RtSbInsAttitudeValidityPitch::_Other(x) => x,
        }
    }
}

/// Defined values for Validity_Yaw
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbInsAttitudeValidityYaw {
    Valid,
    Invalid,
    _Other(bool),
}

impl From<RtSbInsAttitudeValidityYaw> for bool {
    fn from(val: RtSbInsAttitudeValidityYaw) -> bool {
        match val {
            RtSbInsAttitudeValidityYaw::Valid => true,
            RtSbInsAttitudeValidityYaw::Invalid => false,
            RtSbInsAttitudeValidityYaw::_Other(x) => x,
        }
    }
}


/// RT_SB_Output_Status
///
/// - Extended ID: 156724514 (0x9576d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbOutputStatus {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbOutputStatus {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9576d22)});
    
    pub const GPS_TIME_MIN: f32 = 0_f32;
    pub const GPS_TIME_MAX: f32 = 604800_f32;
    
    /// Construct new RT_SB_Output_Status from values
    pub fn new(gps_time: f32, status_trigger: bool, status_serial_output_2: bool, status_serial_output_1: bool, status_pulse_output: bool, status_analogue_4: bool, status_analogue_3: bool, status_analogue_2: bool, status_analogue_1: bool, validity_status_timestamp: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_time(gps_time)?;
        res.set_status_trigger(status_trigger)?;
        res.set_status_serial_output_2(status_serial_output_2)?;
        res.set_status_serial_output_1(status_serial_output_1)?;
        res.set_status_pulse_output(status_pulse_output)?;
        res.set_status_analogue_4(status_analogue_4)?;
        res.set_status_analogue_3(status_analogue_3)?;
        res.set_status_analogue_2(status_analogue_2)?;
        res.set_status_analogue_1(status_analogue_1)?;
        res.set_validity_status_timestamp(validity_status_timestamp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Time
    ///
    /// GPS time is the time in seconds since midnight GMT on Saturday night.
    ///
    /// - Min: 0
    /// - Max: 604800
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_time(&self) -> f32 {
        self.gps_time_raw()
    }
    
    /// Get raw value of GPS_Time
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Time
    #[inline(always)]
    pub fn set_gps_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 604800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbOutputStatus::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Status_Trigger
    ///
    /// Status of the trigger input
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_trigger(&self) -> RtSbOutputStatusStatusTrigger {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusTrigger::Active,
            0 => RtSbOutputStatusStatusTrigger::Inactive,
            _ => RtSbOutputStatusStatusTrigger::_Other(self.status_trigger_raw()),
        }
    }
    
    /// Get raw value of Status_Trigger
    ///
    /// - Start bit: 15
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_trigger_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[15..16].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Trigger
    #[inline(always)]
    pub fn set_status_trigger(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[15..16].store_le(value);
        Ok(())
    }
    
    /// Status_Serial_Output_2
    ///
    /// Status output of serial port 1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_serial_output_2(&self) -> RtSbOutputStatusStatusSerialOutput2 {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusSerialOutput2::Active,
            0 => RtSbOutputStatusStatusSerialOutput2::Inactive,
            _ => RtSbOutputStatusStatusSerialOutput2::_Other(self.status_serial_output_2_raw()),
        }
    }
    
    /// Get raw value of Status_Serial_Output_2
    ///
    /// - Start bit: 14
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_serial_output_2_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[14..15].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Serial_Output_2
    #[inline(always)]
    pub fn set_status_serial_output_2(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[14..15].store_le(value);
        Ok(())
    }
    
    /// Status_Serial_Output_1
    ///
    /// Status output of serial port 1
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_serial_output_1(&self) -> RtSbOutputStatusStatusSerialOutput1 {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusSerialOutput1::Active,
            0 => RtSbOutputStatusStatusSerialOutput1::Inactive,
            _ => RtSbOutputStatusStatusSerialOutput1::_Other(self.status_serial_output_1_raw()),
        }
    }
    
    /// Get raw value of Status_Serial_Output_1
    ///
    /// - Start bit: 13
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_serial_output_1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[13..14].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Serial_Output_1
    #[inline(always)]
    pub fn set_status_serial_output_1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[13..14].store_le(value);
        Ok(())
    }
    
    /// Status_Pulse_Output
    ///
    /// Pulse output activity status
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_pulse_output(&self) -> RtSbOutputStatusStatusPulseOutput {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusPulseOutput::Active,
            0 => RtSbOutputStatusStatusPulseOutput::Inactive,
            _ => RtSbOutputStatusStatusPulseOutput::_Other(self.status_pulse_output_raw()),
        }
    }
    
    /// Get raw value of Status_Pulse_Output
    ///
    /// - Start bit: 12
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_pulse_output_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[12..13].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Pulse_Output
    #[inline(always)]
    pub fn set_status_pulse_output(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[12..13].store_le(value);
        Ok(())
    }
    
    /// Status_Analogue_4
    ///
    /// Analogue output status for channel 4.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_analogue_4(&self) -> RtSbOutputStatusStatusAnalogue4 {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusAnalogue4::Active,
            0 => RtSbOutputStatusStatusAnalogue4::Inactive,
            _ => RtSbOutputStatusStatusAnalogue4::_Other(self.status_analogue_4_raw()),
        }
    }
    
    /// Get raw value of Status_Analogue_4
    ///
    /// - Start bit: 11
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_analogue_4_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[11..12].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Analogue_4
    #[inline(always)]
    pub fn set_status_analogue_4(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[11..12].store_le(value);
        Ok(())
    }
    
    /// Status_Analogue_3
    ///
    /// Analogue output status for channel 3.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_analogue_3(&self) -> RtSbOutputStatusStatusAnalogue3 {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusAnalogue3::Active,
            0 => RtSbOutputStatusStatusAnalogue3::Inactive,
            _ => RtSbOutputStatusStatusAnalogue3::_Other(self.status_analogue_3_raw()),
        }
    }
    
    /// Get raw value of Status_Analogue_3
    ///
    /// - Start bit: 10
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_analogue_3_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[10..11].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Analogue_3
    #[inline(always)]
    pub fn set_status_analogue_3(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[10..11].store_le(value);
        Ok(())
    }
    
    /// Status_Analogue_2
    ///
    /// Analogue output status for channel 1.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_analogue_2(&self) -> RtSbOutputStatusStatusAnalogue2 {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusAnalogue2::Active,
            0 => RtSbOutputStatusStatusAnalogue2::Inactive,
            _ => RtSbOutputStatusStatusAnalogue2::_Other(self.status_analogue_2_raw()),
        }
    }
    
    /// Get raw value of Status_Analogue_2
    ///
    /// - Start bit: 9
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_analogue_2_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[9..10].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Analogue_2
    #[inline(always)]
    pub fn set_status_analogue_2(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[9..10].store_le(value);
        Ok(())
    }
    
    /// Status_Analogue_1
    ///
    /// Analogue output status for channel 1.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn status_analogue_1(&self) -> RtSbOutputStatusStatusAnalogue1 {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        match signal {
            1 => RtSbOutputStatusStatusAnalogue1::Active,
            0 => RtSbOutputStatusStatusAnalogue1::Inactive,
            _ => RtSbOutputStatusStatusAnalogue1::_Other(self.status_analogue_1_raw()),
        }
    }
    
    /// Get raw value of Status_Analogue_1
    ///
    /// - Start bit: 8
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn status_analogue_1_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[8..9].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Status_Analogue_1
    #[inline(always)]
    pub fn set_status_analogue_1(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[8..9].store_le(value);
        Ok(())
    }
    
    /// Validity_Status_Timestamp
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_status_timestamp(&self) -> bool {
        self.validity_status_timestamp_raw()
    }
    
    /// Get raw value of Validity_Status_Timestamp
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_status_timestamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Status_Timestamp
    #[inline(always)]
    pub fn set_validity_status_timestamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbOutputStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbOutputStatus {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}
/// Defined values for Status_Trigger
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusTrigger {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusTrigger> for bool {
    fn from(val: RtSbOutputStatusStatusTrigger) -> bool {
        match val {
            RtSbOutputStatusStatusTrigger::Active => true,
            RtSbOutputStatusStatusTrigger::Inactive => false,
            RtSbOutputStatusStatusTrigger::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Serial_Output_2
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusSerialOutput2 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusSerialOutput2> for bool {
    fn from(val: RtSbOutputStatusStatusSerialOutput2) -> bool {
        match val {
            RtSbOutputStatusStatusSerialOutput2::Active => true,
            RtSbOutputStatusStatusSerialOutput2::Inactive => false,
            RtSbOutputStatusStatusSerialOutput2::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Serial_Output_1
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusSerialOutput1 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusSerialOutput1> for bool {
    fn from(val: RtSbOutputStatusStatusSerialOutput1) -> bool {
        match val {
            RtSbOutputStatusStatusSerialOutput1::Active => true,
            RtSbOutputStatusStatusSerialOutput1::Inactive => false,
            RtSbOutputStatusStatusSerialOutput1::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Pulse_Output
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusPulseOutput {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusPulseOutput> for bool {
    fn from(val: RtSbOutputStatusStatusPulseOutput) -> bool {
        match val {
            RtSbOutputStatusStatusPulseOutput::Active => true,
            RtSbOutputStatusStatusPulseOutput::Inactive => false,
            RtSbOutputStatusStatusPulseOutput::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Analogue_4
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusAnalogue4 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusAnalogue4> for bool {
    fn from(val: RtSbOutputStatusStatusAnalogue4) -> bool {
        match val {
            RtSbOutputStatusStatusAnalogue4::Active => true,
            RtSbOutputStatusStatusAnalogue4::Inactive => false,
            RtSbOutputStatusStatusAnalogue4::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Analogue_3
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusAnalogue3 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusAnalogue3> for bool {
    fn from(val: RtSbOutputStatusStatusAnalogue3) -> bool {
        match val {
            RtSbOutputStatusStatusAnalogue3::Active => true,
            RtSbOutputStatusStatusAnalogue3::Inactive => false,
            RtSbOutputStatusStatusAnalogue3::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Analogue_2
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusAnalogue2 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusAnalogue2> for bool {
    fn from(val: RtSbOutputStatusStatusAnalogue2) -> bool {
        match val {
            RtSbOutputStatusStatusAnalogue2::Active => true,
            RtSbOutputStatusStatusAnalogue2::Inactive => false,
            RtSbOutputStatusStatusAnalogue2::_Other(x) => x,
        }
    }
}

/// Defined values for Status_Analogue_1
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbOutputStatusStatusAnalogue1 {
    Active,
    Inactive,
    _Other(bool),
}

impl From<RtSbOutputStatusStatusAnalogue1> for bool {
    fn from(val: RtSbOutputStatusStatusAnalogue1) -> bool {
        match val {
            RtSbOutputStatusStatusAnalogue1::Active => true,
            RtSbOutputStatusStatusAnalogue1::Inactive => false,
            RtSbOutputStatusStatusAnalogue1::_Other(x) => x,
        }
    }
}


/// RT_SB_GPS_Heading_Gradient_2
///
/// - Extended ID: 156664354 (0x9568222)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsHeadingGradient2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsHeadingGradient2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9568222)});
    
    pub const GPS_GRADIENT_MIN: f32 = -90_f32;
    pub const GPS_GRADIENT_MAX: f32 = 90_f32;
    pub const ACCURACY_GPS_GRADIENT_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_GRADIENT_MAX: u8 = 255_u8;
    pub const GPS_HEADING_2_MIN: f32 = 0_f32;
    pub const GPS_HEADING_2_MAX: f32 = 360_f32;
    pub const ACCURACY_GPS_HEADING_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_HEADING_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Heading_Gradient_2 from values
    pub fn new(gps_gradient: f32, accuracy_gps_gradient: u8, gps_heading_2: f32, accuracy_gps_heading: u8, validity_gps_gradient: bool, validity_gps_heading: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_gradient(gps_gradient)?;
        res.set_accuracy_gps_gradient(accuracy_gps_gradient)?;
        res.set_gps_heading_2(gps_heading_2)?;
        res.set_accuracy_gps_heading(accuracy_gps_heading)?;
        res.set_validity_gps_gradient(validity_gps_gradient)?;
        res.set_validity_gps_heading(validity_gps_heading)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Gradient
    ///
    /// This is GPS gradient, i.e. the vertical direction that the vehicle is travelling, NOT pointing (pitch).
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_gradient(&self) -> f32 {
        self.gps_gradient_raw()
    }
    
    /// Get raw value of GPS_Gradient
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_gradient_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Gradient
    #[inline(always)]
    pub fn set_gps_gradient(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Gradient
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_gradient(&self) -> u8 {
        self.accuracy_gps_gradient_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Gradient
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_gradient_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Gradient
    #[inline(always)]
    pub fn set_accuracy_gps_gradient(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// GPS_Heading_2
    ///
    /// This is GPS heading in the range 0 - 360, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: 0
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_heading_2(&self) -> f32 {
        self.gps_heading_2_raw()
    }
    
    /// Get raw value of GPS_Heading_2
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_heading_2_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<u16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Heading_2
    #[inline(always)]
    pub fn set_gps_heading_2(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Heading
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_heading(&self) -> u8 {
        self.accuracy_gps_heading_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Heading
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_heading_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Heading
    #[inline(always)]
    pub fn set_accuracy_gps_heading(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Gradient
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_gradient(&self) -> bool {
        self.validity_gps_gradient_raw()
    }
    
    /// Get raw value of Validity_GPS_Gradient
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_gradient_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Gradient
    #[inline(always)]
    pub fn set_validity_gps_gradient(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Heading
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_heading(&self) -> bool {
        self.validity_gps_heading_raw()
    }
    
    /// Get raw value of Validity_GPS_Heading
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_heading_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Heading
    #[inline(always)]
    pub fn set_validity_gps_heading(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsHeadingGradient2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsHeadingGradient2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Cumulative_Distance_2
///
/// - Extended ID: 155880738 (0x94a8d22)
/// - Size: 8 bytes
///
/// This cumulative distance calculation is updated when the trigger is active.
#[derive(Clone, Copy)]
pub struct RtSbCumulativeDistance2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbCumulativeDistance2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a8d22)});
    
    pub const CUMULATIVE_DISTANCE_MIN: f32 = 0_f32;
    pub const CUMULATIVE_DISTANCE_MAX: f32 = 4294967_f32;
    pub const CUMULATIVE_TIME_MIN: f32 = 0_f32;
    pub const CUMULATIVE_TIME_MAX: f32 = 167772_f32;
    
    /// Construct new RT_SB_Cumulative_Distance_2 from values
    pub fn new(cumulative_distance: f32, cumulative_time: f32, validity_cumulative_distance: bool, validity_cumulative_time: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cumulative_distance(cumulative_distance)?;
        res.set_cumulative_time(cumulative_time)?;
        res.set_validity_cumulative_distance(validity_cumulative_distance)?;
        res.set_validity_cumulative_time(validity_cumulative_time)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Cumulative_Distance
    ///
    /// - Min: 0
    /// - Max: 4294967
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cumulative_distance(&self) -> f32 {
        self.cumulative_distance_raw()
    }
    
    /// Get raw value of Cumulative_Distance
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cumulative_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Cumulative_Distance
    #[inline(always)]
    pub fn set_cumulative_distance(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 4294967_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbCumulativeDistance2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Cumulative_Time
    ///
    /// - Min: 0
    /// - Max: 167772
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cumulative_time(&self) -> f32 {
        self.cumulative_time_raw()
    }
    
    /// Get raw value of Cumulative_Time
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cumulative_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<u32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Cumulative_Time
    #[inline(always)]
    pub fn set_cumulative_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 167772_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbCumulativeDistance2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_Cumulative_Distance
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_cumulative_distance(&self) -> bool {
        self.validity_cumulative_distance_raw()
    }
    
    /// Get raw value of Validity_Cumulative_Distance
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_cumulative_distance_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Cumulative_Distance
    #[inline(always)]
    pub fn set_validity_cumulative_distance(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Cumulative_Time
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_cumulative_time(&self) -> bool {
        self.validity_cumulative_time_raw()
    }
    
    /// Get raw value of Validity_Cumulative_Time
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_cumulative_time_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Cumulative_Time
    #[inline(always)]
    pub fn set_validity_cumulative_time(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbCumulativeDistance2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbCumulativeDistance2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Cumulative_Distance_1
///
/// - Extended ID: 155880482 (0x94a8c22)
/// - Size: 8 bytes
///
/// This cumulative distance calculation is updated continuously once the first good GPS lock is obtained.
#[derive(Clone, Copy)]
pub struct RtSbCumulativeDistance1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbCumulativeDistance1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a8c22)});
    
    pub const CUMULATIVE_DISTANCE_MIN: f32 = 0_f32;
    pub const CUMULATIVE_DISTANCE_MAX: f32 = 4294967_f32;
    pub const CUMULATIVE_TIME_MIN: f32 = 0_f32;
    pub const CUMULATIVE_TIME_MAX: f32 = 167772_f32;
    
    /// Construct new RT_SB_Cumulative_Distance_1 from values
    pub fn new(cumulative_distance: f32, cumulative_time: f32, validity_cumulative_distance: bool, validity_cumulative_time: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_cumulative_distance(cumulative_distance)?;
        res.set_cumulative_time(cumulative_time)?;
        res.set_validity_cumulative_distance(validity_cumulative_distance)?;
        res.set_validity_cumulative_time(validity_cumulative_time)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Cumulative_Distance
    ///
    /// - Min: 0
    /// - Max: 4294967
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cumulative_distance(&self) -> f32 {
        self.cumulative_distance_raw()
    }
    
    /// Get raw value of Cumulative_Distance
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cumulative_distance_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Cumulative_Distance
    #[inline(always)]
    pub fn set_cumulative_distance(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 4294967_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbCumulativeDistance1::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Cumulative_Time
    ///
    /// - Min: 0
    /// - Max: 167772
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn cumulative_time(&self) -> f32 {
        self.cumulative_time_raw()
    }
    
    /// Get raw value of Cumulative_Time
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn cumulative_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<u32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Cumulative_Time
    #[inline(always)]
    pub fn set_cumulative_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 167772_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbCumulativeDistance1::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_Cumulative_Distance
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_cumulative_distance(&self) -> bool {
        self.validity_cumulative_distance_raw()
    }
    
    /// Get raw value of Validity_Cumulative_Distance
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_cumulative_distance_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Cumulative_Distance
    #[inline(always)]
    pub fn set_validity_cumulative_distance(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Cumulative_Time
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_cumulative_time(&self) -> bool {
        self.validity_cumulative_time_raw()
    }
    
    /// Get raw value of Validity_Cumulative_Time
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_cumulative_time_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Cumulative_Time
    #[inline(always)]
    pub fn set_validity_cumulative_time(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbCumulativeDistance1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbCumulativeDistance1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Trigger_Timestamp
///
/// - Extended ID: 156724258 (0x9576c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbTriggerTimestamp {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbTriggerTimestamp {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9576c22)});
    
    pub const GPS_HIGH_RESOLUTION_TIME_MIN: f32 = 0_f32;
    pub const GPS_HIGH_RESOLUTION_TIME_MAX: f32 = 604800_f32;
    pub const TRIGGER_NUMBER_MIN: u8 = 0_u8;
    pub const TRIGGER_NUMBER_MAX: u8 = 128_u8;
    pub const ACCURACY_TRIGGER_TIMESTAMP_MIN: u8 = 0_u8;
    pub const ACCURACY_TRIGGER_TIMESTAMP_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_Trigger_Timestamp from values
    pub fn new(gps_high_resolution_time: f32, trigger_timestamp_type: bool, trigger_number: u8, accuracy_trigger_timestamp: u8, validity_trigger_timestamp: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_high_resolution_time(gps_high_resolution_time)?;
        res.set_trigger_timestamp_type(trigger_timestamp_type)?;
        res.set_trigger_number(trigger_number)?;
        res.set_accuracy_trigger_timestamp(accuracy_trigger_timestamp)?;
        res.set_validity_trigger_timestamp(validity_trigger_timestamp)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_High_Resolution_Time
    ///
    /// GPS time of week to micro-second resolution.
    ///
    /// - Min: 0
    /// - Max: 604800
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_high_resolution_time(&self) -> f32 {
        self.gps_high_resolution_time_raw()
    }
    
    /// Get raw value of GPS_High_Resolution_Time
    ///
    /// - Start bit: 24
    /// - Signal size: 40 bits
    /// - Factor: 0.000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_high_resolution_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[24..64].load_le::<u64>();
        
        let factor = 0.000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_High_Resolution_Time
    #[inline(always)]
    pub fn set_gps_high_resolution_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 604800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTriggerTimestamp::MESSAGE_ID });
        }
        let factor = 0.000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u64;
        
        self.raw.view_bits_mut::<Lsb0>()[24..64].store_le(value);
        Ok(())
    }
    
    /// Trigger_Timestamp_Type
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trigger_timestamp_type(&self) -> RtSbTriggerTimestampTriggerTimestampType {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        match signal {
            1 => RtSbTriggerTimestampTriggerTimestampType::RisingEdge,
            0 => RtSbTriggerTimestampTriggerTimestampType::FallingEdge,
            _ => RtSbTriggerTimestampTriggerTimestampType::_Other(self.trigger_timestamp_type_raw()),
        }
    }
    
    /// Get raw value of Trigger_Timestamp_Type
    ///
    /// - Start bit: 23
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trigger_timestamp_type_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[23..24].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Trigger_Timestamp_Type
    #[inline(always)]
    pub fn set_trigger_timestamp_type(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[23..24].store_le(value);
        Ok(())
    }
    
    /// Trigger_Number
    ///
    /// This is the ID of the trigger that generated the event, as marked on the case of the logger
    ///
    /// - Min: 0
    /// - Max: 128
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn trigger_number(&self) -> u8 {
        self.trigger_number_raw()
    }
    
    /// Get raw value of Trigger_Number
    ///
    /// - Start bit: 16
    /// - Signal size: 7 bits
    /// - Factor: 1
    /// - Offset: 1
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn trigger_number_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..23].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(1)
    }
    
    /// Set value of Trigger_Number
    #[inline(always)]
    pub fn set_trigger_number(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 128_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTriggerTimestamp::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(1)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbTriggerTimestamp::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..23].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Trigger_Timestamp
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_trigger_timestamp(&self) -> u8 {
        self.accuracy_trigger_timestamp_raw()
    }
    
    /// Get raw value of Accuracy_Trigger_Timestamp
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_trigger_timestamp_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Trigger_Timestamp
    #[inline(always)]
    pub fn set_accuracy_trigger_timestamp(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbTriggerTimestamp::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbTriggerTimestamp::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Trigger_Timestamp
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_trigger_timestamp(&self) -> bool {
        self.validity_trigger_timestamp_raw()
    }
    
    /// Get raw value of Validity_Trigger_Timestamp
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_trigger_timestamp_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Trigger_Timestamp
    #[inline(always)]
    pub fn set_validity_trigger_timestamp(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbTriggerTimestamp {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbTriggerTimestamp {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}
/// Defined values for Trigger_Timestamp_Type
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbTriggerTimestampTriggerTimestampType {
    RisingEdge,
    FallingEdge,
    _Other(bool),
}

impl From<RtSbTriggerTimestampTriggerTimestampType> for bool {
    fn from(val: RtSbTriggerTimestampTriggerTimestampType) -> bool {
        match val {
            RtSbTriggerTimestampTriggerTimestampType::RisingEdge => true,
            RtSbTriggerTimestampTriggerTimestampType::FallingEdge => false,
            RtSbTriggerTimestampTriggerTimestampType::_Other(x) => x,
        }
    }
}


/// RT_IMU06_Gyro_Rates
///
/// - Extended ID: 155872545 (0x94a6d21)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtImu06GyroRates {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtImu06GyroRates {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a6d21)});
    
    pub const GYRO_RATE_ROLL_MIN: f32 = -327_f32;
    pub const GYRO_RATE_ROLL_MAX: f32 = 327_f32;
    pub const GYRO_RATE_PITCH_MIN: f32 = -327_f32;
    pub const GYRO_RATE_PITCH_MAX: f32 = 327_f32;
    pub const GYRO_RATE_YAW_MIN: f32 = -327_f32;
    pub const GYRO_RATE_YAW_MAX: f32 = 327_f32;
    pub const ACCURACY_GYRO_RATES_MIN: u8 = 0_u8;
    pub const ACCURACY_GYRO_RATES_MAX: u8 = 0_u8;
    
    /// Construct new RT_IMU06_Gyro_Rates from values
    pub fn new(gyro_rate_roll: f32, gyro_rate_pitch: f32, gyro_rate_yaw: f32, accuracy_gyro_rates: u8, validity_gyro_rate_roll: bool, validity_gyro_rate_pitch: bool, validity_gyro_rate_yaw: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gyro_rate_roll(gyro_rate_roll)?;
        res.set_gyro_rate_pitch(gyro_rate_pitch)?;
        res.set_gyro_rate_yaw(gyro_rate_yaw)?;
        res.set_accuracy_gyro_rates(accuracy_gyro_rates)?;
        res.set_validity_gyro_rate_roll(validity_gyro_rate_roll)?;
        res.set_validity_gyro_rate_pitch(validity_gyro_rate_pitch)?;
        res.set_validity_gyro_rate_yaw(validity_gyro_rate_yaw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Gyro_Rate_Roll
    ///
    /// Roll rate is positive for clockwise rotation when looking at the rear of the vehicle from behind the vehicle.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_roll(&self) -> f32 {
        self.gyro_rate_roll_raw()
    }
    
    /// Get raw value of Gyro_Rate_Roll
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_roll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Roll
    #[inline(always)]
    pub fn set_gyro_rate_roll(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06GyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Gyro_Rate_Pitch
    ///
    /// Pitch rate is positive for clockwise rotation when looking at the left hand side of the vehicle from the left of the vehicle.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_pitch(&self) -> f32 {
        self.gyro_rate_pitch_raw()
    }
    
    /// Get raw value of Gyro_Rate_Pitch
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_pitch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Pitch
    #[inline(always)]
    pub fn set_gyro_rate_pitch(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06GyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Gyro_Rate_Yaw
    ///
    /// Yaw rate is positive for clockwise rotation when looking down on the vehicle from above.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_yaw(&self) -> f32 {
        self.gyro_rate_yaw_raw()
    }
    
    /// Get raw value of Gyro_Rate_Yaw
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_yaw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Yaw
    #[inline(always)]
    pub fn set_gyro_rate_yaw(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06GyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Gyro_Rates
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gyro_rates(&self) -> u8 {
        self.accuracy_gyro_rates_raw()
    }
    
    /// Get raw value of Accuracy_Gyro_Rates
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gyro_rates_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Gyro_Rates
    #[inline(always)]
    pub fn set_accuracy_gyro_rates(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06GyroRates::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtImu06GyroRates::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Roll
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_roll(&self) -> bool {
        self.validity_gyro_rate_roll_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Roll
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_roll_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Roll
    #[inline(always)]
    pub fn set_validity_gyro_rate_roll(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Pitch
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_pitch(&self) -> bool {
        self.validity_gyro_rate_pitch_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Pitch
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_pitch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Pitch
    #[inline(always)]
    pub fn set_validity_gyro_rate_pitch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Yaw
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_yaw(&self) -> bool {
        self.validity_gyro_rate_yaw_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Yaw
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_yaw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Yaw
    #[inline(always)]
    pub fn set_validity_gyro_rate_yaw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtImu06GyroRates {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtImu06GyroRates {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_IMU06_Accel
///
/// - Extended ID: 155872289 (0x94a6c21)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtImu06Accel {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtImu06Accel {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a6c21)});
    
    pub const ACCEL_VERTICAL_MIN: f32 = -65_f32;
    pub const ACCEL_VERTICAL_MAX: f32 = 65_f32;
    pub const ACCEL_LATERAL_MIN: f32 = -65_f32;
    pub const ACCEL_LATERAL_MAX: f32 = 65_f32;
    pub const ACCEL_LONGITUDINAL_MIN: f32 = -65_f32;
    pub const ACCEL_LONGITUDINAL_MAX: f32 = 65_f32;
    pub const ACCURACY_ACCEL_MIN: u8 = 0_u8;
    pub const ACCURACY_ACCEL_MAX: u8 = 255_u8;
    
    /// Construct new RT_IMU06_Accel from values
    pub fn new(accel_vertical: f32, accel_lateral: f32, accel_longitudinal: f32, accuracy_accel: u8, validity_accel_vertical: bool, validity_accel_lateral: bool, validity_accel_longitudinal: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_accel_vertical(accel_vertical)?;
        res.set_accel_lateral(accel_lateral)?;
        res.set_accel_longitudinal(accel_longitudinal)?;
        res.set_accuracy_accel(accuracy_accel)?;
        res.set_validity_accel_vertical(validity_accel_vertical)?;
        res.set_validity_accel_lateral(validity_accel_lateral)?;
        res.set_validity_accel_longitudinal(validity_accel_longitudinal)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Accel_Vertical
    ///
    /// Vertical acceleration.  This is positive when the vehicle accelerates in an upwards direction, e.g. when travelling through a dip.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_vertical(&self) -> f32 {
        self.accel_vertical_raw()
    }
    
    /// Get raw value of Accel_Vertical
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_vertical_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Vertical
    #[inline(always)]
    pub fn set_accel_vertical(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Accel_Lateral
    ///
    /// Lateral acceleration.  This is positive when the vehicle accelerates towards the right, e.g. when cornering around a right-hand bend.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_lateral(&self) -> f32 {
        self.accel_lateral_raw()
    }
    
    /// Get raw value of Accel_Lateral
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_lateral_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Lateral
    #[inline(always)]
    pub fn set_accel_lateral(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Accel_Longitudinal
    ///
    /// Longitudinal acceleration.  This is positive when the vehicle accelerates in a forwards direction.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_longitudinal(&self) -> f32 {
        self.accel_longitudinal_raw()
    }
    
    /// Get raw value of Accel_Longitudinal
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_longitudinal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Longitudinal
    #[inline(always)]
    pub fn set_accel_longitudinal(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06Accel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Accel
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_accel(&self) -> u8 {
        self.accuracy_accel_raw()
    }
    
    /// Get raw value of Accuracy_Accel
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_accel_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Accel
    #[inline(always)]
    pub fn set_accuracy_accel(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtImu06Accel::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtImu06Accel::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Vertical
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_vertical(&self) -> bool {
        self.validity_accel_vertical_raw()
    }
    
    /// Get raw value of Validity_Accel_Vertical
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_vertical_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Vertical
    #[inline(always)]
    pub fn set_validity_accel_vertical(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Lateral
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_lateral(&self) -> bool {
        self.validity_accel_lateral_raw()
    }
    
    /// Get raw value of Validity_Accel_Lateral
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_lateral_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Lateral
    #[inline(always)]
    pub fn set_validity_accel_lateral(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Longitudinal
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_longitudinal(&self) -> bool {
        self.validity_accel_longitudinal_raw()
    }
    
    /// Get raw value of Validity_Accel_Longitudinal
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_longitudinal_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Longitudinal
    #[inline(always)]
    pub fn set_validity_accel_longitudinal(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtImu06Accel {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtImu06Accel {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Speed
///
/// - Extended ID: 155876386 (0x94a7c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbSpeed {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbSpeed {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a7c22)});
    
    pub const SPEED_MIN: f32 = -20000_f32;
    pub const SPEED_MAX: f32 = 20000_f32;
    pub const ACCURACY_SPEED_MIN: u8 = 0_u8;
    pub const ACCURACY_SPEED_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_Speed from values
    pub fn new(speed: f32, accuracy_speed: u8, validity_speed: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_speed(speed)?;
        res.set_accuracy_speed(accuracy_speed)?;
        res.set_validity_speed(validity_speed)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Speed
    ///
    /// - Min: -20000
    /// - Max: 20000
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn speed(&self) -> f32 {
        self.speed_raw()
    }
    
    /// Get raw value of Speed
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 0.00001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn speed_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..48].load_le::<i32>();
        
        let factor = 0.00001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Speed
    #[inline(always)]
    pub fn set_speed(&mut self, value: f32) -> Result<(), CanError> {
        if value < -20000_f32 || 20000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbSpeed::MESSAGE_ID });
        }
        let factor = 0.00001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..48].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Speed
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_speed(&self) -> u8 {
        self.accuracy_speed_raw()
    }
    
    /// Get raw value of Accuracy_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Speed
    #[inline(always)]
    pub fn set_accuracy_speed(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbSpeed::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbSpeed::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Speed
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_speed(&self) -> bool {
        self.validity_speed_raw()
    }
    
    /// Get raw value of Validity_Speed
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_speed_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Speed
    #[inline(always)]
    pub fn set_validity_speed(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbSpeed {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbSpeed {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_RTK_Slip
///
/// - Extended ID: 156667170 (0x9568d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbRtkSlip {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbRtkSlip {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9568d22)});
    
    pub const RTK_BASELINE_MIN: u16 = 0_u16;
    pub const RTK_BASELINE_MAX: u16 = 65535_u16;
    pub const RTK_SQUAT_MIN: f32 = -360_f32;
    pub const RTK_SQUAT_MAX: f32 = 360_f32;
    pub const RTK_SLIP_MIN: f32 = -360_f32;
    pub const RTK_SLIP_MAX: f32 = 360_f32;
    pub const ACCURACY_RTK_BASELINE_MIN: u8 = 0_u8;
    pub const ACCURACY_RTK_BASELINE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_RTK_Slip from values
    pub fn new(rtk_baseline: u16, rtk_squat: f32, rtk_slip: f32, accuracy_rtk_baseline: u8, validity_rtk_baseline: bool, validity_rtk_squat: bool, validity_rtk_slip: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rtk_baseline(rtk_baseline)?;
        res.set_rtk_squat(rtk_squat)?;
        res.set_rtk_slip(rtk_slip)?;
        res.set_accuracy_rtk_baseline(accuracy_rtk_baseline)?;
        res.set_validity_rtk_baseline(validity_rtk_baseline)?;
        res.set_validity_rtk_squat(validity_rtk_squat)?;
        res.set_validity_rtk_slip(validity_rtk_slip)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// RTK_Baseline
    ///
    /// This is the estimated baseline length calculated by the RTK solution.
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: "mm"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_baseline(&self) -> u16 {
        self.rtk_baseline_raw()
    }
    
    /// Get raw value of RTK_Baseline
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rtk_baseline_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        let factor = 1;
        u16::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of RTK_Baseline
    #[inline(always)]
    pub fn set_rtk_baseline(&mut self, value: u16) -> Result<(), CanError> {
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID })?;
        let value = (value / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// RTK_Squat
    ///
    /// Squat is defined as the difference between pitch and gradient.
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_squat(&self) -> f32 {
        self.rtk_squat_raw()
    }
    
    /// Get raw value of RTK_Squat
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rtk_squat_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RTK_Squat
    #[inline(always)]
    pub fn set_rtk_squat(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// RTK_Slip
    ///
    /// Slip is defined as the difference between yaw and heading.
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_slip(&self) -> f32 {
        self.rtk_slip_raw()
    }
    
    /// Get raw value of RTK_Slip
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rtk_slip_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RTK_Slip
    #[inline(always)]
    pub fn set_rtk_slip(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_RTK_Baseline
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_rtk_baseline(&self) -> u8 {
        self.accuracy_rtk_baseline_raw()
    }
    
    /// Get raw value of Accuracy_RTK_Baseline
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_rtk_baseline_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_RTK_Baseline
    #[inline(always)]
    pub fn set_accuracy_rtk_baseline(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbRtkSlip::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Baseline
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_baseline(&self) -> bool {
        self.validity_rtk_baseline_raw()
    }
    
    /// Get raw value of Validity_RTK_Baseline
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_baseline_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Baseline
    #[inline(always)]
    pub fn set_validity_rtk_baseline(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Squat
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_squat(&self) -> bool {
        self.validity_rtk_squat_raw()
    }
    
    /// Get raw value of Validity_RTK_Squat
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_squat_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Squat
    #[inline(always)]
    pub fn set_validity_rtk_squat(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Slip
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_slip(&self) -> bool {
        self.validity_rtk_slip_raw()
    }
    
    /// Get raw value of Validity_RTK_Slip
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_slip_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Slip
    #[inline(always)]
    pub fn set_validity_rtk_slip(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbRtkSlip {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbRtkSlip {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_RTK_Attitude
///
/// - Extended ID: 156666914 (0x9568c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbRtkAttitude {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbRtkAttitude {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9568c22)});
    
    pub const RTK_ATTITUDE_ROLL_MIN: f32 = -90_f32;
    pub const RTK_ATTITUDE_ROLL_MAX: f32 = 90_f32;
    pub const RTK_ATTITUDE_PITCH_MIN: f32 = -90_f32;
    pub const RTK_ATTITUDE_PITCH_MAX: f32 = 90_f32;
    pub const RTK_ATTITUDE_YAW_MIN: f32 = -360_f32;
    pub const RTK_ATTITUDE_YAW_MAX: f32 = 360_f32;
    pub const ACCURACY_RTK_ATTITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_RTK_ATTITUDE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_RTK_Attitude from values
    pub fn new(rtk_attitude_roll: f32, rtk_attitude_pitch: f32, rtk_attitude_yaw: f32, accuracy_rtk_attitude: u8, validity_rtk_roll: bool, validity_rtk_pitch: bool, validity_rtk_yaw: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rtk_attitude_roll(rtk_attitude_roll)?;
        res.set_rtk_attitude_pitch(rtk_attitude_pitch)?;
        res.set_rtk_attitude_yaw(rtk_attitude_yaw)?;
        res.set_accuracy_rtk_attitude(accuracy_rtk_attitude)?;
        res.set_validity_rtk_roll(validity_rtk_roll)?;
        res.set_validity_rtk_pitch(validity_rtk_pitch)?;
        res.set_validity_rtk_yaw(validity_rtk_yaw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// RTK_Attitude_Roll
    ///
    /// RTK attitude is determined from the MB-RTK solution only.  Roll is positive for a clockwise rotational displacement relative to the local horizontal plane when looking at the vehicle from the rear of it.
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_attitude_roll(&self) -> f32 {
        self.rtk_attitude_roll_raw()
    }
    
    /// Get raw value of RTK_Attitude_Roll
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rtk_attitude_roll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RTK_Attitude_Roll
    #[inline(always)]
    pub fn set_rtk_attitude_roll(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// RTK_Attitude_Pitch
    ///
    /// RTK attitude is determined from the MB-RTK solution only.  Pitch is positive for a clockwise rotational displacement from the local horizontal plane when looking at the vehicle from the left hand side of it.
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_attitude_pitch(&self) -> f32 {
        self.rtk_attitude_pitch_raw()
    }
    
    /// Get raw value of RTK_Attitude_Pitch
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rtk_attitude_pitch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RTK_Attitude_Pitch
    #[inline(always)]
    pub fn set_rtk_attitude_pitch(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// RTK_Attitude_Yaw
    ///
    /// RTK attitude is determined from the MB-RTK solution only.  Yaw is positive for a clockwise rotational displacement from due North, looking down on the vehicle from above.
    ///
    /// - Min: -360
    /// - Max: 360
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_attitude_yaw(&self) -> f32 {
        self.rtk_attitude_yaw_raw()
    }
    
    /// Get raw value of RTK_Attitude_Yaw
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn rtk_attitude_yaw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of RTK_Attitude_Yaw
    #[inline(always)]
    pub fn set_rtk_attitude_yaw(&mut self, value: f32) -> Result<(), CanError> {
        if value < -360_f32 || 360_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkAttitude::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_RTK_Attitude
    ///
    /// Note that RTK yaw is typically up to about 4 times more accurate than RTK pitch or roll.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_rtk_attitude(&self) -> u8 {
        self.accuracy_rtk_attitude_raw()
    }
    
    /// Get raw value of Accuracy_RTK_Attitude
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_rtk_attitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_RTK_Attitude
    #[inline(always)]
    pub fn set_accuracy_rtk_attitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbRtkAttitude::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbRtkAttitude::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Roll
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_roll(&self) -> bool {
        self.validity_rtk_roll_raw()
    }
    
    /// Get raw value of Validity_RTK_Roll
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_roll_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Roll
    #[inline(always)]
    pub fn set_validity_rtk_roll(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Pitch
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_pitch(&self) -> bool {
        self.validity_rtk_pitch_raw()
    }
    
    /// Get raw value of Validity_RTK_Pitch
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_pitch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Pitch
    #[inline(always)]
    pub fn set_validity_rtk_pitch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_RTK_Yaw
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_rtk_yaw(&self) -> bool {
        self.validity_rtk_yaw_raw()
    }
    
    /// Get raw value of Validity_RTK_Yaw
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_rtk_yaw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_RTK_Yaw
    #[inline(always)]
    pub fn set_validity_rtk_yaw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbRtkAttitude {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbRtkAttitude {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Mcycle_Lean
///
/// - Extended ID: 156671010 (0x9569c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsMcycleLean {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsMcycleLean {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9569c22)});
    
    pub const GPS_MCYCLE_LEAN_ANGLE_MIN: f32 = -90_f32;
    pub const GPS_MCYCLE_LEAN_ANGLE_MAX: f32 = 90_f32;
    pub const GPS_LATERAL_ACCEL_MIN: f32 = -65_f32;
    pub const GPS_LATERAL_ACCEL_MAX: f32 = 65_f32;
    pub const ACCURACY_GPS_LATERAL_ACCEL_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_LATERAL_ACCEL_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Mcycle_Lean from values
    pub fn new(gps_mcycle_lean_angle: f32, gps_lateral_accel: f32, accuracy_gps_lateral_accel: u8, validity_gps_mcycle_lean: bool, validity_gps_lateral_accel: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_mcycle_lean_angle(gps_mcycle_lean_angle)?;
        res.set_gps_lateral_accel(gps_lateral_accel)?;
        res.set_accuracy_gps_lateral_accel(accuracy_gps_lateral_accel)?;
        res.set_validity_gps_mcycle_lean(validity_gps_mcycle_lean)?;
        res.set_validity_gps_lateral_accel(validity_gps_lateral_accel)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Mcycle_Lean_Angle
    ///
    /// Motorcycle lean angle, derived from rate of change of heading from GPS.  This is the lean angle of the centre of mass of the combined bike + rider.
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_mcycle_lean_angle(&self) -> f32 {
        self.gps_mcycle_lean_angle_raw()
    }
    
    /// Get raw value of GPS_Mcycle_Lean_Angle
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_mcycle_lean_angle_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Mcycle_Lean_Angle
    #[inline(always)]
    pub fn set_gps_mcycle_lean_angle(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsMcycleLean::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// GPS_Lateral_Accel
    ///
    /// GPS-derived lateral acceleration.  This is derived by differentiating GPS heading - it is much more noisy than lateral accel from the accelerometers, but useful for m/cycle applications.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_lateral_accel(&self) -> f32 {
        self.gps_lateral_accel_raw()
    }
    
    /// Get raw value of GPS_Lateral_Accel
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_lateral_accel_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Lateral_Accel
    #[inline(always)]
    pub fn set_gps_lateral_accel(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsMcycleLean::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Lateral_Accel
    ///
    /// This accuracy value applies to both GPS-derived lateral acceleration and motorcycle lean angle, since both are derived from the rate of change of GPS heading.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_lateral_accel(&self) -> u8 {
        self.accuracy_gps_lateral_accel_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Lateral_Accel
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_lateral_accel_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Lateral_Accel
    #[inline(always)]
    pub fn set_accuracy_gps_lateral_accel(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsMcycleLean::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsMcycleLean::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Mcycle_Lean
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_mcycle_lean(&self) -> bool {
        self.validity_gps_mcycle_lean_raw()
    }
    
    /// Get raw value of Validity_GPS_Mcycle_Lean
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_mcycle_lean_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Mcycle_Lean
    #[inline(always)]
    pub fn set_validity_gps_mcycle_lean(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Lateral_Accel
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_lateral_accel(&self) -> bool {
        self.validity_gps_lateral_accel_raw()
    }
    
    /// Get raw value of Validity_GPS_Lateral_Accel
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_lateral_accel_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Lateral_Accel
    #[inline(always)]
    pub fn set_validity_gps_lateral_accel(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsMcycleLean {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsMcycleLean {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Status
///
/// - Extended ID: 156658722 (0x9566c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsStatus {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsStatus {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566c22)});
    
    pub const RTK_STATUS_MIN: u8 = 0_u8;
    pub const RTK_STATUS_MAX: u8 = 255_u8;
    pub const GPS_N_SV_RTK_MIN: u8 = 0_u8;
    pub const GPS_N_SV_RTK_MAX: u8 = 16_u8;
    pub const GPS_N_SV_2_MIN: u8 = 0_u8;
    pub const GPS_N_SV_2_MAX: u8 = 16_u8;
    pub const GPS_N_SV_MIN: u8 = 0_u8;
    pub const GPS_N_SV_MAX: u8 = 16_u8;
    pub const FIRMWARE_VERSION_MINOR_MIN: u8 = 0_u8;
    pub const FIRMWARE_VERSION_MINOR_MAX: u8 = 255_u8;
    pub const FIRMWARE_VERSION_INTERMEDIATE_MIN: u8 = 0_u8;
    pub const FIRMWARE_VERSION_INTERMEDIATE_MAX: u8 = 255_u8;
    pub const FIRMWARE_VERSION_MAJOR_MIN: u8 = 0_u8;
    pub const FIRMWARE_VERSION_MAJOR_MAX: u8 = 255_u8;
    pub const GPS_STATUS_MIN: u8 = 0_u8;
    pub const GPS_STATUS_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Status from values
    pub fn new(rtk_status: u8, gps_n_sv_rtk: u8, gps_n_sv_2: u8, gps_n_sv: u8, firmware_version_minor: u8, firmware_version_intermediate: u8, firmware_version_major: u8, gps_status: u8) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_rtk_status(rtk_status)?;
        res.set_gps_n_sv_rtk(gps_n_sv_rtk)?;
        res.set_gps_n_sv_2(gps_n_sv_2)?;
        res.set_gps_n_sv(gps_n_sv)?;
        res.set_firmware_version_minor(firmware_version_minor)?;
        res.set_firmware_version_intermediate(firmware_version_intermediate)?;
        res.set_firmware_version_major(firmware_version_major)?;
        res.set_gps_status(gps_status)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// RTK_Status
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn rtk_status(&self) -> RtSbGpsStatusRtkStatus {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        match signal {
            4 => RtSbGpsStatusRtkStatus::MultipleRtkSolutionsFound,
            3 => RtSbGpsStatusRtkStatus::RtkSolutionOk,
            2 => RtSbGpsStatusRtkStatus::RtkSolutionFailed,
            1 => RtSbGpsStatusRtkStatus::NotEnoughCommonSatellites,
            0 => RtSbGpsStatusRtkStatus::NotAttemptingRtkSolution,
            _ => RtSbGpsStatusRtkStatus::_Other(self.rtk_status_raw()),
        }
    }
    
    /// Get raw value of RTK_Status
    ///
    /// - Start bit: 56
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn rtk_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[56..64].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of RTK_Status
    #[inline(always)]
    pub fn set_rtk_status(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[56..64].store_le(value);
        Ok(())
    }
    
    /// GPS_nSv_RTK
    ///
    /// Number of common satellites available to RTK solution
    ///
    /// - Min: 0
    /// - Max: 16
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_n_sv_rtk(&self) -> u8 {
        self.gps_n_sv_rtk_raw()
    }
    
    /// Get raw value of GPS_nSv_RTK
    ///
    /// - Start bit: 48
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_n_sv_rtk_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[48..56].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_nSv_RTK
    #[inline(always)]
    pub fn set_gps_n_sv_rtk(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 16_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[48..56].store_le(value);
        Ok(())
    }
    
    /// GPS_nSv_2
    ///
    /// Number of satellites used in GPS solution by module 2 on RTK units.
    ///
    /// - Min: 0
    /// - Max: 16
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_n_sv_2(&self) -> u8 {
        self.gps_n_sv_2_raw()
    }
    
    /// Get raw value of GPS_nSv_2
    ///
    /// - Start bit: 40
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_n_sv_2_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[40..48].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_nSv_2
    #[inline(always)]
    pub fn set_gps_n_sv_2(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 16_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[40..48].store_le(value);
        Ok(())
    }
    
    /// GPS_nSv
    ///
    /// Number of satellites used in GPS solution
    ///
    /// - Min: 0
    /// - Max: 16
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_n_sv(&self) -> u8 {
        self.gps_n_sv_raw()
    }
    
    /// Get raw value of GPS_nSv
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_n_sv_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_nSv
    #[inline(always)]
    pub fn set_gps_n_sv(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 16_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// Firmware_Version_Minor
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn firmware_version_minor(&self) -> u8 {
        self.firmware_version_minor_raw()
    }
    
    /// Get raw value of Firmware_Version_Minor
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn firmware_version_minor_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Firmware_Version_Minor
    #[inline(always)]
    pub fn set_firmware_version_minor(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Firmware_Version_Intermediate
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn firmware_version_intermediate(&self) -> u8 {
        self.firmware_version_intermediate_raw()
    }
    
    /// Get raw value of Firmware_Version_Intermediate
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn firmware_version_intermediate_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Firmware_Version_Intermediate
    #[inline(always)]
    pub fn set_firmware_version_intermediate(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Firmware_Version_Major
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn firmware_version_major(&self) -> u8 {
        self.firmware_version_major_raw()
    }
    
    /// Get raw value of Firmware_Version_Major
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn firmware_version_major_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Firmware_Version_Major
    #[inline(always)]
    pub fn set_firmware_version_major(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// GPS_Status
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_status(&self) -> RtSbGpsStatusGpsStatus {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        match signal {
            12 => RtSbGpsStatusGpsStatus::LockCarrierSpeedAndPosition,
            11 => RtSbGpsStatusGpsStatus::LockDopplerSpeedAndPosition,
            10 => RtSbGpsStatusGpsStatus::LockPositionButNoSpeed,
            9 => RtSbGpsStatusGpsStatus::Unused,
            8 => RtSbGpsStatusGpsStatus::Unused,
            7 => RtSbGpsStatusGpsStatus::Unused,
            6 => RtSbGpsStatusGpsStatus::Unused,
            5 => RtSbGpsStatusGpsStatus::ExceededMaxSpeedOrAlt,
            4 => RtSbGpsStatusGpsStatus::SolutionFailed,
            3 => RtSbGpsStatusGpsStatus::SolutionAborted,
            2 => RtSbGpsStatusGpsStatus::InsufficientSatellites,
            1 => RtSbGpsStatusGpsStatus::SearchingForSatellites,
            0 => RtSbGpsStatusGpsStatus::GpsModuleNotDetected,
            _ => RtSbGpsStatusGpsStatus::_Other(self.gps_status_raw()),
        }
    }
    
    /// Get raw value of GPS_Status
    ///
    /// - Start bit: 0
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_status_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[0..8].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_Status
    #[inline(always)]
    pub fn set_gps_status(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsStatus::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[0..8].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsStatus {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsStatus {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}
/// Defined values for RTK_Status
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbGpsStatusRtkStatus {
    MultipleRtkSolutionsFound,
    RtkSolutionOk,
    RtkSolutionFailed,
    NotEnoughCommonSatellites,
    NotAttemptingRtkSolution,
    _Other(u8),
}

impl From<RtSbGpsStatusRtkStatus> for u8 {
    fn from(val: RtSbGpsStatusRtkStatus) -> u8 {
        match val {
            RtSbGpsStatusRtkStatus::MultipleRtkSolutionsFound => 4,
            RtSbGpsStatusRtkStatus::RtkSolutionOk => 3,
            RtSbGpsStatusRtkStatus::RtkSolutionFailed => 2,
            RtSbGpsStatusRtkStatus::NotEnoughCommonSatellites => 1,
            RtSbGpsStatusRtkStatus::NotAttemptingRtkSolution => 0,
            RtSbGpsStatusRtkStatus::_Other(x) => x,
        }
    }
}

/// Defined values for GPS_Status
#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
#[derive(Clone, Copy, PartialEq)]
pub enum RtSbGpsStatusGpsStatus {
    LockCarrierSpeedAndPosition,
    LockDopplerSpeedAndPosition,
    LockPositionButNoSpeed,
    Unused,
    Unused,
    Unused,
    Unused,
    ExceededMaxSpeedOrAlt,
    SolutionFailed,
    SolutionAborted,
    InsufficientSatellites,
    SearchingForSatellites,
    GpsModuleNotDetected,
    _Other(u8),
}

impl From<RtSbGpsStatusGpsStatus> for u8 {
    fn from(val: RtSbGpsStatusGpsStatus) -> u8 {
        match val {
            RtSbGpsStatusGpsStatus::LockCarrierSpeedAndPosition => 12,
            RtSbGpsStatusGpsStatus::LockDopplerSpeedAndPosition => 11,
            RtSbGpsStatusGpsStatus::LockPositionButNoSpeed => 10,
            RtSbGpsStatusGpsStatus::Unused => 9,
            RtSbGpsStatusGpsStatus::Unused => 8,
            RtSbGpsStatusGpsStatus::Unused => 7,
            RtSbGpsStatusGpsStatus::Unused => 6,
            RtSbGpsStatusGpsStatus::ExceededMaxSpeedOrAlt => 5,
            RtSbGpsStatusGpsStatus::SolutionFailed => 4,
            RtSbGpsStatusGpsStatus::SolutionAborted => 3,
            RtSbGpsStatusGpsStatus::InsufficientSatellites => 2,
            RtSbGpsStatusGpsStatus::SearchingForSatellites => 1,
            RtSbGpsStatusGpsStatus::GpsModuleNotDetected => 0,
            RtSbGpsStatusGpsStatus::_Other(x) => x,
        }
    }
}


/// RT_SB_GPS_Pos_ECEF_2
///
/// - Extended ID: 156660002 (0x9567122)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsPosEcef2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsPosEcef2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567122)});
    
    pub const GPS_POS_ECEF_Z_MIN: f32 = -10000000_f32;
    pub const GPS_POS_ECEF_Z_MAX: f32 = 10000000_f32;
    pub const GPS_POS_ECEF_Y_MIN: f32 = -10000000_f32;
    pub const GPS_POS_ECEF_Y_MAX: f32 = 10000000_f32;
    
    /// Construct new RT_SB_GPS_Pos_ECEF_2 from values
    pub fn new(gps_pos_ecef_z: f32, gps_pos_ecef_y: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_ecef_z(gps_pos_ecef_z)?;
        res.set_gps_pos_ecef_y(gps_pos_ecef_y)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_ECEF_Z
    ///
    /// ECEF Z position.  The ECEF Z axis originates from the Earth centre, and the positive Z axis intersects the Earth surface at the North Pole.
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_ecef_z(&self) -> f32 {
        self.gps_pos_ecef_z_raw()
    }
    
    /// Get raw value of GPS_Pos_ECEF_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_ecef_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_gps_pos_ecef_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Pos_ECEF_Y
    ///
    /// ECEF Y position.  The ECEF Y axis originates from the Earth centre, and the positive Y axis intersects the Earth surface at zero degrees latittude and 90 degrees longitude.
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_ecef_y(&self) -> f32 {
        self.gps_pos_ecef_y_raw()
    }
    
    /// Get raw value of GPS_Pos_ECEF_Y
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_ecef_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_gps_pos_ecef_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef2::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsPosEcef2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsPosEcef2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Pos_ECEF_1
///
/// - Extended ID: 156659746 (0x9567022)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsPosEcef1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsPosEcef1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567022)});
    
    pub const GPS_POS_ECEF_X_MIN: f32 = -10000000_f32;
    pub const GPS_POS_ECEF_X_MAX: f32 = 10000000_f32;
    pub const ACCURACY_GPS_POS_ECEF_Z_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_ECEF_Z_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_ECEF_Y_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_ECEF_Y_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_ECEF_X_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_ECEF_X_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Pos_ECEF_1 from values
    pub fn new(gps_pos_ecef_x: f32, accuracy_gps_pos_ecef_z: u8, accuracy_gps_pos_ecef_y: u8, accuracy_gps_pos_ecef_x: u8, validity_gps_pos_ecef_z: bool, validity_gps_pos_ecef_y: bool, validity_gps_pos_ecef_x: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_ecef_x(gps_pos_ecef_x)?;
        res.set_accuracy_gps_pos_ecef_z(accuracy_gps_pos_ecef_z)?;
        res.set_accuracy_gps_pos_ecef_y(accuracy_gps_pos_ecef_y)?;
        res.set_accuracy_gps_pos_ecef_x(accuracy_gps_pos_ecef_x)?;
        res.set_validity_gps_pos_ecef_z(validity_gps_pos_ecef_z)?;
        res.set_validity_gps_pos_ecef_y(validity_gps_pos_ecef_y)?;
        res.set_validity_gps_pos_ecef_x(validity_gps_pos_ecef_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_ECEF_X
    ///
    /// ECEF X position.  The ECEF X axis originates from the Earth centre, and the positive X axis intersects the Earth surface at zero degrees latittude and zero degrees longitude (the intersection of the equator and the prime meridian).
    ///
    /// - Min: -10000000
    /// - Max: 10000000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_ecef_x(&self) -> f32 {
        self.gps_pos_ecef_x_raw()
    }
    
    /// Get raw value of GPS_Pos_ECEF_X
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_ecef_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_gps_pos_ecef_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -10000000_f32 || 10000000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_ECEF_Z
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_z(&self) -> u8 {
        self.accuracy_gps_pos_ecef_z_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_ECEF_Z
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_z_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_accuracy_gps_pos_ecef_z(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_ECEF_Y
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_y(&self) -> u8 {
        self.accuracy_gps_pos_ecef_y_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_ECEF_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_y_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_accuracy_gps_pos_ecef_y(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_ECEF_X
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_x(&self) -> u8 {
        self.accuracy_gps_pos_ecef_x_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_ECEF_X
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_ecef_x_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_accuracy_gps_pos_ecef_x(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_ECEF_Z
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_ecef_z(&self) -> bool {
        self.validity_gps_pos_ecef_z_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_ECEF_Z
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_ecef_z_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_ECEF_Z
    #[inline(always)]
    pub fn set_validity_gps_pos_ecef_z(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_ECEF_Y
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_ecef_y(&self) -> bool {
        self.validity_gps_pos_ecef_y_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_ECEF_Y
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_ecef_y_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_ECEF_Y
    #[inline(always)]
    pub fn set_validity_gps_pos_ecef_y(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_ECEF_X
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_ecef_x(&self) -> bool {
        self.validity_gps_pos_ecef_x_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_ECEF_X
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_ecef_x_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_ECEF_X
    #[inline(always)]
    pub fn set_validity_gps_pos_ecef_x(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsPosEcef1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsPosEcef1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Pos_LLH_2
///
/// - Extended ID: 156659490 (0x9566f22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsPosLlh2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsPosLlh2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566f22)});
    
    pub const GPS_POS_LLH_ALTITUDE_MIN: f32 = -1000_f32;
    pub const GPS_POS_LLH_ALTITUDE_MAX: f32 = 100000_f32;
    pub const GPS_POS_LLH_LONGITUDE_MIN: f32 = -180_f32;
    pub const GPS_POS_LLH_LONGITUDE_MAX: f32 = 180_f32;
    
    /// Construct new RT_SB_GPS_Pos_LLH_2 from values
    pub fn new(gps_pos_llh_altitude: f32, gps_pos_llh_longitude: f32) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_llh_altitude(gps_pos_llh_altitude)?;
        res.set_gps_pos_llh_longitude(gps_pos_llh_longitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_LLH_Altitude
    ///
    /// - Min: -1000
    /// - Max: 100000
    /// - Unit: "m"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_altitude(&self) -> f32 {
        self.gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_altitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_gps_pos_llh_altitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -1000_f32 || 100000_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Pos_LLH_Longitude
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_longitude(&self) -> f32 {
        self.gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 0
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_longitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[0..32].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_gps_pos_llh_longitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh2::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[0..32].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsPosLlh2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsPosLlh2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Pos_LLH_1
///
/// - Extended ID: 156659234 (0x9566e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsPosLlh1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsPosLlh1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566e22)});
    
    pub const GPS_POS_LLH_LATITUDE_MIN: f32 = -90_f32;
    pub const GPS_POS_LLH_LATITUDE_MAX: f32 = 90_f32;
    pub const ACCURACY_GPS_POS_LLH_ALTITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_ALTITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_LLH_LONGITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_LONGITUDE_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_POS_LLH_LATITUDE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_POS_LLH_LATITUDE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Pos_LLH_1 from values
    pub fn new(gps_pos_llh_latitude: f32, accuracy_gps_pos_llh_altitude: u8, accuracy_gps_pos_llh_longitude: u8, accuracy_gps_pos_llh_latitude: u8, validity_gps_pos_llh_altitude: bool, validity_gps_pos_llh_longitude: bool, validity_gps_pos_llh_latitude: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_pos_llh_latitude(gps_pos_llh_latitude)?;
        res.set_accuracy_gps_pos_llh_altitude(accuracy_gps_pos_llh_altitude)?;
        res.set_accuracy_gps_pos_llh_longitude(accuracy_gps_pos_llh_longitude)?;
        res.set_accuracy_gps_pos_llh_latitude(accuracy_gps_pos_llh_latitude)?;
        res.set_validity_gps_pos_llh_altitude(validity_gps_pos_llh_altitude)?;
        res.set_validity_gps_pos_llh_longitude(validity_gps_pos_llh_longitude)?;
        res.set_validity_gps_pos_llh_latitude(validity_gps_pos_llh_latitude)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Pos_LLH_Latitude
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_pos_llh_latitude(&self) -> f32 {
        self.gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 32
    /// - Signal size: 32 bits
    /// - Factor: 0.0000001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_pos_llh_latitude_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..64].load_le::<i32>();
        
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_gps_pos_llh_latitude(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID });
        }
        let factor = 0.0000001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..64].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Altitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_altitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_altitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_altitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Longitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_longitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_longitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_longitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Pos_LLH_Latitude
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_latitude(&self) -> u8 {
        self.accuracy_gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_pos_llh_latitude_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_accuracy_gps_pos_llh_latitude(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsPosLlh1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Altitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_altitude(&self) -> bool {
        self.validity_gps_pos_llh_altitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Altitude
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_altitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Altitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_altitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Longitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_longitude(&self) -> bool {
        self.validity_gps_pos_llh_longitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Longitude
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_longitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Longitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_longitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Pos_LLH_Latitude
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_pos_llh_latitude(&self) -> bool {
        self.validity_gps_pos_llh_latitude_raw()
    }
    
    /// Get raw value of Validity_GPS_Pos_LLH_Latitude
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_pos_llh_latitude_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Pos_LLH_Latitude
    #[inline(always)]
    pub fn set_validity_gps_pos_llh_latitude(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsPosLlh1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsPosLlh1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Heading_Gradient
///
/// - Extended ID: 156664098 (0x9568122)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsHeadingGradient {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsHeadingGradient {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9568122)});
    
    pub const GPS_GRADIENT_MIN: f32 = -90_f32;
    pub const GPS_GRADIENT_MAX: f32 = 90_f32;
    pub const ACCURACY_GPS_GRADIENT_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_GRADIENT_MAX: u8 = 255_u8;
    pub const GPS_HEADING_MIN: f32 = -180_f32;
    pub const GPS_HEADING_MAX: f32 = 180_f32;
    pub const ACCURACY_GPS_HEADING_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_HEADING_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Heading_Gradient from values
    pub fn new(gps_gradient: f32, accuracy_gps_gradient: u8, gps_heading: f32, accuracy_gps_heading: u8, validity_gps_gradient: bool, validity_gps_heading: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_gradient(gps_gradient)?;
        res.set_accuracy_gps_gradient(accuracy_gps_gradient)?;
        res.set_gps_heading(gps_heading)?;
        res.set_accuracy_gps_heading(accuracy_gps_heading)?;
        res.set_validity_gps_gradient(validity_gps_gradient)?;
        res.set_validity_gps_heading(validity_gps_heading)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Gradient
    ///
    /// This is GPS gradient, i.e. the vertical direction that the vehicle is travelling, NOT pointing (pitch).
    ///
    /// - Min: -90
    /// - Max: 90
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_gradient(&self) -> f32 {
        self.gps_gradient_raw()
    }
    
    /// Get raw value of GPS_Gradient
    ///
    /// - Start bit: 40
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_gradient_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..56].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Gradient
    #[inline(always)]
    pub fn set_gps_gradient(&mut self, value: f32) -> Result<(), CanError> {
        if value < -90_f32 || 90_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Gradient
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_gradient(&self) -> u8 {
        self.accuracy_gps_gradient_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Gradient
    ///
    /// - Start bit: 32
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_gradient_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[32..40].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Gradient
    #[inline(always)]
    pub fn set_accuracy_gps_gradient(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[32..40].store_le(value);
        Ok(())
    }
    
    /// GPS_Heading
    ///
    /// This is GPS heading, the direction that the vehicle is travelling in the local horizontal plane.
    ///
    /// - Min: -180
    /// - Max: 180
    /// - Unit: "degrees"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_heading(&self) -> f32 {
        self.gps_heading_raw()
    }
    
    /// Get raw value of GPS_Heading
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_heading_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Heading
    #[inline(always)]
    pub fn set_gps_heading(&mut self, value: f32) -> Result<(), CanError> {
        if value < -180_f32 || 180_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Heading
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_heading(&self) -> u8 {
        self.accuracy_gps_heading_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Heading
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_heading_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Heading
    #[inline(always)]
    pub fn set_accuracy_gps_heading(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsHeadingGradient::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Gradient
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_gradient(&self) -> bool {
        self.validity_gps_gradient_raw()
    }
    
    /// Get raw value of Validity_GPS_Gradient
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_gradient_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Gradient
    #[inline(always)]
    pub fn set_validity_gps_gradient(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Heading
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_heading(&self) -> bool {
        self.validity_gps_heading_raw()
    }
    
    /// Get raw value of Validity_GPS_Heading
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_heading_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Heading
    #[inline(always)]
    pub fn set_validity_gps_heading(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsHeadingGradient {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsHeadingGradient {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Vel_ECEF_2
///
/// - Extended ID: 156663842 (0x9568022)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsVelEcef2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsVelEcef2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9568022)});
    
    pub const GPS_VEL_ECEF_Z_MIN: f32 = -838_f32;
    pub const GPS_VEL_ECEF_Z_MAX: f32 = 838_f32;
    pub const GPS_VEL_ECEF_Y_MIN: f32 = -838_f32;
    pub const GPS_VEL_ECEF_Y_MAX: f32 = 838_f32;
    
    /// Construct new RT_SB_GPS_Vel_ECEF_2 from values
    pub fn new(gps_vel_ecef_z: f32, gps_vel_ecef_y: f32, validity_gps_vel_ecef_z: bool, validity_gps_vel_ecef_y: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_vel_ecef_z(gps_vel_ecef_z)?;
        res.set_gps_vel_ecef_y(gps_vel_ecef_y)?;
        res.set_validity_gps_vel_ecef_z(validity_gps_vel_ecef_z)?;
        res.set_validity_gps_vel_ecef_y(validity_gps_vel_ecef_y)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Vel_ECEF_Z
    ///
    /// ECEF Z velocity.  The ECEF Z axis originates from the Earth centre, and the positive Z axis intersects the Earth surface at the North Pole.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ecef_z(&self) -> f32 {
        self.gps_vel_ecef_z_raw()
    }
    
    /// Get raw value of GPS_Vel_ECEF_Z
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ecef_z_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_gps_vel_ecef_z(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// GPS_Vel_ECEF_Y
    ///
    /// ECEF Y velocity.  The ECEF Y axis originates from the Earth centre, and the positive Y axis intersects the Earth surface at zero degrees latittude and 90 degrees longitude.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ecef_y(&self) -> f32 {
        self.gps_vel_ecef_y_raw()
    }
    
    /// Get raw value of GPS_Vel_ECEF_Y
    ///
    /// - Start bit: 8
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ecef_y_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[8..32].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_gps_vel_ecef_y(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[8..32].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_ECEF_Z
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ecef_z(&self) -> bool {
        self.validity_gps_vel_ecef_z_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_ECEF_Z
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ecef_z_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_validity_gps_vel_ecef_z(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_ECEF_Y
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ecef_y(&self) -> bool {
        self.validity_gps_vel_ecef_y_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_ECEF_Y
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ecef_y_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_validity_gps_vel_ecef_y(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsVelEcef2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsVelEcef2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Vel_ECEF_1
///
/// - Extended ID: 156663586 (0x9567f22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsVelEcef1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsVelEcef1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567f22)});
    
    pub const GPS_VEL_ECEF_X_MIN: f32 = -838_f32;
    pub const GPS_VEL_ECEF_X_MAX: f32 = 838_f32;
    pub const ACCURACY_GPS_VEL_ECEF_Z_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_VEL_ECEF_Z_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_VEL_ECEF_Y_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_VEL_ECEF_Y_MAX: u8 = 255_u8;
    pub const ACCURACY_GPS_VEL_ECEF_X_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_VEL_ECEF_X_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Vel_ECEF_1 from values
    pub fn new(gps_vel_ecef_x: f32, accuracy_gps_vel_ecef_z: u8, accuracy_gps_vel_ecef_y: u8, accuracy_gps_vel_ecef_x: u8, validity_gps_vel_ecef_x: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_vel_ecef_x(gps_vel_ecef_x)?;
        res.set_accuracy_gps_vel_ecef_z(accuracy_gps_vel_ecef_z)?;
        res.set_accuracy_gps_vel_ecef_y(accuracy_gps_vel_ecef_y)?;
        res.set_accuracy_gps_vel_ecef_x(accuracy_gps_vel_ecef_x)?;
        res.set_validity_gps_vel_ecef_x(validity_gps_vel_ecef_x)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Vel_ECEF_X
    ///
    /// ECEF X velocity.  The ECEF X axis originates from the Earth centre, and the positive X axis intersects the Earth surface at zero degrees latittude and zero degrees longitude (the intersection of the equator and the prime meridian).
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ecef_x(&self) -> f32 {
        self.gps_vel_ecef_x_raw()
    }
    
    /// Get raw value of GPS_Vel_ECEF_X
    ///
    /// - Start bit: 32
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ecef_x_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..56].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_gps_vel_ecef_x(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..56].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Vel_ECEF_Z
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_z(&self) -> u8 {
        self.accuracy_gps_vel_ecef_z_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Vel_ECEF_Z
    ///
    /// - Start bit: 24
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_z_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[24..32].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Vel_ECEF_Z
    #[inline(always)]
    pub fn set_accuracy_gps_vel_ecef_z(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[24..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Vel_ECEF_Y
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_y(&self) -> u8 {
        self.accuracy_gps_vel_ecef_y_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Vel_ECEF_Y
    ///
    /// - Start bit: 16
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_y_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[16..24].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Vel_ECEF_Y
    #[inline(always)]
    pub fn set_accuracy_gps_vel_ecef_y(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[16..24].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Vel_ECEF_X
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_x(&self) -> u8 {
        self.accuracy_gps_vel_ecef_x_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Vel_ECEF_X
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_vel_ecef_x_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_accuracy_gps_vel_ecef_x(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsVelEcef1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_ECEF_X
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ecef_x(&self) -> bool {
        self.validity_gps_vel_ecef_x_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_ECEF_X
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ecef_x_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_ECEF_X
    #[inline(always)]
    pub fn set_validity_gps_vel_ecef_x(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsVelEcef1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsVelEcef1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Vel_NED_2
///
/// - Extended ID: 156663330 (0x9567e22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsVelNed2 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsVelNed2 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567e22)});
    
    pub const GPS_VEL_NED_D_MIN: f32 = -838_f32;
    pub const GPS_VEL_NED_D_MAX: f32 = 838_f32;
    pub const ACCURACY_GPS_VEL_D_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_VEL_D_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Vel_NED_2 from values
    pub fn new(gps_vel_ned_d: f32, accuracy_gps_vel_d: u8, validity_gps_vel_ned_d: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_vel_ned_d(gps_vel_ned_d)?;
        res.set_accuracy_gps_vel_d(accuracy_gps_vel_d)?;
        res.set_validity_gps_vel_ned_d(validity_gps_vel_ned_d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Vel_NED_D
    ///
    /// VELNED D velocity.  This is the velocity vector directly downwards towards the Earth centre at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ned_d(&self) -> f32 {
        self.gps_vel_ned_d_raw()
    }
    
    /// Get raw value of GPS_Vel_NED_D
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ned_d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_NED_D
    #[inline(always)]
    pub fn set_gps_vel_ned_d(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed2::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Vel_D
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_vel_d(&self) -> u8 {
        self.accuracy_gps_vel_d_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Vel_D
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_vel_d_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Vel_D
    #[inline(always)]
    pub fn set_accuracy_gps_vel_d(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed2::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed2::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_NED_D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ned_d(&self) -> bool {
        self.validity_gps_vel_ned_d_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_NED_D
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ned_d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_NED_D
    #[inline(always)]
    pub fn set_validity_gps_vel_ned_d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsVelNed2 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsVelNed2 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Vel_NED_1
///
/// - Extended ID: 156663074 (0x9567d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsVelNed1 {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsVelNed1 {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567d22)});
    
    pub const GPS_VEL_NED_E_MIN: f32 = -838_f32;
    pub const GPS_VEL_NED_E_MAX: f32 = 838_f32;
    pub const GPS_VEL_NED_N_MIN: f32 = -838_f32;
    pub const GPS_VEL_NED_N_MAX: f32 = 838_f32;
    pub const ACCURACY_GPS_VEL_NE_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_VEL_NE_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Vel_NED_1 from values
    pub fn new(gps_vel_ned_e: f32, gps_vel_ned_n: f32, accuracy_gps_vel_ne: u8, validity_gps_vel_ned_e: bool, validity_gps_vel_ned_n: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_vel_ned_e(gps_vel_ned_e)?;
        res.set_gps_vel_ned_n(gps_vel_ned_n)?;
        res.set_accuracy_gps_vel_ne(accuracy_gps_vel_ne)?;
        res.set_validity_gps_vel_ned_e(validity_gps_vel_ned_e)?;
        res.set_validity_gps_vel_ned_n(validity_gps_vel_ned_n)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Vel_NED_E
    ///
    /// VELNED E velocity.  This is the velocity vector directly East at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ned_e(&self) -> f32 {
        self.gps_vel_ned_e_raw()
    }
    
    /// Get raw value of GPS_Vel_NED_E
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ned_e_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_NED_E
    #[inline(always)]
    pub fn set_gps_vel_ned_e(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Vel_NED_N
    ///
    /// VELNED N velocity.  This is the velocity vector directly North at the current local Earth surface position.
    ///
    /// - Min: -838
    /// - Max: 838
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_vel_ned_n(&self) -> f32 {
        self.gps_vel_ned_n_raw()
    }
    
    /// Get raw value of GPS_Vel_NED_N
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gps_vel_ned_n_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<i32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Vel_NED_N
    #[inline(always)]
    pub fn set_gps_vel_ned_n(&mut self, value: f32) -> Result<(), CanError> {
        if value < -838_f32 || 838_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed1::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i32;
        
        let value = u32::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Vel_NE
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_vel_ne(&self) -> u8 {
        self.accuracy_gps_vel_ne_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Vel_NE
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_vel_ne_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Vel_NE
    #[inline(always)]
    pub fn set_accuracy_gps_vel_ne(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed1::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsVelNed1::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_NED_E
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ned_e(&self) -> bool {
        self.validity_gps_vel_ned_e_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_NED_E
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ned_e_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_NED_E
    #[inline(always)]
    pub fn set_validity_gps_vel_ned_e(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Vel_NED_N
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_vel_ned_n(&self) -> bool {
        self.validity_gps_vel_ned_n_raw()
    }
    
    /// Get raw value of Validity_GPS_Vel_NED_N
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_vel_ned_n_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Vel_NED_N
    #[inline(always)]
    pub fn set_validity_gps_vel_ned_n(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsVelNed1 {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsVelNed1 {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Speed
///
/// - Extended ID: 156662818 (0x9567c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsSpeed {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsSpeed {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9567c22)});
    
    pub const GPS_SPEED_3D_MIN: f32 = 0_f32;
    pub const GPS_SPEED_3D_MAX: f32 = 1675_f32;
    pub const GPS_SPEED_2D_MIN: f32 = 0_f32;
    pub const GPS_SPEED_2D_MAX: f32 = 1675_f32;
    pub const ACCURACY_GPS_SPEED_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_SPEED_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Speed from values
    pub fn new(gps_speed_3d: f32, gps_speed_2d: f32, accuracy_gps_speed: u8, validity_gps_speed_3d: bool, validity_gps_speed_2d: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_speed_3d(gps_speed_3d)?;
        res.set_gps_speed_2d(gps_speed_2d)?;
        res.set_accuracy_gps_speed(accuracy_gps_speed)?;
        res.set_validity_gps_speed_3d(validity_gps_speed_3d)?;
        res.set_validity_gps_speed_2d(validity_gps_speed_2d)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Speed_3D
    ///
    /// This is GPS scalar 3D speed - scalar speed with the local Z axis component included.
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_speed_3d(&self) -> f32 {
        self.gps_speed_3d_raw()
    }
    
    /// Get raw value of GPS_Speed_3D
    ///
    /// - Start bit: 40
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_speed_3d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[40..64].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Speed_3D
    #[inline(always)]
    pub fn set_gps_speed_3d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsSpeed::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[40..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Speed_2D
    ///
    /// This is GPS scalar 2D speed - scalar speed with no local Z axis component included.
    ///
    /// - Min: 0
    /// - Max: 1675
    /// - Unit: "m/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_speed_2d(&self) -> f32 {
        self.gps_speed_2d_raw()
    }
    
    /// Get raw value of GPS_Speed_2D
    ///
    /// - Start bit: 16
    /// - Signal size: 24 bits
    /// - Factor: 0.0001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_speed_2d_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..40].load_le::<u32>();
        
        let factor = 0.0001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Speed_2D
    #[inline(always)]
    pub fn set_gps_speed_2d(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 1675_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsSpeed::MESSAGE_ID });
        }
        let factor = 0.0001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[16..40].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Speed
    ///
    /// This accuracy value applies to both 2D and 3D GPS speed.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_speed(&self) -> u8 {
        self.accuracy_gps_speed_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Speed
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_speed_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Speed
    #[inline(always)]
    pub fn set_accuracy_gps_speed(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsSpeed::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsSpeed::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Speed_3D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_speed_3d(&self) -> bool {
        self.validity_gps_speed_3d_raw()
    }
    
    /// Get raw value of Validity_GPS_Speed_3D
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_speed_3d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Speed_3D
    #[inline(always)]
    pub fn set_validity_gps_speed_3d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Speed_2D
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_speed_2d(&self) -> bool {
        self.validity_gps_speed_2d_raw()
    }
    
    /// Get raw value of Validity_GPS_Speed_2D
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_speed_2d_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Speed_2D
    #[inline(always)]
    pub fn set_validity_gps_speed_2d(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsSpeed {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsSpeed {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_GPS_Time
///
/// - Extended ID: 156658978 (0x9566d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGpsTime {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGpsTime {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x9566d22)});
    
    pub const GPS_WEEK_MIN: u16 = 0_u16;
    pub const GPS_WEEK_MAX: u16 = 65535_u16;
    pub const GPS_TIME_MIN: f32 = 0_f32;
    pub const GPS_TIME_MAX: f32 = 604800_f32;
    pub const ACCURACY_GPS_TIME_MIN: u8 = 0_u8;
    pub const ACCURACY_GPS_TIME_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_GPS_Time from values
    pub fn new(gps_week: u16, gps_time: f32, accuracy_gps_time: u8, validity_gps_week: bool, validity_gps_time: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gps_week(gps_week)?;
        res.set_gps_time(gps_time)?;
        res.set_accuracy_gps_time(accuracy_gps_time)?;
        res.set_validity_gps_week(validity_gps_week)?;
        res.set_validity_gps_time(validity_gps_time)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// GPS_Week
    ///
    /// - Min: 0
    /// - Max: 65535
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_week(&self) -> u16 {
        self.gps_week_raw()
    }
    
    /// Get raw value of GPS_Week
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_week_raw(&self) -> u16 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<u16>();
        
        let factor = 1;
        u16::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of GPS_Week
    #[inline(always)]
    pub fn set_gps_week(&mut self, value: u16) -> Result<(), CanError> {
        if value < 0_u16 || 65535_u16 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsTime::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsTime::MESSAGE_ID })?;
        let value = (value / factor) as u16;
        
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// GPS_Time
    ///
    /// GPS time is the time in seconds since midnight GMT on Saturday night.
    ///
    /// - Min: 0
    /// - Max: 604800
    /// - Unit: "s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gps_time(&self) -> f32 {
        self.gps_time_raw()
    }
    
    /// Get raw value of GPS_Time
    ///
    /// - Start bit: 16
    /// - Signal size: 32 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn gps_time_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..48].load_le::<u32>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of GPS_Time
    #[inline(always)]
    pub fn set_gps_time(&mut self, value: f32) -> Result<(), CanError> {
        if value < 0_f32 || 604800_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsTime::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as u32;
        
        self.raw.view_bits_mut::<Lsb0>()[16..48].store_le(value);
        Ok(())
    }
    
    /// Accuracy_GPS_Time
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gps_time(&self) -> u8 {
        self.accuracy_gps_time_raw()
    }
    
    /// Get raw value of Accuracy_GPS_Time
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gps_time_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_GPS_Time
    #[inline(always)]
    pub fn set_accuracy_gps_time(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGpsTime::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGpsTime::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Week
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_week(&self) -> bool {
        self.validity_gps_week_raw()
    }
    
    /// Get raw value of Validity_GPS_Week
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_week_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Week
    #[inline(always)]
    pub fn set_validity_gps_week(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_GPS_Time
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gps_time(&self) -> bool {
        self.validity_gps_time_raw()
    }
    
    /// Get raw value of Validity_GPS_Time
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gps_time_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_GPS_Time
    #[inline(always)]
    pub fn set_validity_gps_time(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGpsTime {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGpsTime {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Accel
///
/// - Extended ID: 155872290 (0x94a6c22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbAccel {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbAccel {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a6c22)});
    
    pub const ACCEL_VERTICAL_MIN: f32 = -65_f32;
    pub const ACCEL_VERTICAL_MAX: f32 = 65_f32;
    pub const ACCEL_LATERAL_MIN: f32 = -65_f32;
    pub const ACCEL_LATERAL_MAX: f32 = 65_f32;
    pub const ACCEL_LONGITUDINAL_MIN: f32 = -65_f32;
    pub const ACCEL_LONGITUDINAL_MAX: f32 = 65_f32;
    pub const ACCURACY_ACCEL_MIN: u8 = 0_u8;
    pub const ACCURACY_ACCEL_MAX: u8 = 255_u8;
    
    /// Construct new RT_SB_Accel from values
    pub fn new(accel_vertical: f32, accel_lateral: f32, accel_longitudinal: f32, accuracy_accel: u8, validity_accel_vertical: bool, validity_accel_lateral: bool, validity_accel_longitudinal: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_accel_vertical(accel_vertical)?;
        res.set_accel_lateral(accel_lateral)?;
        res.set_accel_longitudinal(accel_longitudinal)?;
        res.set_accuracy_accel(accuracy_accel)?;
        res.set_validity_accel_vertical(validity_accel_vertical)?;
        res.set_validity_accel_lateral(validity_accel_lateral)?;
        res.set_validity_accel_longitudinal(validity_accel_longitudinal)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Accel_Vertical
    ///
    /// Vertical acceleration.  This is positive when the vehicle accelerates in an upwards direction, e.g. when travelling through a dip.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_vertical(&self) -> f32 {
        self.accel_vertical_raw()
    }
    
    /// Get raw value of Accel_Vertical
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_vertical_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Vertical
    #[inline(always)]
    pub fn set_accel_vertical(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbAccel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Accel_Lateral
    ///
    /// Lateral acceleration.  This is positive when the vehicle accelerates towards the right, e.g. when cornering around a right-hand bend.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_lateral(&self) -> f32 {
        self.accel_lateral_raw()
    }
    
    /// Get raw value of Accel_Lateral
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_lateral_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Lateral
    #[inline(always)]
    pub fn set_accel_lateral(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbAccel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Accel_Longitudinal
    ///
    /// Longitudinal acceleration.  This is positive when the vehicle accelerates in a forwards direction.
    ///
    /// - Min: -65
    /// - Max: 65
    /// - Unit: "g"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accel_longitudinal(&self) -> f32 {
        self.accel_longitudinal_raw()
    }
    
    /// Get raw value of Accel_Longitudinal
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.001
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn accel_longitudinal_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.001_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Accel_Longitudinal
    #[inline(always)]
    pub fn set_accel_longitudinal(&mut self, value: f32) -> Result<(), CanError> {
        if value < -65_f32 || 65_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbAccel::MESSAGE_ID });
        }
        let factor = 0.001_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Accel
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 255
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_accel(&self) -> u8 {
        self.accuracy_accel_raw()
    }
    
    /// Get raw value of Accuracy_Accel
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_accel_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Accel
    #[inline(always)]
    pub fn set_accuracy_accel(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 255_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbAccel::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbAccel::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Vertical
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_vertical(&self) -> bool {
        self.validity_accel_vertical_raw()
    }
    
    /// Get raw value of Validity_Accel_Vertical
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_vertical_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Vertical
    #[inline(always)]
    pub fn set_validity_accel_vertical(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Lateral
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_lateral(&self) -> bool {
        self.validity_accel_lateral_raw()
    }
    
    /// Get raw value of Validity_Accel_Lateral
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_lateral_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Lateral
    #[inline(always)]
    pub fn set_validity_accel_lateral(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Accel_Longitudinal
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_accel_longitudinal(&self) -> bool {
        self.validity_accel_longitudinal_raw()
    }
    
    /// Get raw value of Validity_Accel_Longitudinal
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_accel_longitudinal_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Accel_Longitudinal
    #[inline(always)]
    pub fn set_validity_accel_longitudinal(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbAccel {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbAccel {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}

/// RT_SB_Gyro_Rates
///
/// - Extended ID: 155872546 (0x94a6d22)
/// - Size: 8 bytes
#[derive(Clone, Copy)]
pub struct RtSbGyroRates {
    raw: [u8; 8],
}

#[allow(
    clippy::absurd_extreme_comparisons,
    clippy::excessive_precision,
    clippy::manual_range_contains,
    clippy::unnecessary_cast,
    clippy::useless_conversion,
    unused_comparisons,
    unused_variables,
)]
impl RtSbGyroRates {
    pub const MESSAGE_ID: embedded_can::Id = Id::Extended(unsafe { ExtendedId::new_unchecked(0x94a6d22)});
    
    pub const GYRO_RATE_ROLL_MIN: f32 = -327_f32;
    pub const GYRO_RATE_ROLL_MAX: f32 = 327_f32;
    pub const GYRO_RATE_PITCH_MIN: f32 = -327_f32;
    pub const GYRO_RATE_PITCH_MAX: f32 = 327_f32;
    pub const GYRO_RATE_YAW_MIN: f32 = -327_f32;
    pub const GYRO_RATE_YAW_MAX: f32 = 327_f32;
    pub const ACCURACY_GYRO_RATES_MIN: u8 = 0_u8;
    pub const ACCURACY_GYRO_RATES_MAX: u8 = 0_u8;
    
    /// Construct new RT_SB_Gyro_Rates from values
    pub fn new(gyro_rate_roll: f32, gyro_rate_pitch: f32, gyro_rate_yaw: f32, accuracy_gyro_rates: u8, validity_gyro_rate_roll: bool, validity_gyro_rate_pitch: bool, validity_gyro_rate_yaw: bool) -> Result<Self, CanError> {
        let mut res = Self { raw: [0u8; 8] };
        res.set_gyro_rate_roll(gyro_rate_roll)?;
        res.set_gyro_rate_pitch(gyro_rate_pitch)?;
        res.set_gyro_rate_yaw(gyro_rate_yaw)?;
        res.set_accuracy_gyro_rates(accuracy_gyro_rates)?;
        res.set_validity_gyro_rate_roll(validity_gyro_rate_roll)?;
        res.set_validity_gyro_rate_pitch(validity_gyro_rate_pitch)?;
        res.set_validity_gyro_rate_yaw(validity_gyro_rate_yaw)?;
        Ok(res)
    }
    
    /// Access message payload raw value
    pub fn raw(&self) -> &[u8; 8] {
        &self.raw
    }
    
    /// Gyro_Rate_Roll
    ///
    /// Roll rate is positive for clockwise rotation when looking at the rear of the vehicle from behind the vehicle.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_roll(&self) -> f32 {
        self.gyro_rate_roll_raw()
    }
    
    /// Get raw value of Gyro_Rate_Roll
    ///
    /// - Start bit: 48
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_roll_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[48..64].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Roll
    #[inline(always)]
    pub fn set_gyro_rate_roll(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[48..64].store_le(value);
        Ok(())
    }
    
    /// Gyro_Rate_Pitch
    ///
    /// Pitch rate is positive for clockwise rotation when looking at the left hand side of the vehicle from the left of the vehicle.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_pitch(&self) -> f32 {
        self.gyro_rate_pitch_raw()
    }
    
    /// Get raw value of Gyro_Rate_Pitch
    ///
    /// - Start bit: 32
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_pitch_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[32..48].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Pitch
    #[inline(always)]
    pub fn set_gyro_rate_pitch(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[32..48].store_le(value);
        Ok(())
    }
    
    /// Gyro_Rate_Yaw
    ///
    /// Yaw rate is positive for clockwise rotation when looking down on the vehicle from above.
    ///
    /// - Min: -327
    /// - Max: 327
    /// - Unit: "degrees/s"
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn gyro_rate_yaw(&self) -> f32 {
        self.gyro_rate_yaw_raw()
    }
    
    /// Get raw value of Gyro_Rate_Yaw
    ///
    /// - Start bit: 16
    /// - Signal size: 16 bits
    /// - Factor: 0.01
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Signed
    #[inline(always)]
    pub fn gyro_rate_yaw_raw(&self) -> f32 {
        let signal = self.raw.view_bits::<Lsb0>()[16..32].load_le::<i16>();
        
        let factor = 0.01_f32;
        let offset = 0_f32;
        (signal as f32) * factor + offset
    }
    
    /// Set value of Gyro_Rate_Yaw
    #[inline(always)]
    pub fn set_gyro_rate_yaw(&mut self, value: f32) -> Result<(), CanError> {
        if value < -327_f32 || 327_f32 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGyroRates::MESSAGE_ID });
        }
        let factor = 0.01_f32;
        let offset = 0_f32;
        let value = ((value - offset) / factor) as i16;
        
        let value = u16::from_ne_bytes(value.to_ne_bytes());
        self.raw.view_bits_mut::<Lsb0>()[16..32].store_le(value);
        Ok(())
    }
    
    /// Accuracy_Gyro_Rates
    ///
    /// Dimensionless.  Lower values imply but do not guarantee better accuracy than higher values.
    ///
    /// - Min: 0
    /// - Max: 0
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn accuracy_gyro_rates(&self) -> u8 {
        self.accuracy_gyro_rates_raw()
    }
    
    /// Get raw value of Accuracy_Gyro_Rates
    ///
    /// - Start bit: 8
    /// - Signal size: 8 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn accuracy_gyro_rates_raw(&self) -> u8 {
        let signal = self.raw.view_bits::<Lsb0>()[8..16].load_le::<u8>();
        
        let factor = 1;
        u8::from(signal).saturating_mul(factor).saturating_add(0)
    }
    
    /// Set value of Accuracy_Gyro_Rates
    #[inline(always)]
    pub fn set_accuracy_gyro_rates(&mut self, value: u8) -> Result<(), CanError> {
        if value < 0_u8 || 0_u8 < value {
            return Err(CanError::ParameterOutOfRange { message_id: RtSbGyroRates::MESSAGE_ID });
        }
        let factor = 1;
        let value = value.checked_sub(0)
            .ok_or(CanError::ParameterOutOfRange { message_id: RtSbGyroRates::MESSAGE_ID })?;
        let value = (value / factor) as u8;
        
        self.raw.view_bits_mut::<Lsb0>()[8..16].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Roll
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_roll(&self) -> bool {
        self.validity_gyro_rate_roll_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Roll
    ///
    /// - Start bit: 2
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_roll_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[2..3].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Roll
    #[inline(always)]
    pub fn set_validity_gyro_rate_roll(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[2..3].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Pitch
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_pitch(&self) -> bool {
        self.validity_gyro_rate_pitch_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Pitch
    ///
    /// - Start bit: 1
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_pitch_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[1..2].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Pitch
    #[inline(always)]
    pub fn set_validity_gyro_rate_pitch(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[1..2].store_le(value);
        Ok(())
    }
    
    /// Validity_Gyro_Rate_Yaw
    ///
    /// Valid when bit is set, invalid when bit is clear.
    ///
    /// - Min: 0
    /// - Max: 1
    /// - Unit: ""
    /// - Receivers: Vector__XXX
    #[inline(always)]
    pub fn validity_gyro_rate_yaw(&self) -> bool {
        self.validity_gyro_rate_yaw_raw()
    }
    
    /// Get raw value of Validity_Gyro_Rate_Yaw
    ///
    /// - Start bit: 0
    /// - Signal size: 1 bits
    /// - Factor: 1
    /// - Offset: 0
    /// - Byte order: LittleEndian
    /// - Value type: Unsigned
    #[inline(always)]
    pub fn validity_gyro_rate_yaw_raw(&self) -> bool {
        let signal = self.raw.view_bits::<Lsb0>()[0..1].load_le::<u8>();
        
        signal == 1
    }
    
    /// Set value of Validity_Gyro_Rate_Yaw
    #[inline(always)]
    pub fn set_validity_gyro_rate_yaw(&mut self, value: bool) -> Result<(), CanError> {
        let value = value as u8;
        self.raw.view_bits_mut::<Lsb0>()[0..1].store_le(value);
        Ok(())
    }
    
}

impl core::convert::TryFrom<&[u8]> for RtSbGyroRates {
    type Error = CanError;
    
    #[inline(always)]
    fn try_from(payload: &[u8]) -> Result<Self, Self::Error> {
        if payload.len() != 8 { return Err(CanError::InvalidPayloadSize); }
        let mut raw = [0u8; 8];
        raw.copy_from_slice(&payload[..8]);
        Ok(Self { raw })
    }
}

impl embedded_can::Frame for RtSbGyroRates {
    fn new(id: impl Into<Id>, data: &[u8]) -> Option<Self> {
        if id.into() != Self::MESSAGE_ID {
            None
        } else {
            data.try_into().ok()
        }
    }

    fn new_remote(_id: impl Into<Id>, _dlc: usize) -> Option<Self> {
        unimplemented!()
    }

    fn is_extended(&self) -> bool {
        match self.id() {
            Id::Standard(_) => false,
            Id::Extended(_) => true,
        }
    }

    fn is_remote_frame(&self) -> bool {
        false
    }

    fn id(&self) -> Id {
        Self::MESSAGE_ID
    }

    fn dlc(&self) -> usize {
        self.raw.len()
    }

    fn data(&self) -> &[u8] {
        &self.raw
    }
}


/// This is just to make testing easier
#[allow(dead_code)]
fn main() {}

#[allow(dead_code)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum CanError {
    UnknownMessageId(embedded_can::Id),
    /// Signal parameter is not within the range
    /// defined in the dbc
    ParameterOutOfRange {
        /// dbc message id
        message_id: embedded_can::Id,
    },
    InvalidPayloadSize,
    /// Multiplexor value not defined in the dbc
    InvalidMultiplexor {
        /// dbc message id
        message_id: embedded_can::Id,
        /// Multiplexor value not defined in the dbc
        multiplexor: u16,
    },
}

impl core::fmt::Display for CanError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{self:?}")
    }
}

